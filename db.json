{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/assets/img/favicon.png","path":"assets/img/favicon.png","modified":0,"renderable":0},{"_id":"source/assets/img/kunkun.jpg","path":"assets/img/kunkun.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/zhifubao.jpg","path":"assets/img/zhifubao.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/wechat.jpg","path":"assets/img/wechat.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f68c56098a0f5b77c0e7bead0c035b36447c6de7","modified":1549178206091},{"_id":"source/_posts/Java集合源码系列-ArrayList.md","hash":"b6d406ba601717d75df1aab4bb51012137b97cde","modified":1549178206091},{"_id":"source/_posts/Java集合源码系列-HashMap.md","hash":"0614a14ea8a40d62fdb384c3a1d9dea9f3045da4","modified":1549178206091},{"_id":"source/_posts/Java集合源码系列-LinkedList.md","hash":"6013b47643b8e1b7777142253936a3bc4e3feb19","modified":1549202013446},{"_id":"source/_posts/Python多线程.md","hash":"1086ca356bddbcb5fe23ecd9ee12e63605d2cfee","modified":1549178206091},{"_id":"source/_posts/Python装饰器-decorator.md","hash":"2430004fa56bd93bb77ab3919d72446ffe791907","modified":1549178206091},{"_id":"source/_posts/descriptor.md","hash":"9ea02fa84d686b55349cb126a8d6f24fd776be53","modified":1549178206091},{"_id":"source/_posts/gunicorn源码阅读.md","hash":"a4b5e5d9f1ce4dc0421d18b055f4260240764251","modified":1549178206091},{"_id":"source/_posts/《redis设计与实现》笔记.md","hash":"9b6e13db68e9e81afb0c9c5208f26e179817fb94","modified":1549178206095},{"_id":"source/_posts/再见，2018.md","hash":"7e8cf515d0e622237030b99b2d03cf0b82d59025","modified":1549178206095},{"_id":"source/_posts/常用排序算法总结.md","hash":"4019ecee3e736f40749bc5a355e7ba2f2efbd787","modified":1549178206095},{"_id":"source/_posts/建站.md","hash":"65b0545ace85fa852ca6df67fccb9e7e49c42e22","modified":1549178206095},{"_id":"source/assets/.DS_Store","hash":"ed720eba0f76925d33ee3da941d43c31155671d7","modified":1549178206095},{"_id":"source/assets/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1549178206095},{"_id":"source/assets/img/favicon.png","hash":"fb2ff5fdcc6ca23d7c36ca43a7d3a9d712fd5a0c","modified":1549178206095},{"_id":"source/assets/img/kunkun.jpg","hash":"38c5bfb3ae033da62023e71b11cf762af8510dbc","modified":1549178206095},{"_id":"source/assets/img/zhifubao.jpg","hash":"11f4aa4f0c2f9e3e5f7d87425687d6c1f01329b8","modified":1549178206095},{"_id":"source/assets/img/wechat.jpg","hash":"04e21140a68361a22e227a7d8080d9a220fc9afa","modified":1549178206095},{"_id":"public/content.json","hash":"59248c57cd6bc587ba5de559128165d04d645b81","modified":1549248526670},{"_id":"public/2019/02/03/Java集合源码系列-LinkedList/index.html","hash":"8a938a3b020730a5736ebb7ef843805a9b30f15a","modified":1549248659929},{"_id":"public/2019/01/22/Java集合源码系列-ArrayList/index.html","hash":"0e07d7cb4f15525e6c082defc1d9e62f4b189f53","modified":1549248659929},{"_id":"public/2019/01/12/Java集合源码系列-HashMap/index.html","hash":"ac0d9a5ced148daa358236aa29db26b6e3088437","modified":1549248659930},{"_id":"public/2019/01/01/再见，2018/index.html","hash":"a1390475dc961705590f6baaaa138047d7ee3289","modified":1549248659930},{"_id":"public/2018/11/05/《redis设计与实现》笔记/index.html","hash":"edadbde9acc3692d6598461ee44e7bb16fee239e","modified":1549248659930},{"_id":"public/2018/08/13/gunicorn源码阅读/index.html","hash":"ed256d9770e8ba1f488348c09fe12e97d36f1718","modified":1549248659930},{"_id":"public/2018/07/13/descriptor/index.html","hash":"133494566005539f0ea2e94a7d61deda576a8bcf","modified":1549248659930},{"_id":"public/2018/05/29/Python多线程/index.html","hash":"19e8ceacaedadb30916dd7bc24612e0d569feefe","modified":1549248659930},{"_id":"public/2018/05/29/Python装饰器-decorator/index.html","hash":"a8840ecad36b9af47c9b1b7f18f03e7cffcea2df","modified":1549248659931},{"_id":"public/2018/05/29/常用排序算法总结/index.html","hash":"83a81eac1df28c0920298a4a8784155cd3875641","modified":1549248659931},{"_id":"public/2018/05/29/建站/index.html","hash":"9e759ac5d41a93bad749448f58124ea306923acd","modified":1549248659931},{"_id":"public/archives/index.html","hash":"a32f94ac477b3ef816a5d2aa0f515ec44b673865","modified":1549248659931},{"_id":"public/archives/page/2/index.html","hash":"a1534adc1b719c63daa8fe51a119d06a0615432e","modified":1549248659931},{"_id":"public/archives/2018/index.html","hash":"744fea080ab34819aa4c3b83554984d459df5c8a","modified":1549248659931},{"_id":"public/archives/2018/05/index.html","hash":"5b7f6cb421ba5c001f7ee62182f1fbcad703fa6f","modified":1549248659931},{"_id":"public/archives/2018/07/index.html","hash":"577943b1321bb2fc1e42fbe957ab72f61843ddf4","modified":1549248659931},{"_id":"public/archives/2018/08/index.html","hash":"ac3a7ced14a75f5d018fd274d4862b918ba6a265","modified":1549248659932},{"_id":"public/archives/2018/11/index.html","hash":"3c08d53488d73ca1f7a746aa6abfcad06df7dea2","modified":1549248659932},{"_id":"public/archives/2019/index.html","hash":"ea9c382fb00993e8244a11287d6cca2fc7a47210","modified":1549248659932},{"_id":"public/archives/2019/01/index.html","hash":"c82747767328d544885955a0b3a06b1e8e8f3cc6","modified":1549248659932},{"_id":"public/archives/2019/02/index.html","hash":"8d285bdc5754b232f0b10cd3789aaa4e59d013aa","modified":1549248659932},{"_id":"public/index.html","hash":"dd874f7d0a7a943263b996a1565ca809b7da11c9","modified":1549248659932},{"_id":"public/page/2/index.html","hash":"436a40462b6e0b03c157341d59824e55cf225f1a","modified":1549248659932},{"_id":"public/tags/Python/index.html","hash":"f48c5e257340cc72eb8fb0e9b86b4ff745b8dd56","modified":1549248659932},{"_id":"public/tags/redis/index.html","hash":"2ceb8946f983ffb8f337186aab978fc87cffb170","modified":1549248659932},{"_id":"public/tags/数据库/index.html","hash":"53f3501e9689887d7d116ed5920c2dac2b917edf","modified":1549248659933},{"_id":"public/tags/随笔/index.html","hash":"54e9aeee3eb03f0fca48e9ea016842faefba47be","modified":1549248659933},{"_id":"public/tags/Java/index.html","hash":"045f17e5445ac2e8c11c45102a66476ca26017bc","modified":1549248659933},{"_id":"public/tags/Java源码/index.html","hash":"4d139231b323899730cb241e6b0155224f65feee","modified":1549248659933},{"_id":"public/tags/数据结构/index.html","hash":"f64fc9f80739fcc496583cbf3fac5b9bd838c353","modified":1549248659933},{"_id":"public/tags/算法/index.html","hash":"7f8a5cf46227e01b81e2270f336bb42fdf0e2a2e","modified":1549248659933},{"_id":"public/assets/img/favicon.png","hash":"fb2ff5fdcc6ca23d7c36ca43a7d3a9d712fd5a0c","modified":1549248526689},{"_id":"public/assets/img/kunkun.jpg","hash":"38c5bfb3ae033da62023e71b11cf762af8510dbc","modified":1549248526689},{"_id":"public/assets/img/zhifubao.jpg","hash":"11f4aa4f0c2f9e3e5f7d87425687d6c1f01329b8","modified":1549248526698},{"_id":"public/assets/img/wechat.jpg","hash":"04e21140a68361a22e227a7d8080d9a220fc9afa","modified":1549248526698},{"_id":"themes/yilia/.DS_Store","hash":"b88f2a372ee372ebb98a8d2d3d5b5259d7dcad09","modified":1549178206099},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1549178206099},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1549178206099},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1549178206099},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1549178206099},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1549178206099},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1549178206099},{"_id":"themes/yilia/_config.yml","hash":"e46d7a87017f2b3e2a14775171e8b51bd0af27a3","modified":1549178206099},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1549178206103},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1549178206107},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1549178206099},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1549178206099},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1549178206099},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1549178206099},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1549178206099},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1549178206099},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1549178206099},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1549178206103},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1549178206103},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1549178206103},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1549178206103},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1549178206103},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1549178206103},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1549178206103},{"_id":"themes/yilia/source/.DS_Store","hash":"88cf3667a35c1e131ea9417ef911425fa057afdf","modified":1549178206103},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1549178206107},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1549178206103},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1549178206103},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1549178206103},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549178206103},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1549178206103},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1549178206103},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1549178206103},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1549178206103},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1549178206099},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1549178206103},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1549178206103},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1549178206103},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1549178206103},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1549178206103},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1549178206103},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1549178206103},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1549178206103},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1549178206103},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1549178206103},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1549178206103},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1549178206103},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1549178206103},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1549178206103},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1549178206103},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1549178206103},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1549178206103},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1549178206103},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1549178206103},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1549178206103},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1549178206103},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1549178206103},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1549178206103},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1549178206103},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1549178206103},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1549178206103},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1549178206103},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1549178206103},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1549178206103},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1549178206103},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1549178206103},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1549178206103},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1549178206103},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1549178206103},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1549178206103},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1549178206103},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1549178206103},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1549178206103},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1549178206103},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1549178206103},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1549178206103},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1549178206103},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1549178206103},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1549178206103},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1549178206103},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1549178206103},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1549178206103},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1549178206103},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1549178206103},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1549178206099},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1549178206099},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1549178206103},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1549178206103},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1549178206103},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1549178206103},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1549178206103},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1549178206103},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1549178206103},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1549178206103},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1549178206103},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1549178206103},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1549178206103},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1549178206103},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1549248659938},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1549248659938},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1549248659938},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1549248659938},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1549248659938},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1549248659938},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1549248659938},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1549248659938},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1549248659939},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1549248659942},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1549248659943},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1549248659943},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1549248659944}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Python descriptor 描述符","date":"2018-07-13T03:44:18.000Z","_content":"\n最近看Flask源码时发现很多不熟悉的语法，其中一个就是描述符，在config.py中出现，描述符的用处很多，是Python中很多特性的底层机制，如`properties`, `methods`, `static methods`, `class methods`和`super()`。\n\n### 什么是描述符\n\n描述符一般是一个有绑定动作的属性对象，这个属性的获取、赋值、删除操作和途径被描述符协议重写。对象属性的正常获取顺序是这样的，比如想要获取`a.x`,那么首先查找`a.__dict__['x']`,如果找不到则查看`type(a).__dict__['x']`,如果还没有则查看父类的`__dict__`。\n\nPython中有很多协议，比如迭代对象的迭代器协议，上下文管理协议等，都是靠重写类中以`__`开头和结尾的魔法方法来实现的。描述符协议也不例外，只要实现了`__get__(self, instance, owner)`、`__set__(self, instance, value)`、`__delete__(self, instance)`中任意一个或全部的方法，这个类就变成了一个描述符。如果只定义了`__get__`,则这是一个`non-data descriptor`，定义了`__get__`和`__set__`两个方法的是`data descriptor`，这里的区别，后面会提到。实现这些方法后，对属性进行操作时就不走正常途径，而是调用这几个魔法方法。需要注意的是，描述符必须是一个新式类。\n\n<!--more-->\n\n### 为什么需要描述符\n\n写过的Java的应该有一些印象，类里的属性一般是`private`的，如果想要拿到这个属性，一般是通过一个`public`的`get_xxx`方法来获得属性，重新赋值时也是一个道理。但是这样虽然隐藏了属性，但是后续写代码时都得用`object.get_xxx()`来获取值，而不是`object.attr`,显然第二种方式更简单，更美观，所以Python这种简洁的语言就提供了这样的更简洁的实现方式---描述符协议。\n\n还有一种情况，假设有一个`Person`类，它有一个`age`属性，那么在对年龄赋值时是有一些限制的，比如必须是整数，必须大于0。所以应该在赋值时进行检查，这么一看好像赋值时又需要通过方法`xiaoming.age=cls.examine_age(1000)`,又不美观了，而描述符协议可以在背地里帮我们做这种检查，而我们还是可以使用`xiaoming.age=1000`这个更简洁的语句。\n\n这里有个我之前一直困惑的地方提一下，可能你们觉得不难，但是确实干扰了我很久。那就是这三个魔法方法定义在什么地方，还是回到上面那个例子，好像只有`Person`是一个类，所以我之前一直觉得应该定义在`Person`类中，但其实不是。魔法方法应该定义在一个`Age`类中，然后`age`属性是一个`Age`对象实例。\n\n```python\nclass Age(object):\n    def __init__(self, age):\n        self.age = age\n\n    def __get__(self, instance, owner):\n        print('instance={}, owner={}'.format(instance, owner))\n        return self.age\n\n    def __set__(self, instance, value):\n        print('instance={}, value={}'.format(instance, value))\n        if value < 0:\n            raise AttributeError('age should > 0')\n        self.age = value\n\n\nclass Person(object):\n    age = Age(100)\n\n\nxiaoming = Person()\nxiaoming.age = 10\nprint(xiaoming)\nprint(xiaoming.age)\n\n# output::::::::\n# >>> instance=<__main__.Person object at 0x107a24310>, value=10\n# >>> <__main__.Person object at 0x107a24310>\n# >>> instance=<__main__.Person object at 0x107a24310>, owner=<class '__main__.Person'>\n# >>> 10\n```\n方法中的`instance`属性返回的是获取属性的那个对象，在这里就是`xiaoming`，`owner`是获取属性的对象的类，在这里就是`Person`。\n\n### 描述符的调用机制\n\n上面提到了非描述符属性的获取途径，定义了描述符协议后，`obj.b`的操作将调用`b.__get__(obj)`这个方法来获取属性。描述符的调用机制根据调用对象是**对象**还是**类**有一些区别。\n\n描述符是通过`type.__getattribute__()`方法被调用，这也是为什么描述符必须是在新式类中的原因，继承自`object`的类被称为新式类，否则没有这个方法，则无法调用描述符的方法。\n\n对于对象来说，`object.__getattribute__()`会将`b.x` 转换为 `type(b).__dict__['x'].__get__(b, type(b))`。这个转换通过下面这样的一个优先链：`data descriptors`大于实例变量，实例变量大于 `non-data descriptors`，如果存在`__getattr__()`，则`__getattr__()`优先级最低。完整的C实现在[`PyObject_GenericGetAttr()`](https://docs.python.org/2/c-api/object.html#c.PyObject_GenericGetAttr \"PyObject_GenericGetAttr\") in [Objects/object.c](https://github.com/python/cpython/tree/2.7/Objects/object.c).\n\n对于类来说，`object.__getattribute__()`会将 `B.x` 转换为`B.__dict__['x'].__get__(None, B)`。Python实现如下：\n```python\ndef __getattribute__(self, key):\n    \"Emulate type_getattro() in Objects/typeobject.c\"\n    v = object.__getattribute__(self, key)\n    if hasattr(v, '__get__'):\n        return v.__get__(None, self)\n    return v\n```\n### 描述符实例\n\n上面提到了一个最简单的描述符实例，就是对属性进行取值或者赋值时进行额外的操作，同时保持代码的简洁。描述符在Python语言中本来也有很多的应用，但是能力不够，不能很好的理解其中的奥妙，就不误导大家了。主要是`Property`,`Function and method`和`static method and class method`这几个方面，给出链接，有兴趣的可以钻研一下。\n\n### 参考链接\n\n[Python Descriptors, Part 1 of 2](http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/)\n\n[Descriptor HowTo Guide](https://docs.python.org/2/howto/descriptor.html)\n\n\n","source":"_posts/descriptor.md","raw":"---\ntitle: Python descriptor 描述符\ndate: 2018-07-13 11:44:18\ntags:\n    - Python\n---\n\n最近看Flask源码时发现很多不熟悉的语法，其中一个就是描述符，在config.py中出现，描述符的用处很多，是Python中很多特性的底层机制，如`properties`, `methods`, `static methods`, `class methods`和`super()`。\n\n### 什么是描述符\n\n描述符一般是一个有绑定动作的属性对象，这个属性的获取、赋值、删除操作和途径被描述符协议重写。对象属性的正常获取顺序是这样的，比如想要获取`a.x`,那么首先查找`a.__dict__['x']`,如果找不到则查看`type(a).__dict__['x']`,如果还没有则查看父类的`__dict__`。\n\nPython中有很多协议，比如迭代对象的迭代器协议，上下文管理协议等，都是靠重写类中以`__`开头和结尾的魔法方法来实现的。描述符协议也不例外，只要实现了`__get__(self, instance, owner)`、`__set__(self, instance, value)`、`__delete__(self, instance)`中任意一个或全部的方法，这个类就变成了一个描述符。如果只定义了`__get__`,则这是一个`non-data descriptor`，定义了`__get__`和`__set__`两个方法的是`data descriptor`，这里的区别，后面会提到。实现这些方法后，对属性进行操作时就不走正常途径，而是调用这几个魔法方法。需要注意的是，描述符必须是一个新式类。\n\n<!--more-->\n\n### 为什么需要描述符\n\n写过的Java的应该有一些印象，类里的属性一般是`private`的，如果想要拿到这个属性，一般是通过一个`public`的`get_xxx`方法来获得属性，重新赋值时也是一个道理。但是这样虽然隐藏了属性，但是后续写代码时都得用`object.get_xxx()`来获取值，而不是`object.attr`,显然第二种方式更简单，更美观，所以Python这种简洁的语言就提供了这样的更简洁的实现方式---描述符协议。\n\n还有一种情况，假设有一个`Person`类，它有一个`age`属性，那么在对年龄赋值时是有一些限制的，比如必须是整数，必须大于0。所以应该在赋值时进行检查，这么一看好像赋值时又需要通过方法`xiaoming.age=cls.examine_age(1000)`,又不美观了，而描述符协议可以在背地里帮我们做这种检查，而我们还是可以使用`xiaoming.age=1000`这个更简洁的语句。\n\n这里有个我之前一直困惑的地方提一下，可能你们觉得不难，但是确实干扰了我很久。那就是这三个魔法方法定义在什么地方，还是回到上面那个例子，好像只有`Person`是一个类，所以我之前一直觉得应该定义在`Person`类中，但其实不是。魔法方法应该定义在一个`Age`类中，然后`age`属性是一个`Age`对象实例。\n\n```python\nclass Age(object):\n    def __init__(self, age):\n        self.age = age\n\n    def __get__(self, instance, owner):\n        print('instance={}, owner={}'.format(instance, owner))\n        return self.age\n\n    def __set__(self, instance, value):\n        print('instance={}, value={}'.format(instance, value))\n        if value < 0:\n            raise AttributeError('age should > 0')\n        self.age = value\n\n\nclass Person(object):\n    age = Age(100)\n\n\nxiaoming = Person()\nxiaoming.age = 10\nprint(xiaoming)\nprint(xiaoming.age)\n\n# output::::::::\n# >>> instance=<__main__.Person object at 0x107a24310>, value=10\n# >>> <__main__.Person object at 0x107a24310>\n# >>> instance=<__main__.Person object at 0x107a24310>, owner=<class '__main__.Person'>\n# >>> 10\n```\n方法中的`instance`属性返回的是获取属性的那个对象，在这里就是`xiaoming`，`owner`是获取属性的对象的类，在这里就是`Person`。\n\n### 描述符的调用机制\n\n上面提到了非描述符属性的获取途径，定义了描述符协议后，`obj.b`的操作将调用`b.__get__(obj)`这个方法来获取属性。描述符的调用机制根据调用对象是**对象**还是**类**有一些区别。\n\n描述符是通过`type.__getattribute__()`方法被调用，这也是为什么描述符必须是在新式类中的原因，继承自`object`的类被称为新式类，否则没有这个方法，则无法调用描述符的方法。\n\n对于对象来说，`object.__getattribute__()`会将`b.x` 转换为 `type(b).__dict__['x'].__get__(b, type(b))`。这个转换通过下面这样的一个优先链：`data descriptors`大于实例变量，实例变量大于 `non-data descriptors`，如果存在`__getattr__()`，则`__getattr__()`优先级最低。完整的C实现在[`PyObject_GenericGetAttr()`](https://docs.python.org/2/c-api/object.html#c.PyObject_GenericGetAttr \"PyObject_GenericGetAttr\") in [Objects/object.c](https://github.com/python/cpython/tree/2.7/Objects/object.c).\n\n对于类来说，`object.__getattribute__()`会将 `B.x` 转换为`B.__dict__['x'].__get__(None, B)`。Python实现如下：\n```python\ndef __getattribute__(self, key):\n    \"Emulate type_getattro() in Objects/typeobject.c\"\n    v = object.__getattribute__(self, key)\n    if hasattr(v, '__get__'):\n        return v.__get__(None, self)\n    return v\n```\n### 描述符实例\n\n上面提到了一个最简单的描述符实例，就是对属性进行取值或者赋值时进行额外的操作，同时保持代码的简洁。描述符在Python语言中本来也有很多的应用，但是能力不够，不能很好的理解其中的奥妙，就不误导大家了。主要是`Property`,`Function and method`和`static method and class method`这几个方面，给出链接，有兴趣的可以钻研一下。\n\n### 参考链接\n\n[Python Descriptors, Part 1 of 2](http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/)\n\n[Descriptor HowTo Guide](https://docs.python.org/2/howto/descriptor.html)\n\n\n","slug":"descriptor","published":1,"updated":"2019-02-03T07:16:46.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqklkq0000uetuhg9epzvu","content":"<p>最近看Flask源码时发现很多不熟悉的语法，其中一个就是描述符，在config.py中出现，描述符的用处很多，是Python中很多特性的底层机制，如<code>properties</code>, <code>methods</code>, <code>static methods</code>, <code>class methods</code>和<code>super()</code>。</p>\n<h3 id=\"什么是描述符\"><a href=\"#什么是描述符\" class=\"headerlink\" title=\"什么是描述符\"></a>什么是描述符</h3><p>描述符一般是一个有绑定动作的属性对象，这个属性的获取、赋值、删除操作和途径被描述符协议重写。对象属性的正常获取顺序是这样的，比如想要获取<code>a.x</code>,那么首先查找<code>a.__dict__[&#39;x&#39;]</code>,如果找不到则查看<code>type(a).__dict__[&#39;x&#39;]</code>,如果还没有则查看父类的<code>__dict__</code>。</p>\n<p>Python中有很多协议，比如迭代对象的迭代器协议，上下文管理协议等，都是靠重写类中以<code>__</code>开头和结尾的魔法方法来实现的。描述符协议也不例外，只要实现了<code>__get__(self, instance, owner)</code>、<code>__set__(self, instance, value)</code>、<code>__delete__(self, instance)</code>中任意一个或全部的方法，这个类就变成了一个描述符。如果只定义了<code>__get__</code>,则这是一个<code>non-data descriptor</code>，定义了<code>__get__</code>和<code>__set__</code>两个方法的是<code>data descriptor</code>，这里的区别，后面会提到。实现这些方法后，对属性进行操作时就不走正常途径，而是调用这几个魔法方法。需要注意的是，描述符必须是一个新式类。</p>\n<a id=\"more\"></a>\n<h3 id=\"为什么需要描述符\"><a href=\"#为什么需要描述符\" class=\"headerlink\" title=\"为什么需要描述符\"></a>为什么需要描述符</h3><p>写过的Java的应该有一些印象，类里的属性一般是<code>private</code>的，如果想要拿到这个属性，一般是通过一个<code>public</code>的<code>get_xxx</code>方法来获得属性，重新赋值时也是一个道理。但是这样虽然隐藏了属性，但是后续写代码时都得用<code>object.get_xxx()</code>来获取值，而不是<code>object.attr</code>,显然第二种方式更简单，更美观，所以Python这种简洁的语言就提供了这样的更简洁的实现方式—描述符协议。</p>\n<p>还有一种情况，假设有一个<code>Person</code>类，它有一个<code>age</code>属性，那么在对年龄赋值时是有一些限制的，比如必须是整数，必须大于0。所以应该在赋值时进行检查，这么一看好像赋值时又需要通过方法<code>xiaoming.age=cls.examine_age(1000)</code>,又不美观了，而描述符协议可以在背地里帮我们做这种检查，而我们还是可以使用<code>xiaoming.age=1000</code>这个更简洁的语句。</p>\n<p>这里有个我之前一直困惑的地方提一下，可能你们觉得不难，但是确实干扰了我很久。那就是这三个魔法方法定义在什么地方，还是回到上面那个例子，好像只有<code>Person</code>是一个类，所以我之前一直觉得应该定义在<code>Person</code>类中，但其实不是。魔法方法应该定义在一个<code>Age</code>类中，然后<code>age</code>属性是一个<code>Age</code>对象实例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Age</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, age)</span>:</span></span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'instance=&#123;&#125;, owner=&#123;&#125;'</span>.format(instance, owner))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.age</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, instance, value)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'instance=&#123;&#125;, value=&#123;&#125;'</span>.format(instance, value))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">'age should &gt; 0'</span>)</span><br><span class=\"line\">        self.age = value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    age = Age(<span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">xiaoming = Person()</span><br><span class=\"line\">xiaoming.age = <span class=\"number\">10</span></span><br><span class=\"line\">print(xiaoming)</span><br><span class=\"line\">print(xiaoming.age)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output::::::::</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; instance=&lt;__main__.Person object at 0x107a24310&gt;, value=10</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; &lt;__main__.Person object at 0x107a24310&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; instance=&lt;__main__.Person object at 0x107a24310&gt;, owner=&lt;class '__main__.Person'&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; 10</span></span><br></pre></td></tr></table></figure>\n<p>方法中的<code>instance</code>属性返回的是获取属性的那个对象，在这里就是<code>xiaoming</code>，<code>owner</code>是获取属性的对象的类，在这里就是<code>Person</code>。</p>\n<h3 id=\"描述符的调用机制\"><a href=\"#描述符的调用机制\" class=\"headerlink\" title=\"描述符的调用机制\"></a>描述符的调用机制</h3><p>上面提到了非描述符属性的获取途径，定义了描述符协议后，<code>obj.b</code>的操作将调用<code>b.__get__(obj)</code>这个方法来获取属性。描述符的调用机制根据调用对象是<strong>对象</strong>还是<strong>类</strong>有一些区别。</p>\n<p>描述符是通过<code>type.__getattribute__()</code>方法被调用，这也是为什么描述符必须是在新式类中的原因，继承自<code>object</code>的类被称为新式类，否则没有这个方法，则无法调用描述符的方法。</p>\n<p>对于对象来说，<code>object.__getattribute__()</code>会将<code>b.x</code> 转换为 <code>type(b).__dict__[&#39;x&#39;].__get__(b, type(b))</code>。这个转换通过下面这样的一个优先链：<code>data descriptors</code>大于实例变量，实例变量大于 <code>non-data descriptors</code>，如果存在<code>__getattr__()</code>，则<code>__getattr__()</code>优先级最低。完整的C实现在<a href=\"https://docs.python.org/2/c-api/object.html#c.PyObject_GenericGetAttr\" title=\"PyObject_GenericGetAttr\" target=\"_blank\" rel=\"noopener\"><code>PyObject_GenericGetAttr()</code></a> in <a href=\"https://github.com/python/cpython/tree/2.7/Objects/object.c\" target=\"_blank\" rel=\"noopener\">Objects/object.c</a>.</p>\n<p>对于类来说，<code>object.__getattribute__()</code>会将 <code>B.x</code> 转换为<code>B.__dict__[&#39;x&#39;].__get__(None, B)</code>。Python实现如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattribute__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"Emulate type_getattro() in Objects/typeobject.c\"</span></span><br><span class=\"line\">    v = object.__getattribute__(self, key)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(v, <span class=\"string\">'__get__'</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.__get__(<span class=\"keyword\">None</span>, self)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"描述符实例\"><a href=\"#描述符实例\" class=\"headerlink\" title=\"描述符实例\"></a>描述符实例</h3><p>上面提到了一个最简单的描述符实例，就是对属性进行取值或者赋值时进行额外的操作，同时保持代码的简洁。描述符在Python语言中本来也有很多的应用，但是能力不够，不能很好的理解其中的奥妙，就不误导大家了。主要是<code>Property</code>,<code>Function and method</code>和<code>static method and class method</code>这几个方面，给出链接，有兴趣的可以钻研一下。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/\" target=\"_blank\" rel=\"noopener\">Python Descriptors, Part 1 of 2</a></p>\n<p><a href=\"https://docs.python.org/2/howto/descriptor.html\" target=\"_blank\" rel=\"noopener\">Descriptor HowTo Guide</a></p>\n","site":{"data":{}},"excerpt":"<p>最近看Flask源码时发现很多不熟悉的语法，其中一个就是描述符，在config.py中出现，描述符的用处很多，是Python中很多特性的底层机制，如<code>properties</code>, <code>methods</code>, <code>static methods</code>, <code>class methods</code>和<code>super()</code>。</p>\n<h3 id=\"什么是描述符\"><a href=\"#什么是描述符\" class=\"headerlink\" title=\"什么是描述符\"></a>什么是描述符</h3><p>描述符一般是一个有绑定动作的属性对象，这个属性的获取、赋值、删除操作和途径被描述符协议重写。对象属性的正常获取顺序是这样的，比如想要获取<code>a.x</code>,那么首先查找<code>a.__dict__[&#39;x&#39;]</code>,如果找不到则查看<code>type(a).__dict__[&#39;x&#39;]</code>,如果还没有则查看父类的<code>__dict__</code>。</p>\n<p>Python中有很多协议，比如迭代对象的迭代器协议，上下文管理协议等，都是靠重写类中以<code>__</code>开头和结尾的魔法方法来实现的。描述符协议也不例外，只要实现了<code>__get__(self, instance, owner)</code>、<code>__set__(self, instance, value)</code>、<code>__delete__(self, instance)</code>中任意一个或全部的方法，这个类就变成了一个描述符。如果只定义了<code>__get__</code>,则这是一个<code>non-data descriptor</code>，定义了<code>__get__</code>和<code>__set__</code>两个方法的是<code>data descriptor</code>，这里的区别，后面会提到。实现这些方法后，对属性进行操作时就不走正常途径，而是调用这几个魔法方法。需要注意的是，描述符必须是一个新式类。</p>","more":"<h3 id=\"为什么需要描述符\"><a href=\"#为什么需要描述符\" class=\"headerlink\" title=\"为什么需要描述符\"></a>为什么需要描述符</h3><p>写过的Java的应该有一些印象，类里的属性一般是<code>private</code>的，如果想要拿到这个属性，一般是通过一个<code>public</code>的<code>get_xxx</code>方法来获得属性，重新赋值时也是一个道理。但是这样虽然隐藏了属性，但是后续写代码时都得用<code>object.get_xxx()</code>来获取值，而不是<code>object.attr</code>,显然第二种方式更简单，更美观，所以Python这种简洁的语言就提供了这样的更简洁的实现方式—描述符协议。</p>\n<p>还有一种情况，假设有一个<code>Person</code>类，它有一个<code>age</code>属性，那么在对年龄赋值时是有一些限制的，比如必须是整数，必须大于0。所以应该在赋值时进行检查，这么一看好像赋值时又需要通过方法<code>xiaoming.age=cls.examine_age(1000)</code>,又不美观了，而描述符协议可以在背地里帮我们做这种检查，而我们还是可以使用<code>xiaoming.age=1000</code>这个更简洁的语句。</p>\n<p>这里有个我之前一直困惑的地方提一下，可能你们觉得不难，但是确实干扰了我很久。那就是这三个魔法方法定义在什么地方，还是回到上面那个例子，好像只有<code>Person</code>是一个类，所以我之前一直觉得应该定义在<code>Person</code>类中，但其实不是。魔法方法应该定义在一个<code>Age</code>类中，然后<code>age</code>属性是一个<code>Age</code>对象实例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Age</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, age)</span>:</span></span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'instance=&#123;&#125;, owner=&#123;&#125;'</span>.format(instance, owner))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.age</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, instance, value)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'instance=&#123;&#125;, value=&#123;&#125;'</span>.format(instance, value))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">'age should &gt; 0'</span>)</span><br><span class=\"line\">        self.age = value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    age = Age(<span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">xiaoming = Person()</span><br><span class=\"line\">xiaoming.age = <span class=\"number\">10</span></span><br><span class=\"line\">print(xiaoming)</span><br><span class=\"line\">print(xiaoming.age)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output::::::::</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; instance=&lt;__main__.Person object at 0x107a24310&gt;, value=10</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; &lt;__main__.Person object at 0x107a24310&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; instance=&lt;__main__.Person object at 0x107a24310&gt;, owner=&lt;class '__main__.Person'&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; 10</span></span><br></pre></td></tr></table></figure>\n<p>方法中的<code>instance</code>属性返回的是获取属性的那个对象，在这里就是<code>xiaoming</code>，<code>owner</code>是获取属性的对象的类，在这里就是<code>Person</code>。</p>\n<h3 id=\"描述符的调用机制\"><a href=\"#描述符的调用机制\" class=\"headerlink\" title=\"描述符的调用机制\"></a>描述符的调用机制</h3><p>上面提到了非描述符属性的获取途径，定义了描述符协议后，<code>obj.b</code>的操作将调用<code>b.__get__(obj)</code>这个方法来获取属性。描述符的调用机制根据调用对象是<strong>对象</strong>还是<strong>类</strong>有一些区别。</p>\n<p>描述符是通过<code>type.__getattribute__()</code>方法被调用，这也是为什么描述符必须是在新式类中的原因，继承自<code>object</code>的类被称为新式类，否则没有这个方法，则无法调用描述符的方法。</p>\n<p>对于对象来说，<code>object.__getattribute__()</code>会将<code>b.x</code> 转换为 <code>type(b).__dict__[&#39;x&#39;].__get__(b, type(b))</code>。这个转换通过下面这样的一个优先链：<code>data descriptors</code>大于实例变量，实例变量大于 <code>non-data descriptors</code>，如果存在<code>__getattr__()</code>，则<code>__getattr__()</code>优先级最低。完整的C实现在<a href=\"https://docs.python.org/2/c-api/object.html#c.PyObject_GenericGetAttr\" title=\"PyObject_GenericGetAttr\" target=\"_blank\" rel=\"noopener\"><code>PyObject_GenericGetAttr()</code></a> in <a href=\"https://github.com/python/cpython/tree/2.7/Objects/object.c\" target=\"_blank\" rel=\"noopener\">Objects/object.c</a>.</p>\n<p>对于类来说，<code>object.__getattribute__()</code>会将 <code>B.x</code> 转换为<code>B.__dict__[&#39;x&#39;].__get__(None, B)</code>。Python实现如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattribute__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"Emulate type_getattro() in Objects/typeobject.c\"</span></span><br><span class=\"line\">    v = object.__getattribute__(self, key)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(v, <span class=\"string\">'__get__'</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.__get__(<span class=\"keyword\">None</span>, self)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"描述符实例\"><a href=\"#描述符实例\" class=\"headerlink\" title=\"描述符实例\"></a>描述符实例</h3><p>上面提到了一个最简单的描述符实例，就是对属性进行取值或者赋值时进行额外的操作，同时保持代码的简洁。描述符在Python语言中本来也有很多的应用，但是能力不够，不能很好的理解其中的奥妙，就不误导大家了。主要是<code>Property</code>,<code>Function and method</code>和<code>static method and class method</code>这几个方面，给出链接，有兴趣的可以钻研一下。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/\" target=\"_blank\" rel=\"noopener\">Python Descriptors, Part 1 of 2</a></p>\n<p><a href=\"https://docs.python.org/2/howto/descriptor.html\" target=\"_blank\" rel=\"noopener\">Descriptor HowTo Guide</a></p>"},{"title":"《redis设计与实现》笔记","date":"2018-11-05T05:19:29.000Z","_content":"\n记录阅读这本书时\b觉得有用的东西，也许很零散。(第一部分)\n\n## 字符串\n\nredis的字符串底层实现为简单动态字符串`simple-dynamic-string`。\n```c\nstruct sdshdr{\n    int len; 字符个数，不包括‘/0’\n    int free; 没有使用的字符个数\n    char buf[]; 字符数组\n}\n```\n\n<!--more-->\n\n### 空间预分配\n\n空间预分配用于优化SDS的字符串增长操作。\n1. 如果对sds修改后，len小于1MB，那么分配与len同样大小的未使用空间。buf的长度变为`len+buf+1`\n2. 如果修改后，lend大于等于1MB,那么分配1MB的未使用空间。buf的长度变为`len+1MB+1byte`\n\n### 惰性空间释放\n\n用于优化SDS的字符串缩短操作\n1. 进行缩短操作时，不减少buf的长度，将缩短的部分加入free。\n2. 同时提供了真正释放未使用空间的API，\b不用担心内存浪费\n\n### C字符串与SDS对比\n\n| C字符串 | SDS |\n| ------ | ------ |\n| 获取字符串长度复杂度O(n) | 复杂度O(1) |\n| API不安全，可能缓冲区溢出 |  API安全     |\n| 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要N次内存重分配 |\n| 只能保存文本数据 | 可以保存文本或者二进制数据 |\n| 可以使用所有<string.h>库中的函数 | 可以使用部分 |\n\n## 链表\n\n链表在redis中应用广泛，当一个列表键包含了数量较多的元素，又或者列表包含的元素都是比较长的字符串时，redis就会用链表作为列表键的底层实现。\n\n### 特性\n\n1. 双向， 无环\n1. 有表头，表尾指针\n1. 带链表长度计数器\n1. 多态，可以保存不同类型的值\n\n## 字典\n\n应用广泛。整个数据库就是一个kv数据库，其次哈希键这个数据结构的底层也是字典。\n\n哈希表结构\n```c\ntypedef struct dictht {\n    // 哈希表数组\n    dictEntry **table;\n\n    // 哈希表大小\n    unsigned long size;\n\n    // 哈希表大小掩码，用于计算索引值，总是等于size-1\n    unsigned long sizemask;\n\n    // 该哈希表已有节点数量\n    unsigned long used;\n} dictht;\n```\n\n哈希表节点结构\n```c\ntypedef struct dictEntry {\n    void *key;\n\n    union(\n        void *val;\n        uint64_tu64;\n        int64_ts64;\n    ) v;\n\n    struvt dictEntry *next;\n} dictEntry;\n```\n\n字典结构\n```c\ntypedef struct dict {\n    // 类型特定函数\n    dictType *type;\n\n    // 私有数据\n    void *privdata;\n\n    // 哈希表\n    dictht ht[2];\n\n    // rehash索引， 当rehash不在进行时，值为-1\n    int trehashidx;\n} dict;\n```\n\n字典保存在ht[0]中，ht[1]用来对哈希表进行rehash。使用MurmueHash算法。数组+链表的方式解决哈希冲突。\n\n### rehash优化-渐进式rehash\n\n如果字典表过大，一次完成rehash会造成数据库在一段时间停止服务。步骤如下：\n\n1. 为ht[1]分配空间\n1. 在字典中维持一个索引计数器变量rehashidx，并将值置为0\n1. 在rehash期间，每次对字典进行添加删除，查找或者更新操作时，顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，完成后rehashidx+1\n1. 最终全部rehash到ht[1]， 将rehashidx设为-1表示完成。把ht[0]的哈希表指向ht[1]的哈希表，ht[1]指向null。\n\n## 压缩列表\n\n压缩列表是列表和哈希的底层实现之一，当一个列表键只包含少量列表项，并且是小整数值或短字符串。同时满足以下两点，使用压缩链表。\n\n1. 列表对象保存的所有字符串长度都小于64字节\n1. 列表对象保存的元素数量小于512个\n\n## 跳跃表\n\nredis使用跳跃表作为有序集合的底层实现之一，同时也用在集群节点中用作内部数据结构。可以参考网上跳表数据结构分析。（个人感觉与二分的思想是一致的，有序情况下降低复杂度）\n\n## set\n\n集合数据结构靠字典实现，集合的值为字典的键，对应的值为null。","source":"_posts/《redis设计与实现》笔记.md","raw":"---\ntitle: 《redis设计与实现》笔记\ndate: 2018-11-05 13:19:29\ntags:\n    - redis\n    - 数据库\n---\n\n记录阅读这本书时\b觉得有用的东西，也许很零散。(第一部分)\n\n## 字符串\n\nredis的字符串底层实现为简单动态字符串`simple-dynamic-string`。\n```c\nstruct sdshdr{\n    int len; 字符个数，不包括‘/0’\n    int free; 没有使用的字符个数\n    char buf[]; 字符数组\n}\n```\n\n<!--more-->\n\n### 空间预分配\n\n空间预分配用于优化SDS的字符串增长操作。\n1. 如果对sds修改后，len小于1MB，那么分配与len同样大小的未使用空间。buf的长度变为`len+buf+1`\n2. 如果修改后，lend大于等于1MB,那么分配1MB的未使用空间。buf的长度变为`len+1MB+1byte`\n\n### 惰性空间释放\n\n用于优化SDS的字符串缩短操作\n1. 进行缩短操作时，不减少buf的长度，将缩短的部分加入free。\n2. 同时提供了真正释放未使用空间的API，\b不用担心内存浪费\n\n### C字符串与SDS对比\n\n| C字符串 | SDS |\n| ------ | ------ |\n| 获取字符串长度复杂度O(n) | 复杂度O(1) |\n| API不安全，可能缓冲区溢出 |  API安全     |\n| 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要N次内存重分配 |\n| 只能保存文本数据 | 可以保存文本或者二进制数据 |\n| 可以使用所有<string.h>库中的函数 | 可以使用部分 |\n\n## 链表\n\n链表在redis中应用广泛，当一个列表键包含了数量较多的元素，又或者列表包含的元素都是比较长的字符串时，redis就会用链表作为列表键的底层实现。\n\n### 特性\n\n1. 双向， 无环\n1. 有表头，表尾指针\n1. 带链表长度计数器\n1. 多态，可以保存不同类型的值\n\n## 字典\n\n应用广泛。整个数据库就是一个kv数据库，其次哈希键这个数据结构的底层也是字典。\n\n哈希表结构\n```c\ntypedef struct dictht {\n    // 哈希表数组\n    dictEntry **table;\n\n    // 哈希表大小\n    unsigned long size;\n\n    // 哈希表大小掩码，用于计算索引值，总是等于size-1\n    unsigned long sizemask;\n\n    // 该哈希表已有节点数量\n    unsigned long used;\n} dictht;\n```\n\n哈希表节点结构\n```c\ntypedef struct dictEntry {\n    void *key;\n\n    union(\n        void *val;\n        uint64_tu64;\n        int64_ts64;\n    ) v;\n\n    struvt dictEntry *next;\n} dictEntry;\n```\n\n字典结构\n```c\ntypedef struct dict {\n    // 类型特定函数\n    dictType *type;\n\n    // 私有数据\n    void *privdata;\n\n    // 哈希表\n    dictht ht[2];\n\n    // rehash索引， 当rehash不在进行时，值为-1\n    int trehashidx;\n} dict;\n```\n\n字典保存在ht[0]中，ht[1]用来对哈希表进行rehash。使用MurmueHash算法。数组+链表的方式解决哈希冲突。\n\n### rehash优化-渐进式rehash\n\n如果字典表过大，一次完成rehash会造成数据库在一段时间停止服务。步骤如下：\n\n1. 为ht[1]分配空间\n1. 在字典中维持一个索引计数器变量rehashidx，并将值置为0\n1. 在rehash期间，每次对字典进行添加删除，查找或者更新操作时，顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，完成后rehashidx+1\n1. 最终全部rehash到ht[1]， 将rehashidx设为-1表示完成。把ht[0]的哈希表指向ht[1]的哈希表，ht[1]指向null。\n\n## 压缩列表\n\n压缩列表是列表和哈希的底层实现之一，当一个列表键只包含少量列表项，并且是小整数值或短字符串。同时满足以下两点，使用压缩链表。\n\n1. 列表对象保存的所有字符串长度都小于64字节\n1. 列表对象保存的元素数量小于512个\n\n## 跳跃表\n\nredis使用跳跃表作为有序集合的底层实现之一，同时也用在集群节点中用作内部数据结构。可以参考网上跳表数据结构分析。（个人感觉与二分的思想是一致的，有序情况下降低复杂度）\n\n## set\n\n集合数据结构靠字典实现，集合的值为字典的键，对应的值为null。","slug":"《redis设计与实现》笔记","published":1,"updated":"2019-02-03T07:16:46.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqklku0001uetuhojcxbhy","content":"<p>记录阅读这本书时\b觉得有用的东西，也许很零散。(第一部分)</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>redis的字符串底层实现为简单动态字符串<code>simple-dynamic-string</code>。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len; 字符个数，不包括‘/<span class=\"number\">0</span>’</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>; 没有使用的字符个数</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[]; 字符数组</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h3><p>空间预分配用于优化SDS的字符串增长操作。</p>\n<ol>\n<li>如果对sds修改后，len小于1MB，那么分配与len同样大小的未使用空间。buf的长度变为<code>len+buf+1</code></li>\n<li>如果修改后，lend大于等于1MB,那么分配1MB的未使用空间。buf的长度变为<code>len+1MB+1byte</code></li>\n</ol>\n<h3 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h3><p>用于优化SDS的字符串缩短操作</p>\n<ol>\n<li>进行缩短操作时，不减少buf的长度，将缩短的部分加入free。</li>\n<li>同时提供了真正释放未使用空间的API，\b不用担心内存浪费</li>\n</ol>\n<h3 id=\"C字符串与SDS对比\"><a href=\"#C字符串与SDS对比\" class=\"headerlink\" title=\"C字符串与SDS对比\"></a>C字符串与SDS对比</h3><table>\n<thead>\n<tr>\n<th>C字符串</th>\n<th>SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取字符串长度复杂度O(n)</td>\n<td>复杂度O(1)</td>\n</tr>\n<tr>\n<td>API不安全，可能缓冲区溢出</td>\n<td>API安全</td>\n</tr>\n<tr>\n<td>修改字符串长度N次必然需要执行N次内存重分配</td>\n<td>修改字符串长度N次最多需要N次内存重分配</td>\n</tr>\n<tr>\n<td>只能保存文本数据</td>\n<td>可以保存文本或者二进制数据</td>\n</tr>\n<tr>\n<td>可以使用所有&lt;string.h&gt;库中的函数</td>\n<td>可以使用部分</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表在redis中应用广泛，当一个列表键包含了数量较多的元素，又或者列表包含的元素都是比较长的字符串时，redis就会用链表作为列表键的底层实现。</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li>双向， 无环</li>\n<li>有表头，表尾指针</li>\n<li>带链表长度计数器</li>\n<li>多态，可以保存不同类型的值</li>\n</ol>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>应用广泛。整个数据库就是一个kv数据库，其次哈希键这个数据结构的底层也是字典。</p>\n<p>哈希表结构<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure></p>\n<p>哈希表节点结构<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">union</span>(</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        uint64_tu64;</span><br><span class=\"line\">        int64_ts64;</span><br><span class=\"line\">    ) v;</span><br><span class=\"line\"></span><br><span class=\"line\">    struvt dictEntry *next;</span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>字典结构<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// rehash索引， 当rehash不在进行时，值为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> trehashidx;</span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure></p>\n<p>字典保存在ht[0]中，ht[1]用来对哈希表进行rehash。使用MurmueHash算法。数组+链表的方式解决哈希冲突。</p>\n<h3 id=\"rehash优化-渐进式rehash\"><a href=\"#rehash优化-渐进式rehash\" class=\"headerlink\" title=\"rehash优化-渐进式rehash\"></a>rehash优化-渐进式rehash</h3><p>如果字典表过大，一次完成rehash会造成数据库在一段时间停止服务。步骤如下：</p>\n<ol>\n<li>为ht[1]分配空间</li>\n<li>在字典中维持一个索引计数器变量rehashidx，并将值置为0</li>\n<li>在rehash期间，每次对字典进行添加删除，查找或者更新操作时，顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，完成后rehashidx+1</li>\n<li>最终全部rehash到ht[1]， 将rehashidx设为-1表示完成。把ht[0]的哈希表指向ht[1]的哈希表，ht[1]指向null。</li>\n</ol>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表是列表和哈希的底层实现之一，当一个列表键只包含少量列表项，并且是小整数值或短字符串。同时满足以下两点，使用压缩链表。</p>\n<ol>\n<li>列表对象保存的所有字符串长度都小于64字节</li>\n<li>列表对象保存的元素数量小于512个</li>\n</ol>\n<h2 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h2><p>redis使用跳跃表作为有序集合的底层实现之一，同时也用在集群节点中用作内部数据结构。可以参考网上跳表数据结构分析。（个人感觉与二分的思想是一致的，有序情况下降低复杂度）</p>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p>集合数据结构靠字典实现，集合的值为字典的键，对应的值为null。</p>\n","site":{"data":{}},"excerpt":"<p>记录阅读这本书时\b觉得有用的东西，也许很零散。(第一部分)</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>redis的字符串底层实现为简单动态字符串<code>simple-dynamic-string</code>。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len; 字符个数，不包括‘/<span class=\"number\">0</span>’</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>; 没有使用的字符个数</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[]; 字符数组</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","more":"<h3 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h3><p>空间预分配用于优化SDS的字符串增长操作。</p>\n<ol>\n<li>如果对sds修改后，len小于1MB，那么分配与len同样大小的未使用空间。buf的长度变为<code>len+buf+1</code></li>\n<li>如果修改后，lend大于等于1MB,那么分配1MB的未使用空间。buf的长度变为<code>len+1MB+1byte</code></li>\n</ol>\n<h3 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h3><p>用于优化SDS的字符串缩短操作</p>\n<ol>\n<li>进行缩短操作时，不减少buf的长度，将缩短的部分加入free。</li>\n<li>同时提供了真正释放未使用空间的API，\b不用担心内存浪费</li>\n</ol>\n<h3 id=\"C字符串与SDS对比\"><a href=\"#C字符串与SDS对比\" class=\"headerlink\" title=\"C字符串与SDS对比\"></a>C字符串与SDS对比</h3><table>\n<thead>\n<tr>\n<th>C字符串</th>\n<th>SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取字符串长度复杂度O(n)</td>\n<td>复杂度O(1)</td>\n</tr>\n<tr>\n<td>API不安全，可能缓冲区溢出</td>\n<td>API安全</td>\n</tr>\n<tr>\n<td>修改字符串长度N次必然需要执行N次内存重分配</td>\n<td>修改字符串长度N次最多需要N次内存重分配</td>\n</tr>\n<tr>\n<td>只能保存文本数据</td>\n<td>可以保存文本或者二进制数据</td>\n</tr>\n<tr>\n<td>可以使用所有&lt;string.h&gt;库中的函数</td>\n<td>可以使用部分</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表在redis中应用广泛，当一个列表键包含了数量较多的元素，又或者列表包含的元素都是比较长的字符串时，redis就会用链表作为列表键的底层实现。</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li>双向， 无环</li>\n<li>有表头，表尾指针</li>\n<li>带链表长度计数器</li>\n<li>多态，可以保存不同类型的值</li>\n</ol>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>应用广泛。整个数据库就是一个kv数据库，其次哈希键这个数据结构的底层也是字典。</p>\n<p>哈希表结构<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure></p>\n<p>哈希表节点结构<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">union</span>(</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        uint64_tu64;</span><br><span class=\"line\">        int64_ts64;</span><br><span class=\"line\">    ) v;</span><br><span class=\"line\"></span><br><span class=\"line\">    struvt dictEntry *next;</span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>字典结构<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// rehash索引， 当rehash不在进行时，值为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> trehashidx;</span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure></p>\n<p>字典保存在ht[0]中，ht[1]用来对哈希表进行rehash。使用MurmueHash算法。数组+链表的方式解决哈希冲突。</p>\n<h3 id=\"rehash优化-渐进式rehash\"><a href=\"#rehash优化-渐进式rehash\" class=\"headerlink\" title=\"rehash优化-渐进式rehash\"></a>rehash优化-渐进式rehash</h3><p>如果字典表过大，一次完成rehash会造成数据库在一段时间停止服务。步骤如下：</p>\n<ol>\n<li>为ht[1]分配空间</li>\n<li>在字典中维持一个索引计数器变量rehashidx，并将值置为0</li>\n<li>在rehash期间，每次对字典进行添加删除，查找或者更新操作时，顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，完成后rehashidx+1</li>\n<li>最终全部rehash到ht[1]， 将rehashidx设为-1表示完成。把ht[0]的哈希表指向ht[1]的哈希表，ht[1]指向null。</li>\n</ol>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表是列表和哈希的底层实现之一，当一个列表键只包含少量列表项，并且是小整数值或短字符串。同时满足以下两点，使用压缩链表。</p>\n<ol>\n<li>列表对象保存的所有字符串长度都小于64字节</li>\n<li>列表对象保存的元素数量小于512个</li>\n</ol>\n<h2 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h2><p>redis使用跳跃表作为有序集合的底层实现之一，同时也用在集群节点中用作内部数据结构。可以参考网上跳表数据结构分析。（个人感觉与二分的思想是一致的，有序情况下降低复杂度）</p>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p>集合数据结构靠字典实现，集合的值为字典的键，对应的值为null。</p>"},{"title":"建站","date":"2018-05-29T09:11:59.000Z","_content":"# 建站\n\n折腾了一天终于在5月29日17:00的时候完成了这个博客，一个简单的hexo静态博客。之前我也自己写过一个博客，但是无奈于界面太过丑陋，于是就有了这个，现在文章有点空，我把之前的文章先移植几篇过来充充数，以后继续更新。\n\n测试一下\n```python\na, b = 1, 2\nprint(a)\n```","source":"_posts/建站.md","raw":"---\ntitle: 建站\ndate: 2018-05-29 17:11:59\ntags:\n     - 随笔\n---\n# 建站\n\n折腾了一天终于在5月29日17:00的时候完成了这个博客，一个简单的hexo静态博客。之前我也自己写过一个博客，但是无奈于界面太过丑陋，于是就有了这个，现在文章有点空，我把之前的文章先移植几篇过来充充数，以后继续更新。\n\n测试一下\n```python\na, b = 1, 2\nprint(a)\n```","slug":"建站","published":1,"updated":"2019-02-03T07:16:46.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqklkx0003uetux7nbehh2","content":"<h1 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h1><p>折腾了一天终于在5月29日17:00的时候完成了这个博客，一个简单的hexo静态博客。之前我也自己写过一个博客，但是无奈于界面太过丑陋，于是就有了这个，现在文章有点空，我把之前的文章先移植几篇过来充充数，以后继续更新。</p>\n<p>测试一下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, b = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h1><p>折腾了一天终于在5月29日17:00的时候完成了这个博客，一个简单的hexo静态博客。之前我也自己写过一个博客，但是无奈于界面太过丑陋，于是就有了这个，现在文章有点空，我把之前的文章先移植几篇过来充充数，以后继续更新。</p>\n<p>测试一下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, b = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Java集合源码系列-ArrayList","date":"2019-01-22T15:02:45.000Z","_content":"\n## 前言\n\n这是Java集合源码系列的第二篇，\b第一篇分析了HashMap，本来想把TreeMap和HashMap这几个Map实现分析一下，但是一个是红黑树的一个是不常用的类，想想就不浪费这个时间了。后面有时间有能力可以尝试分析下更有意义的`ConcurrentHashMap`。不过这篇文章将要分析的是经常用到的`ArrayList`。\n\n## 概览\n\n`ArrayList`是一个列表，底层是一个大小可以改变的数组类型。而数组类型在内存中的地址是连续的，可以通过数组下标直接计算出地址，所以可以以O(1)的时间复杂度进行**get**操作，但是**add**操作，需要对插入下标之后的数据进行向后移动，所以平均时间复杂度将会是O(n)。而列表的另外一种实现`LinkedList`则是采用双向链表，靠指针将前后数据连接起来，但数据在内存中并不是连续存放的，这种方式对插入和删除的操作友好，但是**get**的性能稍差。\n\n下面还是按照之前的思路，从使用`ArrayList`的整个生命周期来作为行文路线，即创建-->添加-->获取-->删除。\n\n<!--more-->\n\n### 创建\n\n使用`ArrayList`的第一步就是创建一个该类的对象，那么先来看下他的构造函数吧。一共有三个构造函数。\n\n```java\n// 无参构造函数是最常用的构造函数\n// elementData即为底层存储数据的数组，无参构造函数将一个空数组赋值它，它的大小将在第一个元素被添加时指定，后面会提到\ntransient Object[] elementData;\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n// 指定数组大小的构造函数，这里的EMPTY_ELEMENTDATA与上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA虽然值一样，但是名字不一样，先记住这一点，后面在添加元素的时候会介绍到\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n// 通过已经存在的collection创建ArrayList\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n### 添加元素\n\n构造函数还是比较简单的，但是也留了一个问题，`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`和`EMPTY_ELEMENTDATA`值明明是一样的，为什么需要两个呢？？将在这里解开谜底。\n\n```java\n// 最常用的是不带index的add方法，将元素追加到末尾,size是实例变量，初始化时为0\nprivate int size; // size变量记录元素的数量\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);\n// 确保容量后，元素添加到size++的位置，即末尾添加\n    elementData[size++] = e;\n\n    return true;\n}\n// add()调用ensureCapacityInternal()\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n// 这里就解答了上面的提到的问题，如果elementData指向的是ensureExplicitCapacity，即ArrayList是通过无参构造函数生成的，那么在第一次添加元素的时候，数组的默认大小设为10。因为第一次添加元素时minCapacity=size+1=1 < 10.\nprivate static final int DEFAULT_CAPACITY = 10;\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n// modCount变量的作用是记录修改的次数，包括添加，删除等操作，修改值不记录，用于使用迭代器时的fail-fast\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n// 数组容量不够时进行扩容\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n// 扩容1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n// 第一次扩容时，elementData.length为0，minCapacity为10，所以数组大小最终会被设置为minCapacity\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n// MAX_ARRAY_SIZE需要减8的原因在注释中提到了，有些虚拟机的实现需要将一些头部字段存到数组中，因此留出一些空间，避免出现OutOfMemoryError错误\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n// 如果扩容后的数组大小大于MAX_ARRAY_SIZE,进行hugeCapacity调整\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0)\n        throw new OutOfMemoryError();\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n上面的那部分是以追加的方式在末尾添加元素，现在看下在指定下标处添加元素的代码\n\n```java\npublic void add(int index, E element) {\n    rangeCheckForAdd(index); \n    ensureCapacityInternal(size + 1);\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n// 调用系统的数组复制方法将原数组中index及之后的所有元素，向后移动一格，所以ArrayList在插入元素时的性能逊于LinkedList\n    elementData[index] = element;\n    size++;\n}\n// add方法首先校验index的合法性，对于不合法的index抛出异常，给出index和size信息\nprivate void rangeCheckForAdd(int index) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\nprivate String outOfBoundsMsg(int index) {\n    return \"Index: \"+index+\", Size: \"+size;\n}\n// add方法然后调用ensureCapacityInternal进行保证内部容量的合适的验证，该方法前面介绍到，不再次介绍\n```\n\n除了上面介绍的两个add方法，还有两个个addAll方法，其实实现方式是一样的，就简单的贴下代码，大家稍微看下就能明白跟前面的方法几乎是一样的。\n\n```java\n public boolean addAll(Collection<? extends E> c) {\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    ensureCapacityInternal(size + numNew);  // Increments modCount\n    System.arraycopy(a, 0, elementData, size, numNew);\n    size += numNew;\n    return numNew != 0;\n}\npublic boolean addAll(int index, Collection<? extends E> c) {\n    rangeCheckForAdd(index);\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    ensureCapacityInternal(size + numNew);  // Increments modCount\n    int numMoved = size - index;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index, elementData, index + numNew,\n                         numMoved);\n    System.arraycopy(a, 0, elementData, index, numNew);\n    size += numNew;\n    return numNew != 0;\n}\n```\n\n### 获取元素\n\n前面的几个代码片段已经把添加元素都分析完了，还是不难的。现在看一下如何取出刚才添加的元素呢？\n\n```java\n// 因为是底层是数组，所以取出元素的代码更加简单，直接通过数组下标获取，然后进行类型转换后返回\npublic E get(int index) {\n    rangeCheck(index);\n    return elementData(index);\n}\nprivate void rangeCheck(int index) {\n    if (index >= size)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n// 将元素类型转换后返回\nE elementData(int index) {\n    return (E) elementData[index];\n}\n```\n\n前面介绍的是根据指定下标找元素，其实还可以通过指定元素找元素对应的下标\n\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n// 从前向后遍历，找到第一个equal的元素后返回其下标，可以查找null对象，找不到时返回-1\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n// 从后向前遍历，逻辑一样\npublic int lastIndexOf(Object o) {\n    if (o == null) {\n        for (int i = size-1; i >= 0; i--)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = size-1; i >= 0; i--)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n\n#### for-each遍历\n\n```java\n@Override\npublic void forEach(Consumer<? super E> action) {\n    Objects.requireNonNull(action);\n// action 为 null时抛出NullPointerException\n    final int expectedModCount = modCount;\n// 记录遍历时modCount的值，遍历时不允许对数组进行添加，删除等修改结构的操作\n    @SuppressWarnings(\"unchecked\")\n    final E[] elementData = (E[]) this.elementData;\n    final int size = this.size;\n// 遍历数组，对每个元素进行action方法相关的操作，并判断modCount没有修改过\n    for (int i=0; modCount == expectedModCount && i < size; i++) {\n        action.accept(elementData[i]);\n    }\n// 遍历过程中发现modCount被修改过，抛出异常\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n```\n\n### 删除元素\n\n介绍完了获取元素，现在来看下如何删除元素\n\n```java\n// 根据下标删除元素\npublic E remove(int index) {\n    rangeCheck(index); // 确保index<size\n    modCount++; // 进行修改操作时modCount++\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n// 将index+1到最后一个元素全都向前移动一格\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n}\n// 根据对象删除\npublic boolean remove(Object o) {\n// 如果找到该元素返回true，反之返回false，删除逻辑都是调用了fastRomeve\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n// fastRemove的取名还挺形象，跟remove(index)相比，省去了校验index合法性的步骤，直接进行移位\nprivate void fastRemove(int index) {\n    modCount++; // 修改次数+1\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n// 清除所有元素\npublic void clear() {\n    modCount++;\n    // clear to let GC do its work\n    for (int i = 0; i < size; i++)\n        elementData[i] = null;\n    size = 0;\n}\n// 把修改值的方法也放入删除的分类里吧，可以看出修改值的操作不会对modCount进行修改\npublic E set(int index, E element) {\n    rangeCheck(index); // 验证index合法性\n    E oldValue = elementData(index);\n    elementData[index] = element; // 直接替换旧值\n    return oldValue;\n}\n// 移除collection c中所有的元素\npublic boolean removeAll(Collection<?> c) {\n    Objects.requireNonNull(c);\n    return batchRemove(c, false);\n}\nprivate boolean batchRemove(Collection<?> c, boolean complement) {\n    final Object[] elementData = this.elementData;\n    int r = 0, w = 0;\n    boolean modified = false;\n    try {\n        for (; r < size; r++)\n// 遍历elementData，如果元素不存在c中，赋值给elementData[w]，w++,这里巧妙的是w<=r，所以不会丢失值\n            if (c.contains(elementData[r]) == complement)\n                elementData[w++] = elementData[r];\n    } finally {\n// 按理说r是等于size的，源码注释中解释这个finally语句的目的是兼容AbstractCollection，因为c.contains可能会抛出异常\n        if (r != size) {\n            System.arraycopy(elementData, r,\n                             elementData, w,\n                             size - r);\n            w += size - r;\n        }\n        if (w != size) {\n            for (int i = w; i < size; i++)\n                elementData[i] = null;\n            modCount += size - w;\n            size = w;\n            modified = true;\n        }\n    }\n    return modified;\n}\n```\n\n### 总结\n\n`ArrayList`源码中除了迭代器的部分，已经差不多都分析完了，相比于`HashMap`来说简单了很多，因为其底层的数据结构是数组，没有任何其他东西，所以实现较为简单。那么需要注意的就是什么场景使用`ArrayList`，什么场景使用`LinkedList`.\b`ArrayList`适合按序插入及频繁的通过index的查找的场景，而`LinkedList`适合随机的插入与删除元素的场景。\n\n### 往期回顾\n\n* [Java集合源码系列-HashMap](https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/)\n\n### 欢迎关注我的公众号\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![技术旅途](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","source":"_posts/Java集合源码系列-ArrayList.md","raw":"---\ntitle: Java集合源码系列-ArrayList\ndate: 2019-01-22 23:02:45\ntags:\n    - Java\n    - Java源码\n---\n\n## 前言\n\n这是Java集合源码系列的第二篇，\b第一篇分析了HashMap，本来想把TreeMap和HashMap这几个Map实现分析一下，但是一个是红黑树的一个是不常用的类，想想就不浪费这个时间了。后面有时间有能力可以尝试分析下更有意义的`ConcurrentHashMap`。不过这篇文章将要分析的是经常用到的`ArrayList`。\n\n## 概览\n\n`ArrayList`是一个列表，底层是一个大小可以改变的数组类型。而数组类型在内存中的地址是连续的，可以通过数组下标直接计算出地址，所以可以以O(1)的时间复杂度进行**get**操作，但是**add**操作，需要对插入下标之后的数据进行向后移动，所以平均时间复杂度将会是O(n)。而列表的另外一种实现`LinkedList`则是采用双向链表，靠指针将前后数据连接起来，但数据在内存中并不是连续存放的，这种方式对插入和删除的操作友好，但是**get**的性能稍差。\n\n下面还是按照之前的思路，从使用`ArrayList`的整个生命周期来作为行文路线，即创建-->添加-->获取-->删除。\n\n<!--more-->\n\n### 创建\n\n使用`ArrayList`的第一步就是创建一个该类的对象，那么先来看下他的构造函数吧。一共有三个构造函数。\n\n```java\n// 无参构造函数是最常用的构造函数\n// elementData即为底层存储数据的数组，无参构造函数将一个空数组赋值它，它的大小将在第一个元素被添加时指定，后面会提到\ntransient Object[] elementData;\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n// 指定数组大小的构造函数，这里的EMPTY_ELEMENTDATA与上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA虽然值一样，但是名字不一样，先记住这一点，后面在添加元素的时候会介绍到\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n// 通过已经存在的collection创建ArrayList\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n### 添加元素\n\n构造函数还是比较简单的，但是也留了一个问题，`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`和`EMPTY_ELEMENTDATA`值明明是一样的，为什么需要两个呢？？将在这里解开谜底。\n\n```java\n// 最常用的是不带index的add方法，将元素追加到末尾,size是实例变量，初始化时为0\nprivate int size; // size变量记录元素的数量\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);\n// 确保容量后，元素添加到size++的位置，即末尾添加\n    elementData[size++] = e;\n\n    return true;\n}\n// add()调用ensureCapacityInternal()\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n// 这里就解答了上面的提到的问题，如果elementData指向的是ensureExplicitCapacity，即ArrayList是通过无参构造函数生成的，那么在第一次添加元素的时候，数组的默认大小设为10。因为第一次添加元素时minCapacity=size+1=1 < 10.\nprivate static final int DEFAULT_CAPACITY = 10;\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n// modCount变量的作用是记录修改的次数，包括添加，删除等操作，修改值不记录，用于使用迭代器时的fail-fast\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n// 数组容量不够时进行扩容\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n// 扩容1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n// 第一次扩容时，elementData.length为0，minCapacity为10，所以数组大小最终会被设置为minCapacity\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n// MAX_ARRAY_SIZE需要减8的原因在注释中提到了，有些虚拟机的实现需要将一些头部字段存到数组中，因此留出一些空间，避免出现OutOfMemoryError错误\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n// 如果扩容后的数组大小大于MAX_ARRAY_SIZE,进行hugeCapacity调整\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0)\n        throw new OutOfMemoryError();\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n上面的那部分是以追加的方式在末尾添加元素，现在看下在指定下标处添加元素的代码\n\n```java\npublic void add(int index, E element) {\n    rangeCheckForAdd(index); \n    ensureCapacityInternal(size + 1);\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n// 调用系统的数组复制方法将原数组中index及之后的所有元素，向后移动一格，所以ArrayList在插入元素时的性能逊于LinkedList\n    elementData[index] = element;\n    size++;\n}\n// add方法首先校验index的合法性，对于不合法的index抛出异常，给出index和size信息\nprivate void rangeCheckForAdd(int index) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\nprivate String outOfBoundsMsg(int index) {\n    return \"Index: \"+index+\", Size: \"+size;\n}\n// add方法然后调用ensureCapacityInternal进行保证内部容量的合适的验证，该方法前面介绍到，不再次介绍\n```\n\n除了上面介绍的两个add方法，还有两个个addAll方法，其实实现方式是一样的，就简单的贴下代码，大家稍微看下就能明白跟前面的方法几乎是一样的。\n\n```java\n public boolean addAll(Collection<? extends E> c) {\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    ensureCapacityInternal(size + numNew);  // Increments modCount\n    System.arraycopy(a, 0, elementData, size, numNew);\n    size += numNew;\n    return numNew != 0;\n}\npublic boolean addAll(int index, Collection<? extends E> c) {\n    rangeCheckForAdd(index);\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    ensureCapacityInternal(size + numNew);  // Increments modCount\n    int numMoved = size - index;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index, elementData, index + numNew,\n                         numMoved);\n    System.arraycopy(a, 0, elementData, index, numNew);\n    size += numNew;\n    return numNew != 0;\n}\n```\n\n### 获取元素\n\n前面的几个代码片段已经把添加元素都分析完了，还是不难的。现在看一下如何取出刚才添加的元素呢？\n\n```java\n// 因为是底层是数组，所以取出元素的代码更加简单，直接通过数组下标获取，然后进行类型转换后返回\npublic E get(int index) {\n    rangeCheck(index);\n    return elementData(index);\n}\nprivate void rangeCheck(int index) {\n    if (index >= size)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n// 将元素类型转换后返回\nE elementData(int index) {\n    return (E) elementData[index];\n}\n```\n\n前面介绍的是根据指定下标找元素，其实还可以通过指定元素找元素对应的下标\n\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n// 从前向后遍历，找到第一个equal的元素后返回其下标，可以查找null对象，找不到时返回-1\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n// 从后向前遍历，逻辑一样\npublic int lastIndexOf(Object o) {\n    if (o == null) {\n        for (int i = size-1; i >= 0; i--)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = size-1; i >= 0; i--)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n\n#### for-each遍历\n\n```java\n@Override\npublic void forEach(Consumer<? super E> action) {\n    Objects.requireNonNull(action);\n// action 为 null时抛出NullPointerException\n    final int expectedModCount = modCount;\n// 记录遍历时modCount的值，遍历时不允许对数组进行添加，删除等修改结构的操作\n    @SuppressWarnings(\"unchecked\")\n    final E[] elementData = (E[]) this.elementData;\n    final int size = this.size;\n// 遍历数组，对每个元素进行action方法相关的操作，并判断modCount没有修改过\n    for (int i=0; modCount == expectedModCount && i < size; i++) {\n        action.accept(elementData[i]);\n    }\n// 遍历过程中发现modCount被修改过，抛出异常\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n```\n\n### 删除元素\n\n介绍完了获取元素，现在来看下如何删除元素\n\n```java\n// 根据下标删除元素\npublic E remove(int index) {\n    rangeCheck(index); // 确保index<size\n    modCount++; // 进行修改操作时modCount++\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n// 将index+1到最后一个元素全都向前移动一格\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n}\n// 根据对象删除\npublic boolean remove(Object o) {\n// 如果找到该元素返回true，反之返回false，删除逻辑都是调用了fastRomeve\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n// fastRemove的取名还挺形象，跟remove(index)相比，省去了校验index合法性的步骤，直接进行移位\nprivate void fastRemove(int index) {\n    modCount++; // 修改次数+1\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n// 清除所有元素\npublic void clear() {\n    modCount++;\n    // clear to let GC do its work\n    for (int i = 0; i < size; i++)\n        elementData[i] = null;\n    size = 0;\n}\n// 把修改值的方法也放入删除的分类里吧，可以看出修改值的操作不会对modCount进行修改\npublic E set(int index, E element) {\n    rangeCheck(index); // 验证index合法性\n    E oldValue = elementData(index);\n    elementData[index] = element; // 直接替换旧值\n    return oldValue;\n}\n// 移除collection c中所有的元素\npublic boolean removeAll(Collection<?> c) {\n    Objects.requireNonNull(c);\n    return batchRemove(c, false);\n}\nprivate boolean batchRemove(Collection<?> c, boolean complement) {\n    final Object[] elementData = this.elementData;\n    int r = 0, w = 0;\n    boolean modified = false;\n    try {\n        for (; r < size; r++)\n// 遍历elementData，如果元素不存在c中，赋值给elementData[w]，w++,这里巧妙的是w<=r，所以不会丢失值\n            if (c.contains(elementData[r]) == complement)\n                elementData[w++] = elementData[r];\n    } finally {\n// 按理说r是等于size的，源码注释中解释这个finally语句的目的是兼容AbstractCollection，因为c.contains可能会抛出异常\n        if (r != size) {\n            System.arraycopy(elementData, r,\n                             elementData, w,\n                             size - r);\n            w += size - r;\n        }\n        if (w != size) {\n            for (int i = w; i < size; i++)\n                elementData[i] = null;\n            modCount += size - w;\n            size = w;\n            modified = true;\n        }\n    }\n    return modified;\n}\n```\n\n### 总结\n\n`ArrayList`源码中除了迭代器的部分，已经差不多都分析完了，相比于`HashMap`来说简单了很多，因为其底层的数据结构是数组，没有任何其他东西，所以实现较为简单。那么需要注意的就是什么场景使用`ArrayList`，什么场景使用`LinkedList`.\b`ArrayList`适合按序插入及频繁的通过index的查找的场景，而`LinkedList`适合随机的插入与删除元素的场景。\n\n### 往期回顾\n\n* [Java集合源码系列-HashMap](https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/)\n\n### 欢迎关注我的公众号\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![技术旅途](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","slug":"Java集合源码系列-ArrayList","published":1,"updated":"2019-02-03T07:16:46.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkll4000buetunrb4o7c4","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这是Java集合源码系列的第二篇，\b第一篇分析了HashMap，本来想把TreeMap和HashMap这几个Map实现分析一下，但是一个是红黑树的一个是不常用的类，想想就不浪费这个时间了。后面有时间有能力可以尝试分析下更有意义的<code>ConcurrentHashMap</code>。不过这篇文章将要分析的是经常用到的<code>ArrayList</code>。</p>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p><code>ArrayList</code>是一个列表，底层是一个大小可以改变的数组类型。而数组类型在内存中的地址是连续的，可以通过数组下标直接计算出地址，所以可以以O(1)的时间复杂度进行<strong>get</strong>操作，但是<strong>add</strong>操作，需要对插入下标之后的数据进行向后移动，所以平均时间复杂度将会是O(n)。而列表的另外一种实现<code>LinkedList</code>则是采用双向链表，靠指针将前后数据连接起来，但数据在内存中并不是连续存放的，这种方式对插入和删除的操作友好，但是<strong>get</strong>的性能稍差。</p>\n<p>下面还是按照之前的思路，从使用<code>ArrayList</code>的整个生命周期来作为行文路线，即创建–&gt;添加–&gt;获取–&gt;删除。</p>\n<a id=\"more\"></a>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>使用<code>ArrayList</code>的第一步就是创建一个该类的对象，那么先来看下他的构造函数吧。一共有三个构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无参构造函数是最常用的构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// elementData即为底层存储数据的数组，无参构造函数将一个空数组赋值它，它的大小将在第一个元素被添加时指定，后面会提到</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 指定数组大小的构造函数，这里的EMPTY_ELEMENTDATA与上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA虽然值一样，但是名字不一样，先记住这一点，后面在添加元素的时候会介绍到</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过已经存在的collection创建ArrayList</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>构造函数还是比较简单的，但是也留了一个问题，<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>值明明是一样的，为什么需要两个呢？？将在这里解开谜底。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最常用的是不带index的add方法，将元素追加到末尾,size是实例变量，初始化时为0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size; <span class=\"comment\">// size变量记录元素的数量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 确保容量后，元素添加到size++的位置，即末尾添加</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// add()调用ensureCapacityInternal()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里就解答了上面的提到的问题，如果elementData指向的是ensureExplicitCapacity，即ArrayList是通过无参构造函数生成的，那么在第一次添加元素的时候，数组的默认大小设为10。因为第一次添加元素时minCapacity=size+1=1 &lt; 10.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"><span class=\"comment\">// modCount变量的作用是记录修改的次数，包括添加，删除等操作，修改值不记录，用于使用迭代器时的fail-fast</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 数组容量不够时进行扩容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\"><span class=\"comment\">// 扩容1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 第一次扩容时，elementData.length为0，minCapacity为10，所以数组大小最终会被设置为minCapacity</span></span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// MAX_ARRAY_SIZE需要减8的原因在注释中提到了，有些虚拟机的实现需要将一些头部字段存到数组中，因此留出一些空间，避免出现OutOfMemoryError错误</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果扩容后的数组大小大于MAX_ARRAY_SIZE,进行hugeCapacity调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的那部分是以追加的方式在末尾添加元素，现在看下在指定下标处添加元素的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index); </span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\"><span class=\"comment\">// 调用系统的数组复制方法将原数组中index及之后的所有元素，向后移动一格，所以ArrayList在插入元素时的性能逊于LinkedList</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// add方法首先校验index的合法性，对于不合法的index抛出异常，给出index和size信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// add方法然后调用ensureCapacityInternal进行保证内部容量的合适的验证，该方法前面介绍到，不再次介绍</span></span><br></pre></td></tr></table></figure>\n<p>除了上面介绍的两个add方法，还有两个个addAll方法，其实实现方式是一样的，就简单的贴下代码，大家稍微看下就能明白跟前面的方法几乎是一样的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><p>前面的几个代码片段已经把添加元素都分析完了，还是不难的。现在看一下如何取出刚才添加的元素呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 因为是底层是数组，所以取出元素的代码更加简单，直接通过数组下标获取，然后进行类型转换后返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将元素类型转换后返回</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前面介绍的是根据指定下标找元素，其实还可以通过指定元素找元素对应的下标</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从前向后遍历，找到第一个equal的元素后返回其下标，可以查找null对象，找不到时返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从后向前遍历，逻辑一样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"for-each遍历\"><a href=\"#for-each遍历\" class=\"headerlink\" title=\"for-each遍历\"></a>for-each遍历</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(action);</span><br><span class=\"line\"><span class=\"comment\">// action 为 null时抛出NullPointerException</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\"><span class=\"comment\">// 记录遍历时modCount的值，遍历时不允许对数组进行添加，删除等修改结构的操作</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E[] elementData = (E[]) <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = <span class=\"keyword\">this</span>.size;</span><br><span class=\"line\"><span class=\"comment\">// 遍历数组，对每个元素进行action方法相关的操作，并判断modCount没有修改过</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class=\"line\">        action.accept(elementData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历过程中发现modCount被修改过，抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p>介绍完了获取元素，现在来看下如何删除元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据下标删除元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index); <span class=\"comment\">// 确保index&lt;size</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 进行修改操作时modCount++</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 将index+1到最后一个元素全都向前移动一格</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 根据对象删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 如果找到该元素返回true，反之返回false，删除逻辑都是调用了fastRomeve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// fastRemove的取名还挺形象，跟remove(index)相比，省去了校验index合法性的步骤，直接进行移位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 修改次数+1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 清除所有元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">        elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 把修改值的方法也放入删除的分类里吧，可以看出修改值的操作不会对modCount进行修改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index); <span class=\"comment\">// 验证index合法性</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element; <span class=\"comment\">// 直接替换旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 移除collection c中所有的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">batchRemove</span><span class=\"params\">(Collection&lt;?&gt; c, <span class=\"keyword\">boolean</span> complement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] elementData = <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = <span class=\"number\">0</span>, w = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; r &lt; size; r++)</span><br><span class=\"line\"><span class=\"comment\">// 遍历elementData，如果元素不存在c中，赋值给elementData[w]，w++,这里巧妙的是w&lt;=r，所以不会丢失值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c.contains(elementData[r]) == complement)</span><br><span class=\"line\">                elementData[w++] = elementData[r];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 按理说r是等于size的，源码注释中解释这个finally语句的目的是兼容AbstractCollection，因为c.contains可能会抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != size) &#123;</span><br><span class=\"line\">            System.arraycopy(elementData, r,</span><br><span class=\"line\">                             elementData, w,</span><br><span class=\"line\">                             size - r);</span><br><span class=\"line\">            w += size - r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w != size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = w; i &lt; size; i++)</span><br><span class=\"line\">                elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            modCount += size - w;</span><br><span class=\"line\">            size = w;</span><br><span class=\"line\">            modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>ArrayList</code>源码中除了迭代器的部分，已经差不多都分析完了，相比于<code>HashMap</code>来说简单了很多，因为其底层的数据结构是数组，没有任何其他东西，所以实现较为简单。那么需要注意的就是什么场景使用<code>ArrayList</code>，什么场景使用<code>LinkedList</code>.\b<code>ArrayList</code>适合按序插入及频繁的通过index的查找的场景，而<code>LinkedList</code>适合随机的插入与删除元素的场景。</p>\n<h3 id=\"往期回顾\"><a href=\"#往期回顾\" class=\"headerlink\" title=\"往期回顾\"></a>往期回顾</h3><ul>\n<li><a href=\"https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/\" target=\"_blank\" rel=\"noopener\">Java集合源码系列-HashMap</a></li>\n</ul>\n<h3 id=\"欢迎关注我的公众号\"><a href=\"#欢迎关注我的公众号\" class=\"headerlink\" title=\"欢迎关注我的公众号\"></a>欢迎关注我的公众号</h3><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"技术旅途\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这是Java集合源码系列的第二篇，\b第一篇分析了HashMap，本来想把TreeMap和HashMap这几个Map实现分析一下，但是一个是红黑树的一个是不常用的类，想想就不浪费这个时间了。后面有时间有能力可以尝试分析下更有意义的<code>ConcurrentHashMap</code>。不过这篇文章将要分析的是经常用到的<code>ArrayList</code>。</p>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p><code>ArrayList</code>是一个列表，底层是一个大小可以改变的数组类型。而数组类型在内存中的地址是连续的，可以通过数组下标直接计算出地址，所以可以以O(1)的时间复杂度进行<strong>get</strong>操作，但是<strong>add</strong>操作，需要对插入下标之后的数据进行向后移动，所以平均时间复杂度将会是O(n)。而列表的另外一种实现<code>LinkedList</code>则是采用双向链表，靠指针将前后数据连接起来，但数据在内存中并不是连续存放的，这种方式对插入和删除的操作友好，但是<strong>get</strong>的性能稍差。</p>\n<p>下面还是按照之前的思路，从使用<code>ArrayList</code>的整个生命周期来作为行文路线，即创建–&gt;添加–&gt;获取–&gt;删除。</p>","more":"<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>使用<code>ArrayList</code>的第一步就是创建一个该类的对象，那么先来看下他的构造函数吧。一共有三个构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无参构造函数是最常用的构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// elementData即为底层存储数据的数组，无参构造函数将一个空数组赋值它，它的大小将在第一个元素被添加时指定，后面会提到</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 指定数组大小的构造函数，这里的EMPTY_ELEMENTDATA与上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA虽然值一样，但是名字不一样，先记住这一点，后面在添加元素的时候会介绍到</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过已经存在的collection创建ArrayList</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>构造函数还是比较简单的，但是也留了一个问题，<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>值明明是一样的，为什么需要两个呢？？将在这里解开谜底。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最常用的是不带index的add方法，将元素追加到末尾,size是实例变量，初始化时为0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size; <span class=\"comment\">// size变量记录元素的数量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 确保容量后，元素添加到size++的位置，即末尾添加</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// add()调用ensureCapacityInternal()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里就解答了上面的提到的问题，如果elementData指向的是ensureExplicitCapacity，即ArrayList是通过无参构造函数生成的，那么在第一次添加元素的时候，数组的默认大小设为10。因为第一次添加元素时minCapacity=size+1=1 &lt; 10.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"><span class=\"comment\">// modCount变量的作用是记录修改的次数，包括添加，删除等操作，修改值不记录，用于使用迭代器时的fail-fast</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 数组容量不够时进行扩容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\"><span class=\"comment\">// 扩容1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 第一次扩容时，elementData.length为0，minCapacity为10，所以数组大小最终会被设置为minCapacity</span></span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// MAX_ARRAY_SIZE需要减8的原因在注释中提到了，有些虚拟机的实现需要将一些头部字段存到数组中，因此留出一些空间，避免出现OutOfMemoryError错误</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果扩容后的数组大小大于MAX_ARRAY_SIZE,进行hugeCapacity调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的那部分是以追加的方式在末尾添加元素，现在看下在指定下标处添加元素的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index); </span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\"><span class=\"comment\">// 调用系统的数组复制方法将原数组中index及之后的所有元素，向后移动一格，所以ArrayList在插入元素时的性能逊于LinkedList</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// add方法首先校验index的合法性，对于不合法的index抛出异常，给出index和size信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// add方法然后调用ensureCapacityInternal进行保证内部容量的合适的验证，该方法前面介绍到，不再次介绍</span></span><br></pre></td></tr></table></figure>\n<p>除了上面介绍的两个add方法，还有两个个addAll方法，其实实现方式是一样的，就简单的贴下代码，大家稍微看下就能明白跟前面的方法几乎是一样的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><p>前面的几个代码片段已经把添加元素都分析完了，还是不难的。现在看一下如何取出刚才添加的元素呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 因为是底层是数组，所以取出元素的代码更加简单，直接通过数组下标获取，然后进行类型转换后返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将元素类型转换后返回</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前面介绍的是根据指定下标找元素，其实还可以通过指定元素找元素对应的下标</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从前向后遍历，找到第一个equal的元素后返回其下标，可以查找null对象，找不到时返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从后向前遍历，逻辑一样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"for-each遍历\"><a href=\"#for-each遍历\" class=\"headerlink\" title=\"for-each遍历\"></a>for-each遍历</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(action);</span><br><span class=\"line\"><span class=\"comment\">// action 为 null时抛出NullPointerException</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\"><span class=\"comment\">// 记录遍历时modCount的值，遍历时不允许对数组进行添加，删除等修改结构的操作</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E[] elementData = (E[]) <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = <span class=\"keyword\">this</span>.size;</span><br><span class=\"line\"><span class=\"comment\">// 遍历数组，对每个元素进行action方法相关的操作，并判断modCount没有修改过</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class=\"line\">        action.accept(elementData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历过程中发现modCount被修改过，抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p>介绍完了获取元素，现在来看下如何删除元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据下标删除元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index); <span class=\"comment\">// 确保index&lt;size</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 进行修改操作时modCount++</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 将index+1到最后一个元素全都向前移动一格</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 根据对象删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 如果找到该元素返回true，反之返回false，删除逻辑都是调用了fastRomeve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// fastRemove的取名还挺形象，跟remove(index)相比，省去了校验index合法性的步骤，直接进行移位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 修改次数+1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 清除所有元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">        elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 把修改值的方法也放入删除的分类里吧，可以看出修改值的操作不会对modCount进行修改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index); <span class=\"comment\">// 验证index合法性</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element; <span class=\"comment\">// 直接替换旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 移除collection c中所有的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">batchRemove</span><span class=\"params\">(Collection&lt;?&gt; c, <span class=\"keyword\">boolean</span> complement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] elementData = <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = <span class=\"number\">0</span>, w = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; r &lt; size; r++)</span><br><span class=\"line\"><span class=\"comment\">// 遍历elementData，如果元素不存在c中，赋值给elementData[w]，w++,这里巧妙的是w&lt;=r，所以不会丢失值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c.contains(elementData[r]) == complement)</span><br><span class=\"line\">                elementData[w++] = elementData[r];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 按理说r是等于size的，源码注释中解释这个finally语句的目的是兼容AbstractCollection，因为c.contains可能会抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != size) &#123;</span><br><span class=\"line\">            System.arraycopy(elementData, r,</span><br><span class=\"line\">                             elementData, w,</span><br><span class=\"line\">                             size - r);</span><br><span class=\"line\">            w += size - r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w != size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = w; i &lt; size; i++)</span><br><span class=\"line\">                elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            modCount += size - w;</span><br><span class=\"line\">            size = w;</span><br><span class=\"line\">            modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>ArrayList</code>源码中除了迭代器的部分，已经差不多都分析完了，相比于<code>HashMap</code>来说简单了很多，因为其底层的数据结构是数组，没有任何其他东西，所以实现较为简单。那么需要注意的就是什么场景使用<code>ArrayList</code>，什么场景使用<code>LinkedList</code>.\b<code>ArrayList</code>适合按序插入及频繁的通过index的查找的场景，而<code>LinkedList</code>适合随机的插入与删除元素的场景。</p>\n<h3 id=\"往期回顾\"><a href=\"#往期回顾\" class=\"headerlink\" title=\"往期回顾\"></a>往期回顾</h3><ul>\n<li><a href=\"https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/\" target=\"_blank\" rel=\"noopener\">Java集合源码系列-HashMap</a></li>\n</ul>\n<h3 id=\"欢迎关注我的公众号\"><a href=\"#欢迎关注我的公众号\" class=\"headerlink\" title=\"欢迎关注我的公众号\"></a>欢迎关注我的公众号</h3><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"技术旅途\"></p>"},{"title":"Java集合源码系列-LinkedList","date":"2019-02-03T07:22:04.000Z","_content":"\n### 前言\n\n这是Java集合源码系列的第三篇了，准备来介绍一下`LinkedList`这个类,`LinkedList`常与`ArrayList`放在一起比较，都是`List`接口的实现类，但是底层的数据结构不同，导致它们在一些操作上各有优缺点，需要根据应用场景灵活选用`List`。`ArrayList`的细节上篇文章已经介绍过了，不了解的可以回过去看一下。`LinkedList`的底层实现是一个双向链表，同时也实现了`Deque`接口，因此也可以作为双向队列的一个实现，这是`LinkedList`相比`ArrayList`的另外一个重大特性。话不多说，直接进入源码分析阶段吧,按照惯例，依然是从使用集合的整个生命周期来作为行文路线，即创建-->插入-->获取-->删除。\n\n\n### 创建\n\n#### 继承关系\n\n![LinkedList](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/2019/LinkedList.png)\n\n#### 底层数据结构--双向链表\n\n前面介绍到`LinkedList`的底层数据结构是双向链表，那么先来看一下其实现。\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n非常的简单，与普通的双向链表完全一致，一个存储数据的**item**,以及两个分别指向前一个节点和后一个节点的指针。\n\n#### 构造函数\n```java\ntransient int size = 0;　// number of elements in list\n// 类中有两个指针变量，一个指向双向链表的头，一个指向尾\ntransient Node<E> first;\ntransient Node<E> last;\n// 创建一个空的list\npublic LinkedList() {\n}\n// 从一个已有集合创建\npublic LinkedList(Collection<? extends E> c) {\n    this();\n// addAll就是将collection中所有元素添加到list中，具体在添加元素部分介绍\n    addAll(c);\n}\n```\n\n`LinkedList`的构造函数非常简单，而且成员变量的数目最少，只有3个，那么现在来看下如何添加元素吧。\n\n### 添加元素\n\n首先介绍下上面构造函数中提到的的**addAll**方法\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n    return addAll(size, c); //　size初始值为0\n}\n//　从指定Index处插入给定集合中的所有元素\npublic boolean addAll(int index, Collection<? extends E> c) {\n//　check index>=0 && index <= size\n    checkPositionIndex(index);\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n    Node<E> pred, succ;\n    if (index == size) {\n    //　index为最后一个元素的后面一个时\n        succ = null;\n        pred = last;//pred指向List中最后一个节点\n    } else {\n    //　index是中间元素时\n    //　node方法返回下标为index的节点,将在获取元素部分详细介绍\n        succ = node(index);\n    // pred指向succ的前一个节点\n        pred = succ.prev;\n    }\n    // 新插入的元素在pred指针之后\n    // 遍历数组a，将元素逐个插入，并指定新的first和last指针\n    for (Object o : a) {\n        E e = (E) o;\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n    if (succ == null) {\n        last = pred;\n    } else {\n        pred.next = succ;\n        succ.prev = pred;\n    }\n    //　修改size的数值\n　  size += numNew;\n　　//　对于add, delete这样结构性的修改方式，modCount记录修改次数，用于迭代时检测list是否被修改，被修改则抛出异常，但是不保证一定抛出异常。需要用其他方式检测并发操作的正确性\n    modCount++;\n    return true;\n}\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n//　生成错误信息\nprivate String outOfBoundsMsg(int index) {\n    return \"Index: \"+index+\", Size: \"+size;\n}\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\n```\n\n上面的是addAll方法，应该是不常用的(我猜的)。那么现在来看下`LinkedList`作为**list**实现的常用添加方法**add**\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n//　在双向链表末尾插入新元素\nvoid linkLast(E e) {\n// last指针指向双向链表最后一个元素，l指向last\n    final Node<E> l = last;\n// 新创建一个节点，其prev指针指向链表末尾\n    final Node<E> newNode = new Node<>(l, e, null);\n// 更新last指针\n    last = newNode;\n    if (l == null)\n//　如果当前没有元素，插入的元素即为第一个元素，将first指针指向该node\n        first = newNode;\n    else\n// 如果双向链表已经存在，将添加之前的链表的最后一个几点的next指针更新\n        l.next = newNode;\n// 修改size和modCount\n    size++;\n    modCount++;\n}\n// *******************************************************\n//　指定下标处插入元素的add方法\npublic void add(int index, E element) {\n// check index>=0 && index<=size\n    checkPositionIndex(index);\n    if (index == size)\n// 等价于末尾插入\n        linkLast(element);\n    else\n// 在链表前端节点插入，node方法返回index处的节点，后面详细介绍\n        linkBefore(element, node(index));\n}\nvoid linkBefore(E e, Node<E> succ) {\n//　succ为index所在位置的节点，原链表A->succ->B\n// 插入后链表A->newNode->succ->B\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n//　因为是双向链表，succ.prev指针也需要更新\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n// *******************************************************\n// 接下来看看LinkedList作为deque的一些方法\npublic void addLast(E e) {\n    linkLast(e);\n}\n// 入栈操作\npublic void push(E e) {\n    addFirst(e);\n}\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n//　将元素添加到链表的第一个节点\nprivate void linkFirst(E e) {\n    final Node<E> f = first;\n    final Node<E> newNode = new Node<>(null, e, f);\n    first = newNode;\n    if (f == null)\n        last = newNode;\n    else\n        f.prev = newNode;\n    size++;\n    modCount++;\n}\n```\n\n插入操作总的来说是先找到插入的位置，生成一个新的双向链表的Node节点，修改前后节点相应的指针。时间开销只需要一个遍历的开销，相比于`ArrayList`,`ArrayList`需要将index之后的元素进行位移，花费的开销更大。\n\n### 获取元素\n\n```java\n//　先介绍下前面出现过几次的node()方法\n// node方法返回指定Index处的节点，根据index与first及last的距离，选择较近的一端进行遍历，总的复杂度为O(n),而ArrayList根据index获取元素的时间复杂度为O(1)\nNode<E> node(int index) {\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n//根据指定下标获取元素\npublic E get(int index) {\n//check index>=0 && index<size\n    checkElementIndex(index);\n    return node(index).item;\n}\nprivate void checkElementIndex(int index) {\n    if (!isElementIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\nprivate boolean isElementIndex(int index) {\n    return index >= 0 && index < size;\n}\n//　作为队列，有getFirst和getLasr两个方法，直接返回内部成员变量first和last指针的值，非空才返回，为空抛异常\npublic E getFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return f.item;\n}\npublic E getLast() {\n    final Node<E> l = last;\n    if (l == null)\n        throw new NoSuchElementException();\n    return l.item;\n}\n//　判断是否包含某个元素\npublic boolean contains(Object o) {\n    return indexOf(o) != -1;\n}\n//　返回第一个相等对象的index\npublic int indexOf(Object o) {\n    int index = 0;\n//　从first节点开始遍历，检验是否存在对象o\n    if (o == null) {\n//　支持查找null对象\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null)\n                return index;\n            index++;\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item))\n                return index;\n            index++;\n        }\n    }\n// 查找不到return -1\n    return -1;\n}\n//还有一个lastIndexOf,从后向前查找，实现原理相同\n```\n\n### 删除元素\n\n```java\n//删除指定下标处的元素\npublic E remove(int index) {\n//check index>=0 && index<size\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n//删除指定对象，与indexOf的实现雷同\npublic boolean remove(Object o) {\n// 从first向后遍历，支持null对象，找到该对象后调用unlink方法删除，删除成功返回true，否则false\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nE unlink(Node<E> x) {\n    final E element = x.item;\n// 获取即将删除节点的前一个节点和后一个节点\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    if (prev == null) {\n// 被删除节点为first指向的节点，更新first指针为next\n        first = next;\n    } else {\n// 被删除节点不是first指向的节点，将前一个节点的next指针更新，并把被删除节点的prev节点置空\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {\n// 被删除节点为last指向的节点，更新last指针为prev\n        last = prev;\n    } else {\n// 被删除的节点不是last指向的节点，更新被删除节点的后一个节点的prev指针\n        next.prev = prev;\n        x.next = null;\n    }\n//　将x的各个成员变量置为null，方便GC,同时对size和modCount进行修改后返回被删除元素的值\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n//修改指定下标处的值\npublic E set(int index, E element) {\n// check index>=0 && index<size\n    checkElementIndex(index);\n//通过node方法获取index下标对应的节点，将其item变量更新\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n//删除所有元素\npublic void clear() {\n//从first向后遍历，将当前节点的成员变量都置空\n    for (Node<E> x = first; x != null; ) {\n        Node<E> next = x.next;\n        x.item = null;\n        x.next = null;\n        x.prev = null;\n        x = next;\n    }\n//将first,last,size恢复为空值\n    first = last = null;\n    size = 0;\n    modCount++;\n}\n// *****************************************************\n// 作为deque的一些删除方法\npublic E removeFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return unlinkFirst(f);\n}\nprivate E unlinkFirst(Node<E> f) {\n    final E element = f.item;\n    final Node<E> next = f.next;\n    f.item = null;\n    f.next = null; // help GC\n//更新first指针，并判断是否还存在元素\n    first = next;\n    if (next == null)\n        last = null;\n    else\n        next.prev = null;\n    size--;\n    modCount++;\n    return element;\n}\n//removeLast与removeFirst实现相似，不再重复\npublic E removeLast() {\n    final Node<E> l = last;\n    if (l == null)\n        throw new NoSuchElementException();\n    return unlinkLast(l);\n}\nprivate E unlinkLast(Node<E> l) {\n    final E element = l.item;\n    final Node<E> prev = l.prev;\n    l.item = null;\n    l.prev = null; // help GC\n    last = prev;\n    if (prev == null)\n        first = null;\n    else\n        prev.next = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n### deque方法介绍\n\n上面的分析差不多已经介绍完大部分代码了，其实可以发现，有很多代码的逻辑都是相似的。`LinkedList`作为队列的实现类，还有很多针对队列的实现方法，但其实只是原有代码的再封装，我把之前没提到的一些方法放在这一部分一起介绍了。\n\n```java\n//返回队列第一个元素的值\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n//返回队列第一个元素的值，与peek的区别在于，element方法在第一个元素不存在时会抛出异常\npublic E element() {\n    return getFirst();\n}\n//返回队列第一个元素，并删除\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n//返回队列第一个元素，并删除，为空抛异常\npublic E remove() {\n    return removeFirst();\n}\n//末尾添加\npublic boolean offer(E e) {\n    return add(e);\n}\n//头节点添加\npublic boolean offerFirst(E e) {\n    addFirst(e);\n    return true;\n}\n//末尾添加\npublic boolean offerLast(E e) {\n    addLast(e);\n    return true;\n}\n//弹出list的第一个元素\npublic E pop() {\n    return removeFirst();\n}\n```\n\n### 总结\n\n`LinkedList`的大部分代码都介绍完了，可以看出来比较简单。`LinkedList`底层实现为双向链表，除了可以作为**List**外，还可以作为队列和栈的实现类。因为是双向链表，所以对频繁的插入和删除操作较为友好，但是对频繁的根据下标获取的场景不够友好，需要权衡一下。才疏学浅，如有错误，欢迎指出\n\n### 往期回顾\n\n* [Java集合源码系列-HashMap](https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/)\n\n* [Java集合源码系列-ArrayList](https://cfk1996.github.io/2019/01/22/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/)\n\n### 欢迎关注我的公众号\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![技术旅途](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","source":"_posts/Java集合源码系列-LinkedList.md","raw":"---\ntitle: Java集合源码系列-LinkedList\ndate: 2019-02-03 15:22:04\ntags:\n    - Java\n    - Java源码\n---\n\n### 前言\n\n这是Java集合源码系列的第三篇了，准备来介绍一下`LinkedList`这个类,`LinkedList`常与`ArrayList`放在一起比较，都是`List`接口的实现类，但是底层的数据结构不同，导致它们在一些操作上各有优缺点，需要根据应用场景灵活选用`List`。`ArrayList`的细节上篇文章已经介绍过了，不了解的可以回过去看一下。`LinkedList`的底层实现是一个双向链表，同时也实现了`Deque`接口，因此也可以作为双向队列的一个实现，这是`LinkedList`相比`ArrayList`的另外一个重大特性。话不多说，直接进入源码分析阶段吧,按照惯例，依然是从使用集合的整个生命周期来作为行文路线，即创建-->插入-->获取-->删除。\n\n\n### 创建\n\n#### 继承关系\n\n![LinkedList](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/2019/LinkedList.png)\n\n#### 底层数据结构--双向链表\n\n前面介绍到`LinkedList`的底层数据结构是双向链表，那么先来看一下其实现。\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n非常的简单，与普通的双向链表完全一致，一个存储数据的**item**,以及两个分别指向前一个节点和后一个节点的指针。\n\n#### 构造函数\n```java\ntransient int size = 0;　// number of elements in list\n// 类中有两个指针变量，一个指向双向链表的头，一个指向尾\ntransient Node<E> first;\ntransient Node<E> last;\n// 创建一个空的list\npublic LinkedList() {\n}\n// 从一个已有集合创建\npublic LinkedList(Collection<? extends E> c) {\n    this();\n// addAll就是将collection中所有元素添加到list中，具体在添加元素部分介绍\n    addAll(c);\n}\n```\n\n`LinkedList`的构造函数非常简单，而且成员变量的数目最少，只有3个，那么现在来看下如何添加元素吧。\n\n### 添加元素\n\n首先介绍下上面构造函数中提到的的**addAll**方法\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n    return addAll(size, c); //　size初始值为0\n}\n//　从指定Index处插入给定集合中的所有元素\npublic boolean addAll(int index, Collection<? extends E> c) {\n//　check index>=0 && index <= size\n    checkPositionIndex(index);\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n    Node<E> pred, succ;\n    if (index == size) {\n    //　index为最后一个元素的后面一个时\n        succ = null;\n        pred = last;//pred指向List中最后一个节点\n    } else {\n    //　index是中间元素时\n    //　node方法返回下标为index的节点,将在获取元素部分详细介绍\n        succ = node(index);\n    // pred指向succ的前一个节点\n        pred = succ.prev;\n    }\n    // 新插入的元素在pred指针之后\n    // 遍历数组a，将元素逐个插入，并指定新的first和last指针\n    for (Object o : a) {\n        E e = (E) o;\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n    if (succ == null) {\n        last = pred;\n    } else {\n        pred.next = succ;\n        succ.prev = pred;\n    }\n    //　修改size的数值\n　  size += numNew;\n　　//　对于add, delete这样结构性的修改方式，modCount记录修改次数，用于迭代时检测list是否被修改，被修改则抛出异常，但是不保证一定抛出异常。需要用其他方式检测并发操作的正确性\n    modCount++;\n    return true;\n}\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n//　生成错误信息\nprivate String outOfBoundsMsg(int index) {\n    return \"Index: \"+index+\", Size: \"+size;\n}\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\n```\n\n上面的是addAll方法，应该是不常用的(我猜的)。那么现在来看下`LinkedList`作为**list**实现的常用添加方法**add**\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n//　在双向链表末尾插入新元素\nvoid linkLast(E e) {\n// last指针指向双向链表最后一个元素，l指向last\n    final Node<E> l = last;\n// 新创建一个节点，其prev指针指向链表末尾\n    final Node<E> newNode = new Node<>(l, e, null);\n// 更新last指针\n    last = newNode;\n    if (l == null)\n//　如果当前没有元素，插入的元素即为第一个元素，将first指针指向该node\n        first = newNode;\n    else\n// 如果双向链表已经存在，将添加之前的链表的最后一个几点的next指针更新\n        l.next = newNode;\n// 修改size和modCount\n    size++;\n    modCount++;\n}\n// *******************************************************\n//　指定下标处插入元素的add方法\npublic void add(int index, E element) {\n// check index>=0 && index<=size\n    checkPositionIndex(index);\n    if (index == size)\n// 等价于末尾插入\n        linkLast(element);\n    else\n// 在链表前端节点插入，node方法返回index处的节点，后面详细介绍\n        linkBefore(element, node(index));\n}\nvoid linkBefore(E e, Node<E> succ) {\n//　succ为index所在位置的节点，原链表A->succ->B\n// 插入后链表A->newNode->succ->B\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n//　因为是双向链表，succ.prev指针也需要更新\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n// *******************************************************\n// 接下来看看LinkedList作为deque的一些方法\npublic void addLast(E e) {\n    linkLast(e);\n}\n// 入栈操作\npublic void push(E e) {\n    addFirst(e);\n}\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n//　将元素添加到链表的第一个节点\nprivate void linkFirst(E e) {\n    final Node<E> f = first;\n    final Node<E> newNode = new Node<>(null, e, f);\n    first = newNode;\n    if (f == null)\n        last = newNode;\n    else\n        f.prev = newNode;\n    size++;\n    modCount++;\n}\n```\n\n插入操作总的来说是先找到插入的位置，生成一个新的双向链表的Node节点，修改前后节点相应的指针。时间开销只需要一个遍历的开销，相比于`ArrayList`,`ArrayList`需要将index之后的元素进行位移，花费的开销更大。\n\n### 获取元素\n\n```java\n//　先介绍下前面出现过几次的node()方法\n// node方法返回指定Index处的节点，根据index与first及last的距离，选择较近的一端进行遍历，总的复杂度为O(n),而ArrayList根据index获取元素的时间复杂度为O(1)\nNode<E> node(int index) {\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n//根据指定下标获取元素\npublic E get(int index) {\n//check index>=0 && index<size\n    checkElementIndex(index);\n    return node(index).item;\n}\nprivate void checkElementIndex(int index) {\n    if (!isElementIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\nprivate boolean isElementIndex(int index) {\n    return index >= 0 && index < size;\n}\n//　作为队列，有getFirst和getLasr两个方法，直接返回内部成员变量first和last指针的值，非空才返回，为空抛异常\npublic E getFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return f.item;\n}\npublic E getLast() {\n    final Node<E> l = last;\n    if (l == null)\n        throw new NoSuchElementException();\n    return l.item;\n}\n//　判断是否包含某个元素\npublic boolean contains(Object o) {\n    return indexOf(o) != -1;\n}\n//　返回第一个相等对象的index\npublic int indexOf(Object o) {\n    int index = 0;\n//　从first节点开始遍历，检验是否存在对象o\n    if (o == null) {\n//　支持查找null对象\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null)\n                return index;\n            index++;\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item))\n                return index;\n            index++;\n        }\n    }\n// 查找不到return -1\n    return -1;\n}\n//还有一个lastIndexOf,从后向前查找，实现原理相同\n```\n\n### 删除元素\n\n```java\n//删除指定下标处的元素\npublic E remove(int index) {\n//check index>=0 && index<size\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n//删除指定对象，与indexOf的实现雷同\npublic boolean remove(Object o) {\n// 从first向后遍历，支持null对象，找到该对象后调用unlink方法删除，删除成功返回true，否则false\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nE unlink(Node<E> x) {\n    final E element = x.item;\n// 获取即将删除节点的前一个节点和后一个节点\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    if (prev == null) {\n// 被删除节点为first指向的节点，更新first指针为next\n        first = next;\n    } else {\n// 被删除节点不是first指向的节点，将前一个节点的next指针更新，并把被删除节点的prev节点置空\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {\n// 被删除节点为last指向的节点，更新last指针为prev\n        last = prev;\n    } else {\n// 被删除的节点不是last指向的节点，更新被删除节点的后一个节点的prev指针\n        next.prev = prev;\n        x.next = null;\n    }\n//　将x的各个成员变量置为null，方便GC,同时对size和modCount进行修改后返回被删除元素的值\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n//修改指定下标处的值\npublic E set(int index, E element) {\n// check index>=0 && index<size\n    checkElementIndex(index);\n//通过node方法获取index下标对应的节点，将其item变量更新\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n//删除所有元素\npublic void clear() {\n//从first向后遍历，将当前节点的成员变量都置空\n    for (Node<E> x = first; x != null; ) {\n        Node<E> next = x.next;\n        x.item = null;\n        x.next = null;\n        x.prev = null;\n        x = next;\n    }\n//将first,last,size恢复为空值\n    first = last = null;\n    size = 0;\n    modCount++;\n}\n// *****************************************************\n// 作为deque的一些删除方法\npublic E removeFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return unlinkFirst(f);\n}\nprivate E unlinkFirst(Node<E> f) {\n    final E element = f.item;\n    final Node<E> next = f.next;\n    f.item = null;\n    f.next = null; // help GC\n//更新first指针，并判断是否还存在元素\n    first = next;\n    if (next == null)\n        last = null;\n    else\n        next.prev = null;\n    size--;\n    modCount++;\n    return element;\n}\n//removeLast与removeFirst实现相似，不再重复\npublic E removeLast() {\n    final Node<E> l = last;\n    if (l == null)\n        throw new NoSuchElementException();\n    return unlinkLast(l);\n}\nprivate E unlinkLast(Node<E> l) {\n    final E element = l.item;\n    final Node<E> prev = l.prev;\n    l.item = null;\n    l.prev = null; // help GC\n    last = prev;\n    if (prev == null)\n        first = null;\n    else\n        prev.next = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n### deque方法介绍\n\n上面的分析差不多已经介绍完大部分代码了，其实可以发现，有很多代码的逻辑都是相似的。`LinkedList`作为队列的实现类，还有很多针对队列的实现方法，但其实只是原有代码的再封装，我把之前没提到的一些方法放在这一部分一起介绍了。\n\n```java\n//返回队列第一个元素的值\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n//返回队列第一个元素的值，与peek的区别在于，element方法在第一个元素不存在时会抛出异常\npublic E element() {\n    return getFirst();\n}\n//返回队列第一个元素，并删除\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n//返回队列第一个元素，并删除，为空抛异常\npublic E remove() {\n    return removeFirst();\n}\n//末尾添加\npublic boolean offer(E e) {\n    return add(e);\n}\n//头节点添加\npublic boolean offerFirst(E e) {\n    addFirst(e);\n    return true;\n}\n//末尾添加\npublic boolean offerLast(E e) {\n    addLast(e);\n    return true;\n}\n//弹出list的第一个元素\npublic E pop() {\n    return removeFirst();\n}\n```\n\n### 总结\n\n`LinkedList`的大部分代码都介绍完了，可以看出来比较简单。`LinkedList`底层实现为双向链表，除了可以作为**List**外，还可以作为队列和栈的实现类。因为是双向链表，所以对频繁的插入和删除操作较为友好，但是对频繁的根据下标获取的场景不够友好，需要权衡一下。才疏学浅，如有错误，欢迎指出\n\n### 往期回顾\n\n* [Java集合源码系列-HashMap](https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/)\n\n* [Java集合源码系列-ArrayList](https://cfk1996.github.io/2019/01/22/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/)\n\n### 欢迎关注我的公众号\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![技术旅途](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","slug":"Java集合源码系列-LinkedList","published":1,"updated":"2019-02-03T13:53:33.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkll5000cuetuo1cmtrub","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这是Java集合源码系列的第三篇了，准备来介绍一下<code>LinkedList</code>这个类,<code>LinkedList</code>常与<code>ArrayList</code>放在一起比较，都是<code>List</code>接口的实现类，但是底层的数据结构不同，导致它们在一些操作上各有优缺点，需要根据应用场景灵活选用<code>List</code>。<code>ArrayList</code>的细节上篇文章已经介绍过了，不了解的可以回过去看一下。<code>LinkedList</code>的底层实现是一个双向链表，同时也实现了<code>Deque</code>接口，因此也可以作为双向队列的一个实现，这是<code>LinkedList</code>相比<code>ArrayList</code>的另外一个重大特性。话不多说，直接进入源码分析阶段吧,按照惯例，依然是从使用集合的整个生命周期来作为行文路线，即创建–&gt;插入–&gt;获取–&gt;删除。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><h4 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h4><p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/2019/LinkedList.png\" alt=\"LinkedList\"></p>\n<h4 id=\"底层数据结构–双向链表\"><a href=\"#底层数据结构–双向链表\" class=\"headerlink\" title=\"底层数据结构–双向链表\"></a>底层数据结构–双向链表</h4><p>前面介绍到<code>LinkedList</code>的底层数据结构是双向链表，那么先来看一下其实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常的简单，与普通的双向链表完全一致，一个存储数据的<strong>item</strong>,以及两个分别指向前一个节点和后一个节点的指针。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;　<span class=\"comment\">// number of elements in list</span></span><br><span class=\"line\"><span class=\"comment\">// 类中有两个指针变量，一个指向双向链表的头，一个指向尾</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个空的list</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从一个已有集合创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\"><span class=\"comment\">// addAll就是将collection中所有元素添加到list中，具体在添加元素部分介绍</span></span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>LinkedList</code>的构造函数非常简单，而且成员变量的数目最少，只有3个，那么现在来看下如何添加元素吧。</p>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>首先介绍下上面构造函数中提到的的<strong>addAll</strong>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addAll(size, c); <span class=\"comment\">//　size初始值为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　从指定Index处插入给定集合中的所有元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//　check index&gt;=0 &amp;&amp; index &lt;= size</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//　index为最后一个元素的后面一个时</span></span><br><span class=\"line\">        succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        pred = last;<span class=\"comment\">//pred指向List中最后一个节点</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//　index是中间元素时</span></span><br><span class=\"line\">    <span class=\"comment\">//　node方法返回下标为index的节点,将在获取元素部分详细介绍</span></span><br><span class=\"line\">        succ = node(index);</span><br><span class=\"line\">    <span class=\"comment\">// pred指向succ的前一个节点</span></span><br><span class=\"line\">        pred = succ.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新插入的元素在pred指针之后</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历数组a，将元素逐个插入，并指定新的first和last指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">        E e = (E) o;</span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        pred = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        last = pred;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pred.next = succ;</span><br><span class=\"line\">        succ.prev = pred;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//　修改size的数值</span></span><br><span class=\"line\">　  size += numNew;</span><br><span class=\"line\">　　<span class=\"comment\">//　对于add, delete这样结构性的修改方式，modCount记录修改次数，用于迭代时检测list是否被修改，被修改则抛出异常，但是不保证一定抛出异常。需要用其他方式检测并发操作的正确性</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkPositionIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPositionIndex(index))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　生成错误信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPositionIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的是addAll方法，应该是不常用的(我猜的)。那么现在来看下<code>LinkedList</code>作为<strong>list</strong>实现的常用添加方法<strong>add</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　在双向链表末尾插入新元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// last指针指向双向链表最后一个元素，l指向last</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\"><span class=\"comment\">// 新创建一个节点，其prev指针指向链表末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更新last指针</span></span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\"><span class=\"comment\">//　如果当前没有元素，插入的元素即为第一个元素，将first指针指向该node</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"comment\">// 如果双向链表已经存在，将添加之前的链表的最后一个几点的next指针更新</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\"><span class=\"comment\">// 修改size和modCount</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// *******************************************************</span></span><br><span class=\"line\"><span class=\"comment\">//　指定下标处插入元素的add方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// check index&gt;=0 &amp;&amp; index&lt;=size</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\"><span class=\"comment\">// 等价于末尾插入</span></span><br><span class=\"line\">        linkLast(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"comment\">// 在链表前端节点插入，node方法返回index处的节点，后面详细介绍</span></span><br><span class=\"line\">        linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//　succ为index所在位置的节点，原链表A-&gt;succ-&gt;B</span></span><br><span class=\"line\"><span class=\"comment\">// 插入后链表A-&gt;newNode-&gt;succ-&gt;B</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\"><span class=\"comment\">//　因为是双向链表，succ.prev指针也需要更新</span></span><br><span class=\"line\">    succ.prev = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pred.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// *******************************************************</span></span><br><span class=\"line\"><span class=\"comment\">// 接下来看看LinkedList作为deque的一些方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 入栈操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    addFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　将元素添加到链表的第一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        f.prev = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入操作总的来说是先找到插入的位置，生成一个新的双向链表的Node节点，修改前后节点相应的指针。时间开销只需要一个遍历的开销，相比于<code>ArrayList</code>,<code>ArrayList</code>需要将index之后的元素进行位移，花费的开销更大。</p>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　先介绍下前面出现过几次的node()方法</span></span><br><span class=\"line\"><span class=\"comment\">// node方法返回指定Index处的节点，根据index与first及last的距离，选择较近的一端进行遍历，总的复杂度为O(n),而ArrayList根据index获取元素的时间复杂度为O(1)</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//根据指定下标获取元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//check index&gt;=0 &amp;&amp; index&lt;size</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkElementIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isElementIndex(index))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isElementIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　作为队列，有getFirst和getLasr两个方法，直接返回内部成员变量first和last指针的值，非空才返回，为空抛异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　判断是否包含某个元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(o) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　返回第一个相等对象的index</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//　从first节点开始遍历，检验是否存在对象o</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//　支持查找null对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 查找不到return -1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//还有一个lastIndexOf,从后向前查找，实现原理相同</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除指定下标处的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//check index&gt;=0 &amp;&amp; index&lt;size</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除指定对象，与indexOf的实现雷同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 从first向后遍历，支持null对象，找到该对象后调用unlink方法删除，删除成功返回true，否则false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                unlink(x);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                unlink(x);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\"><span class=\"comment\">// 获取即将删除节点的前一个节点和后一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除节点为first指向的节点，更新first指针为next</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除节点不是first指向的节点，将前一个节点的next指针更新，并把被删除节点的prev节点置空</span></span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除节点为last指向的节点，更新last指针为prev</span></span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除的节点不是last指向的节点，更新被删除节点的后一个节点的prev指针</span></span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//　将x的各个成员变量置为null，方便GC,同时对size和modCount进行修改后返回被删除元素的值</span></span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//修改指定下标处的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// check index&gt;=0 &amp;&amp; index&lt;size</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\"><span class=\"comment\">//通过node方法获取index下标对应的节点，将其item变量更新</span></span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    x.item = element;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除所有元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//从first向后遍历，将当前节点的成员变量都置空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; ) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">        x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        x = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//将first,last,size恢复为空值</span></span><br><span class=\"line\">    first = last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// *****************************************************</span></span><br><span class=\"line\"><span class=\"comment\">// 作为deque的一些删除方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkFirst</span><span class=\"params\">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = f.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = f.next;</span><br><span class=\"line\">    f.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    f.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\"><span class=\"comment\">//更新first指针，并判断是否还存在元素</span></span><br><span class=\"line\">    first = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        next.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//removeLast与removeFirst实现相似，不再重复</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkLast</span><span class=\"params\">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = l.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class=\"line\">    l.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    l.prev = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">    last = prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        prev.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"deque方法介绍\"><a href=\"#deque方法介绍\" class=\"headerlink\" title=\"deque方法介绍\"></a>deque方法介绍</h3><p>上面的分析差不多已经介绍完大部分代码了，其实可以发现，有很多代码的逻辑都是相似的。<code>LinkedList</code>作为队列的实现类，还有很多针对队列的实现方法，但其实只是原有代码的再封装，我把之前没提到的一些方法放在这一部分一起介绍了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回队列第一个元素的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回队列第一个元素的值，与peek的区别在于，element方法在第一个元素不存在时会抛出异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">element</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getFirst();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回队列第一个元素，并删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回队列第一个元素，并删除，为空抛异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeFirst();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//末尾添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//头节点添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offerFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    addFirst(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//末尾添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offerLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    addLast(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//弹出list的第一个元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeFirst();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>LinkedList</code>的大部分代码都介绍完了，可以看出来比较简单。<code>LinkedList</code>底层实现为双向链表，除了可以作为<strong>List</strong>外，还可以作为队列和栈的实现类。因为是双向链表，所以对频繁的插入和删除操作较为友好，但是对频繁的根据下标获取的场景不够友好，需要权衡一下。才疏学浅，如有错误，欢迎指出</p>\n<h3 id=\"往期回顾\"><a href=\"#往期回顾\" class=\"headerlink\" title=\"往期回顾\"></a>往期回顾</h3><ul>\n<li><p><a href=\"https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/\" target=\"_blank\" rel=\"noopener\">Java集合源码系列-HashMap</a></p>\n</li>\n<li><p><a href=\"https://cfk1996.github.io/2019/01/22/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/\" target=\"_blank\" rel=\"noopener\">Java集合源码系列-ArrayList</a></p>\n</li>\n</ul>\n<h3 id=\"欢迎关注我的公众号\"><a href=\"#欢迎关注我的公众号\" class=\"headerlink\" title=\"欢迎关注我的公众号\"></a>欢迎关注我的公众号</h3><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"技术旅途\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这是Java集合源码系列的第三篇了，准备来介绍一下<code>LinkedList</code>这个类,<code>LinkedList</code>常与<code>ArrayList</code>放在一起比较，都是<code>List</code>接口的实现类，但是底层的数据结构不同，导致它们在一些操作上各有优缺点，需要根据应用场景灵活选用<code>List</code>。<code>ArrayList</code>的细节上篇文章已经介绍过了，不了解的可以回过去看一下。<code>LinkedList</code>的底层实现是一个双向链表，同时也实现了<code>Deque</code>接口，因此也可以作为双向队列的一个实现，这是<code>LinkedList</code>相比<code>ArrayList</code>的另外一个重大特性。话不多说，直接进入源码分析阶段吧,按照惯例，依然是从使用集合的整个生命周期来作为行文路线，即创建–&gt;插入–&gt;获取–&gt;删除。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><h4 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h4><p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/2019/LinkedList.png\" alt=\"LinkedList\"></p>\n<h4 id=\"底层数据结构–双向链表\"><a href=\"#底层数据结构–双向链表\" class=\"headerlink\" title=\"底层数据结构–双向链表\"></a>底层数据结构–双向链表</h4><p>前面介绍到<code>LinkedList</code>的底层数据结构是双向链表，那么先来看一下其实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常的简单，与普通的双向链表完全一致，一个存储数据的<strong>item</strong>,以及两个分别指向前一个节点和后一个节点的指针。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;　<span class=\"comment\">// number of elements in list</span></span><br><span class=\"line\"><span class=\"comment\">// 类中有两个指针变量，一个指向双向链表的头，一个指向尾</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个空的list</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从一个已有集合创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\"><span class=\"comment\">// addAll就是将collection中所有元素添加到list中，具体在添加元素部分介绍</span></span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>LinkedList</code>的构造函数非常简单，而且成员变量的数目最少，只有3个，那么现在来看下如何添加元素吧。</p>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>首先介绍下上面构造函数中提到的的<strong>addAll</strong>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addAll(size, c); <span class=\"comment\">//　size初始值为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　从指定Index处插入给定集合中的所有元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//　check index&gt;=0 &amp;&amp; index &lt;= size</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//　index为最后一个元素的后面一个时</span></span><br><span class=\"line\">        succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        pred = last;<span class=\"comment\">//pred指向List中最后一个节点</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//　index是中间元素时</span></span><br><span class=\"line\">    <span class=\"comment\">//　node方法返回下标为index的节点,将在获取元素部分详细介绍</span></span><br><span class=\"line\">        succ = node(index);</span><br><span class=\"line\">    <span class=\"comment\">// pred指向succ的前一个节点</span></span><br><span class=\"line\">        pred = succ.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新插入的元素在pred指针之后</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历数组a，将元素逐个插入，并指定新的first和last指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">        E e = (E) o;</span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        pred = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        last = pred;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pred.next = succ;</span><br><span class=\"line\">        succ.prev = pred;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//　修改size的数值</span></span><br><span class=\"line\">　  size += numNew;</span><br><span class=\"line\">　　<span class=\"comment\">//　对于add, delete这样结构性的修改方式，modCount记录修改次数，用于迭代时检测list是否被修改，被修改则抛出异常，但是不保证一定抛出异常。需要用其他方式检测并发操作的正确性</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkPositionIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPositionIndex(index))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　生成错误信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPositionIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的是addAll方法，应该是不常用的(我猜的)。那么现在来看下<code>LinkedList</code>作为<strong>list</strong>实现的常用添加方法<strong>add</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　在双向链表末尾插入新元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// last指针指向双向链表最后一个元素，l指向last</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\"><span class=\"comment\">// 新创建一个节点，其prev指针指向链表末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更新last指针</span></span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\"><span class=\"comment\">//　如果当前没有元素，插入的元素即为第一个元素，将first指针指向该node</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"comment\">// 如果双向链表已经存在，将添加之前的链表的最后一个几点的next指针更新</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\"><span class=\"comment\">// 修改size和modCount</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// *******************************************************</span></span><br><span class=\"line\"><span class=\"comment\">//　指定下标处插入元素的add方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// check index&gt;=0 &amp;&amp; index&lt;=size</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\"><span class=\"comment\">// 等价于末尾插入</span></span><br><span class=\"line\">        linkLast(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"comment\">// 在链表前端节点插入，node方法返回index处的节点，后面详细介绍</span></span><br><span class=\"line\">        linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//　succ为index所在位置的节点，原链表A-&gt;succ-&gt;B</span></span><br><span class=\"line\"><span class=\"comment\">// 插入后链表A-&gt;newNode-&gt;succ-&gt;B</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\"><span class=\"comment\">//　因为是双向链表，succ.prev指针也需要更新</span></span><br><span class=\"line\">    succ.prev = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pred.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// *******************************************************</span></span><br><span class=\"line\"><span class=\"comment\">// 接下来看看LinkedList作为deque的一些方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 入栈操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    addFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　将元素添加到链表的第一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        f.prev = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入操作总的来说是先找到插入的位置，生成一个新的双向链表的Node节点，修改前后节点相应的指针。时间开销只需要一个遍历的开销，相比于<code>ArrayList</code>,<code>ArrayList</code>需要将index之后的元素进行位移，花费的开销更大。</p>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　先介绍下前面出现过几次的node()方法</span></span><br><span class=\"line\"><span class=\"comment\">// node方法返回指定Index处的节点，根据index与first及last的距离，选择较近的一端进行遍历，总的复杂度为O(n),而ArrayList根据index获取元素的时间复杂度为O(1)</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//根据指定下标获取元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//check index&gt;=0 &amp;&amp; index&lt;size</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkElementIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isElementIndex(index))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isElementIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　作为队列，有getFirst和getLasr两个方法，直接返回内部成员变量first和last指针的值，非空才返回，为空抛异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　判断是否包含某个元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(o) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　返回第一个相等对象的index</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//　从first节点开始遍历，检验是否存在对象o</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//　支持查找null对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 查找不到return -1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//还有一个lastIndexOf,从后向前查找，实现原理相同</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除指定下标处的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//check index&gt;=0 &amp;&amp; index&lt;size</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除指定对象，与indexOf的实现雷同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 从first向后遍历，支持null对象，找到该对象后调用unlink方法删除，删除成功返回true，否则false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                unlink(x);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                unlink(x);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\"><span class=\"comment\">// 获取即将删除节点的前一个节点和后一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除节点为first指向的节点，更新first指针为next</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除节点不是first指向的节点，将前一个节点的next指针更新，并把被删除节点的prev节点置空</span></span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除节点为last指向的节点，更新last指针为prev</span></span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 被删除的节点不是last指向的节点，更新被删除节点的后一个节点的prev指针</span></span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//　将x的各个成员变量置为null，方便GC,同时对size和modCount进行修改后返回被删除元素的值</span></span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//修改指定下标处的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// check index&gt;=0 &amp;&amp; index&lt;size</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\"><span class=\"comment\">//通过node方法获取index下标对应的节点，将其item变量更新</span></span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    x.item = element;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除所有元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//从first向后遍历，将当前节点的成员变量都置空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; ) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">        x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        x = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//将first,last,size恢复为空值</span></span><br><span class=\"line\">    first = last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// *****************************************************</span></span><br><span class=\"line\"><span class=\"comment\">// 作为deque的一些删除方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkFirst</span><span class=\"params\">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = f.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = f.next;</span><br><span class=\"line\">    f.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    f.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\"><span class=\"comment\">//更新first指针，并判断是否还存在元素</span></span><br><span class=\"line\">    first = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        next.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//removeLast与removeFirst实现相似，不再重复</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkLast</span><span class=\"params\">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = l.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class=\"line\">    l.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    l.prev = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">    last = prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        prev.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"deque方法介绍\"><a href=\"#deque方法介绍\" class=\"headerlink\" title=\"deque方法介绍\"></a>deque方法介绍</h3><p>上面的分析差不多已经介绍完大部分代码了，其实可以发现，有很多代码的逻辑都是相似的。<code>LinkedList</code>作为队列的实现类，还有很多针对队列的实现方法，但其实只是原有代码的再封装，我把之前没提到的一些方法放在这一部分一起介绍了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回队列第一个元素的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回队列第一个元素的值，与peek的区别在于，element方法在第一个元素不存在时会抛出异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">element</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getFirst();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回队列第一个元素，并删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回队列第一个元素，并删除，为空抛异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeFirst();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//末尾添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//头节点添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offerFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    addFirst(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//末尾添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offerLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    addLast(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//弹出list的第一个元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeFirst();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>LinkedList</code>的大部分代码都介绍完了，可以看出来比较简单。<code>LinkedList</code>底层实现为双向链表，除了可以作为<strong>List</strong>外，还可以作为队列和栈的实现类。因为是双向链表，所以对频繁的插入和删除操作较为友好，但是对频繁的根据下标获取的场景不够友好，需要权衡一下。才疏学浅，如有错误，欢迎指出</p>\n<h3 id=\"往期回顾\"><a href=\"#往期回顾\" class=\"headerlink\" title=\"往期回顾\"></a>往期回顾</h3><ul>\n<li><p><a href=\"https://cfk1996.github.io/2019/01/12/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/\" target=\"_blank\" rel=\"noopener\">Java集合源码系列-HashMap</a></p>\n</li>\n<li><p><a href=\"https://cfk1996.github.io/2019/01/22/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/\" target=\"_blank\" rel=\"noopener\">Java集合源码系列-ArrayList</a></p>\n</li>\n</ul>\n<h3 id=\"欢迎关注我的公众号\"><a href=\"#欢迎关注我的公众号\" class=\"headerlink\" title=\"欢迎关注我的公众号\"></a>欢迎关注我的公众号</h3><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"技术旅途\"></p>\n"},{"title":"Python多线程","date":"2018-05-29T11:12:18.000Z","_content":"最近在学习并发编程，打算写一个并发编程系列的文章。之前也看过很多Python多线程多进程的教程、博客等，但收益不大。因为大多数文章上来就是写几个对照代码，不去解释那些库方法的作用，然后得出多线程多进程确实快。这种教程相当于让我死记硬背，这是我无法接受的。\n\n经过长期摸索，我发现了一个神奇的网址，那就是[The Python Standard Library](https://docs.python.org/3/library/index.html).这在我刚学Python时就了解过，但当时看到整页整页的英文我就头大，现在慢慢适应了，发现它确实很好，对标准库的介绍非常详细。如果可以接受直接去看它就行，我的文章只是在它之上的一个翻译和总结。\n\n## 基础概念\n\n学习并发编程首先要了解一些基本概念，线程，进程，协程，IO等概念，不了解的可以学习一下操作系统。\n\n## GIL\n\nPython有个历史遗留问题，那就是全局解释器锁，一个进程同一个时刻只有一个线程在执行，如果将多线程用于CPU计算密集行工作可能效果不如单线程，但是在I/O这种耗时操作方面还是有用的，这方面可以查阅GIL相关资料。\n<!--more-->\n## threading\n\nthreading是Python标准的多线程接口，是对底层的_thread模块的封装， 使多线程用起来更加方便。\n\n这个模块定义了如下几个函数(列举部分用到的)：\n\n1. threading.active_count(): 返回当前存活的线程数量\n\n1. threading.current_thread(): 返回当前线程对象\n\n1. threading.enumerate(): 返回一个列表，列表包含所有存活的线程对象\n\n1. threading.main_thread()： 返回主线程对象\n\n### 创建线程\n\n有两种方法可以新创建一个线程对象，都基于Thread类。第一种是传一个可调用的对象（一般是函数）给Thread的构造器，第二种是继承Thread类，重写它的run方法。\n\n一旦thread对象被创建，需要调用对象的start()方法让他在一个单独的线程中运行，即运行run方法。\n\n### class threading.Thread\n\nclass threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)。\n\n构造Thread类时传入的参数必须是关键字参数。\n\ngroup可忽略，target为需要执行的函数func，name为线程的名字（没实际意义，可忽略），args为func需要的参数元祖(注意是元祖，元祖的单个形式为`(arg,)`)，kwargs为func需要的关键字参数，daemon设置是否为守护进程。\n\n**start()**： 启动线程\n\n**run()**： 线程运行后执行的函数\n\n**join()**: This blocks the calling thread until the thread whose join() method is called is terminated.比如在A线程中调用B.join()，A就会阻塞，直到B运行结束，看个例子。\n\n```python\nfrom threading import Thread\n\ndef hello(num):\n    print(num)\n\nif __name__ == '__main__':\n    threads = []\n    for i in range(10):\n        t = Thread(target=hello, args=(i,))\n        threads.append(t)\n    for t in threads:\n        t.start()\n        t.join()\n    print('1111111')\n# output: 节省篇幅，用，代替换行\n# 0， 1, 2, 3, 4, 5, 6, 7, 8, 9, 1111111\nif __name__ == '__main__':\n    ...\n    for t in threads:\n        t.start()\n    print('22222')\n# output:\n# 0, 1, 2, 3, 4, 6, 5, 22222, 8, 7, 9\n```\n\n注意Print('22222')的位置。the calling thread在这里就是主线程，the thread whose join is called在这里是threads列表里的对象。所以这句话意思就是主线程会一直阻塞，直到所有threads里的thread执行完毕。如果不调用join()方法，主线程就不会等待子线程的执行。\n\n## 同步机制\n\n不同的线程可能需要对同一个资源进行修改，如果不加控制，会出现意想不到的结果，来看个神奇的例子。\n\n```python\ncount = 0\ndef add():\n    global count\n    temp = count + 1\n    time.sleep(0.0001)\n    count = temp\n\nthreads = []\n\nfor i in range(10):\n    t = Thread(target=add)\n    threads.append(t)\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\nprint('count={}'.format(count))\n# output: 运行三次的结果\n# 3, 4， 4\n```\n\n正常来说count的值应该是10,因为我调用了10个线程。但结果却是3或4或其他数，原因在于time.sleep()和多线程并发，time的作用只是让线程有机会交叉执行。考虑两个线程并发执行。\n\n\n| A线程       | B线程    |\n| :------: | :-----:  |\n|     global count(count=0)   |      |\n|     temp = count+1（temp=1)    |      |\n|      time.sleep()  |       |\n| | global count(count=0) |\n|  | temp = count+1 (temp=1) |\n|  | time.sleep() |\n| count = temp(count=1) |  |\n|  | count = temp(count=1) |\n\n\n如果不加控制，并发操作会导致意料不到的后果，所以需要采取一些手段来控制并发的执行顺序。\n\n### Lock 锁\n\n锁有两个状态，上锁了(locked)和没上锁(unlocked)。一个锁对象创建时是没上锁的状态。锁有两个基本函数，acquire()用来上锁，release()用来释放锁。如果锁处于上锁状态，不能调用acquire();属于未上锁状态，不能调用release()，否则会引起错误。对上面一个例子进行加锁处理。\n\n```python\ncount = 0\n\ndef add(lock):\n    global count\n    lock.acquire()\n    temp = count + 1\n    time.sleep(0.0001)\n    lock.release()\n    count = temp\n\nthreads = []\nlock = Lock()\n\nfor i in range(10):\n    t = Thread(target=add, args=(lock,))\n    threads.append(t)\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\nprint('count={}'.format(count))\n# output:\n# 10\n```\n\n锁如果不恰当控制会出现死锁的情况，关于死锁的原因和解决办法在操作系统中也有涉及，不了解的学习一下操作系统，我这篇文章只介绍多线程模块的基本用法。\n\n### RLock 可重入锁\n\n对于这个锁我有点困惑，想不到它的实际应用场景，可重入锁建立在锁的基础上，获得锁A的线程可以对锁A进行再次加锁而不会陷入死锁，但释放操作也需要相同次数，但是其他线程无法在锁住的情况下获得锁，同样对上面例子进行修改。还没找到一个很有说服力的需要加多次锁的例子。\n\n```python\n# ...不变\ndef add(lock):\n    global count\n    lock.acquire()\n    temp = count + 1\n    lock.acquire()\n    time.sleep(0.0001)\n    lock.release()\n    count = temp\n    lock.release()\n# ...不变\n```\n\n### Condition 条件\n\n条件也是建立在锁的基础上，在创建条件对象时可以传入一个锁或可重入锁，不传入参数则默认生成一个可重入锁。一些线程A等待条件而阻塞，一些线程B发出条件满足的信号，则等待的线程A可以继续运行。线程A首先acquire()加锁，在wait()处释放锁并阻塞，当其他线程发出条件满足信号，发出条件满足信号的方法有两个，一个是notify()，唤醒一个等待线程，另一个是notify_all()唤醒所有等待线程;A线程的wait()重新加锁并返回。经典的场景可能就是消费者和生产者模式。\n\n```python\ndef consumer(con):\n    con.acquire()\n    print('{} is waiting'.format(threading.currentThread().name))\n    con.wait()\n    print('{} cousumes one time.'.format(threading.currentThread().name))\n    con.release()\n\ndef producer(con):\n    print('prodece and notify')\n    con.acquire()\n    con.notify_all()\n    con.release()\n\nthreads, condition = [], Condition()\n\nfor i in range(5):\n    t = Thread(target=consumer, args=(condition,))\n    threads.append(t)\n\nfor t in threads:\n    t.start()\n\nproduce = Thread(target=producer, args=(condition,))\nproduce.start()\nproduce.join()\nfor t in threads:\n    t.join()\nprint('end')\n# output:\n# Thread-1 is waiting\n# Thread-2 is waiting\n# Thread-3 is waiting\n# Thread-4 is waiting\n# Thread-5 is waiting\n# prodece and notify\n# Thread-1 cousumes one time.\n# Thread-4 cousumes one time.\n# Thread-5 cousumes one time.\n# Thread-2 cousumes one time.\n# Thread-3 cousumes one time.\n# end\n```\n\n### Semaphore 信号量\n\n方法与Lock()一样，但是可以在创建信号量时可以传入一个大于０的整数，当传入的整数为１时与Lock作用相同。信号量一般用于限制并发的数量，如连接数据库服务器时需要在连接数量控制在一定范围内。\n\n```python\ndef hello(sem):\n    sem.acquire()\n    time.sleep(1)\n    print('{} is running'.format(threading.currentThread().name))\n    sem.release()\n\nthreads, sem = [], Semaphore(5)\n\nfor i in range(100):\n    t = Thread(target=hello, args=(sem,))\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n```\n\n可以在自己的电脑上运行一下，会看到print结果是5个5个的出现，sleep时间长点效果更明显。可以看到虽然开了100个线程，但是同时在运行只有5个。\n\n### Event 事件\n\n一个线程标识一个事件，其他线程等待它。一个事件对象管理一个内部标志，这个标志可以用set()置为true,用clear()置为false。wait()方法会一直阻塞直到标志为true。这个看起来似乎跟条件有点像。\n\n```python\ndef consumer(event):\n    print('{} is waiting for an event.'.format(threading.currentThread().name))\n    event.wait()\n    print('{} finish.'.format(threading.currentThread().name))\n\ndef producer(event):\n    print('producer')\n    event.set()\n\nthreads, event = [], Event()\n\nfor i in range(3):\n    t = Thread(target=consumer, args=(event,))\n    threads.append(t)\n    t.start()\n\nproduce = Thread(target=producer, args=(event,))\nproduce.start()\nfor t in threads:\n    t.join()\nproduce.join()\nprint('end')\n# output:\n# Thread-1 is waiting for an event.\n# Thread-2 is waiting for an event.\n# Thread-3 is waiting for an event.\n# producer\n# Thread-2 finish.\n# Thread-3 finish.\n# Thread-1 finish.\n# end\n```\n\n### 上下文管理器\n\n上下文管理协议是Python的一个语法糖吧，用来方便资源的申请与释放。实现了上下文管理协议的类就可以用with语句包裹，简化代码的书写。具体实现查阅资料。\n\n上面介绍的那么多同步机制大多数都有一个申请锁和释放锁的步骤，可以用with语句简化这些操作，支持with语法的有lock, Rlock, conditions和semaphore.官网示例如下：\n\n```python\nwith some_lock:\n    # do something\n```\n\n等价于\n\n```python\nsome_lock.acquire()\ntry:\n    # do something\nfinally:\n    some_lock.release()\n```\n\n## 最后\n\n如果还有疑问，标准库是你最好的选择！刚开始看也许看不下去，有这么几个建议。\n\n1. 看简短一点的模块\n2. 积累专业词汇量\n3. 找自己熟悉的模块入手，这样你就能大概的猜出它的意思","source":"_posts/Python多线程.md","raw":"---\ntitle: Python多线程\ndate: 2018-05-29 19:12:18\ntags:\n    - Python\n---\n最近在学习并发编程，打算写一个并发编程系列的文章。之前也看过很多Python多线程多进程的教程、博客等，但收益不大。因为大多数文章上来就是写几个对照代码，不去解释那些库方法的作用，然后得出多线程多进程确实快。这种教程相当于让我死记硬背，这是我无法接受的。\n\n经过长期摸索，我发现了一个神奇的网址，那就是[The Python Standard Library](https://docs.python.org/3/library/index.html).这在我刚学Python时就了解过，但当时看到整页整页的英文我就头大，现在慢慢适应了，发现它确实很好，对标准库的介绍非常详细。如果可以接受直接去看它就行，我的文章只是在它之上的一个翻译和总结。\n\n## 基础概念\n\n学习并发编程首先要了解一些基本概念，线程，进程，协程，IO等概念，不了解的可以学习一下操作系统。\n\n## GIL\n\nPython有个历史遗留问题，那就是全局解释器锁，一个进程同一个时刻只有一个线程在执行，如果将多线程用于CPU计算密集行工作可能效果不如单线程，但是在I/O这种耗时操作方面还是有用的，这方面可以查阅GIL相关资料。\n<!--more-->\n## threading\n\nthreading是Python标准的多线程接口，是对底层的_thread模块的封装， 使多线程用起来更加方便。\n\n这个模块定义了如下几个函数(列举部分用到的)：\n\n1. threading.active_count(): 返回当前存活的线程数量\n\n1. threading.current_thread(): 返回当前线程对象\n\n1. threading.enumerate(): 返回一个列表，列表包含所有存活的线程对象\n\n1. threading.main_thread()： 返回主线程对象\n\n### 创建线程\n\n有两种方法可以新创建一个线程对象，都基于Thread类。第一种是传一个可调用的对象（一般是函数）给Thread的构造器，第二种是继承Thread类，重写它的run方法。\n\n一旦thread对象被创建，需要调用对象的start()方法让他在一个单独的线程中运行，即运行run方法。\n\n### class threading.Thread\n\nclass threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)。\n\n构造Thread类时传入的参数必须是关键字参数。\n\ngroup可忽略，target为需要执行的函数func，name为线程的名字（没实际意义，可忽略），args为func需要的参数元祖(注意是元祖，元祖的单个形式为`(arg,)`)，kwargs为func需要的关键字参数，daemon设置是否为守护进程。\n\n**start()**： 启动线程\n\n**run()**： 线程运行后执行的函数\n\n**join()**: This blocks the calling thread until the thread whose join() method is called is terminated.比如在A线程中调用B.join()，A就会阻塞，直到B运行结束，看个例子。\n\n```python\nfrom threading import Thread\n\ndef hello(num):\n    print(num)\n\nif __name__ == '__main__':\n    threads = []\n    for i in range(10):\n        t = Thread(target=hello, args=(i,))\n        threads.append(t)\n    for t in threads:\n        t.start()\n        t.join()\n    print('1111111')\n# output: 节省篇幅，用，代替换行\n# 0， 1, 2, 3, 4, 5, 6, 7, 8, 9, 1111111\nif __name__ == '__main__':\n    ...\n    for t in threads:\n        t.start()\n    print('22222')\n# output:\n# 0, 1, 2, 3, 4, 6, 5, 22222, 8, 7, 9\n```\n\n注意Print('22222')的位置。the calling thread在这里就是主线程，the thread whose join is called在这里是threads列表里的对象。所以这句话意思就是主线程会一直阻塞，直到所有threads里的thread执行完毕。如果不调用join()方法，主线程就不会等待子线程的执行。\n\n## 同步机制\n\n不同的线程可能需要对同一个资源进行修改，如果不加控制，会出现意想不到的结果，来看个神奇的例子。\n\n```python\ncount = 0\ndef add():\n    global count\n    temp = count + 1\n    time.sleep(0.0001)\n    count = temp\n\nthreads = []\n\nfor i in range(10):\n    t = Thread(target=add)\n    threads.append(t)\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\nprint('count={}'.format(count))\n# output: 运行三次的结果\n# 3, 4， 4\n```\n\n正常来说count的值应该是10,因为我调用了10个线程。但结果却是3或4或其他数，原因在于time.sleep()和多线程并发，time的作用只是让线程有机会交叉执行。考虑两个线程并发执行。\n\n\n| A线程       | B线程    |\n| :------: | :-----:  |\n|     global count(count=0)   |      |\n|     temp = count+1（temp=1)    |      |\n|      time.sleep()  |       |\n| | global count(count=0) |\n|  | temp = count+1 (temp=1) |\n|  | time.sleep() |\n| count = temp(count=1) |  |\n|  | count = temp(count=1) |\n\n\n如果不加控制，并发操作会导致意料不到的后果，所以需要采取一些手段来控制并发的执行顺序。\n\n### Lock 锁\n\n锁有两个状态，上锁了(locked)和没上锁(unlocked)。一个锁对象创建时是没上锁的状态。锁有两个基本函数，acquire()用来上锁，release()用来释放锁。如果锁处于上锁状态，不能调用acquire();属于未上锁状态，不能调用release()，否则会引起错误。对上面一个例子进行加锁处理。\n\n```python\ncount = 0\n\ndef add(lock):\n    global count\n    lock.acquire()\n    temp = count + 1\n    time.sleep(0.0001)\n    lock.release()\n    count = temp\n\nthreads = []\nlock = Lock()\n\nfor i in range(10):\n    t = Thread(target=add, args=(lock,))\n    threads.append(t)\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\nprint('count={}'.format(count))\n# output:\n# 10\n```\n\n锁如果不恰当控制会出现死锁的情况，关于死锁的原因和解决办法在操作系统中也有涉及，不了解的学习一下操作系统，我这篇文章只介绍多线程模块的基本用法。\n\n### RLock 可重入锁\n\n对于这个锁我有点困惑，想不到它的实际应用场景，可重入锁建立在锁的基础上，获得锁A的线程可以对锁A进行再次加锁而不会陷入死锁，但释放操作也需要相同次数，但是其他线程无法在锁住的情况下获得锁，同样对上面例子进行修改。还没找到一个很有说服力的需要加多次锁的例子。\n\n```python\n# ...不变\ndef add(lock):\n    global count\n    lock.acquire()\n    temp = count + 1\n    lock.acquire()\n    time.sleep(0.0001)\n    lock.release()\n    count = temp\n    lock.release()\n# ...不变\n```\n\n### Condition 条件\n\n条件也是建立在锁的基础上，在创建条件对象时可以传入一个锁或可重入锁，不传入参数则默认生成一个可重入锁。一些线程A等待条件而阻塞，一些线程B发出条件满足的信号，则等待的线程A可以继续运行。线程A首先acquire()加锁，在wait()处释放锁并阻塞，当其他线程发出条件满足信号，发出条件满足信号的方法有两个，一个是notify()，唤醒一个等待线程，另一个是notify_all()唤醒所有等待线程;A线程的wait()重新加锁并返回。经典的场景可能就是消费者和生产者模式。\n\n```python\ndef consumer(con):\n    con.acquire()\n    print('{} is waiting'.format(threading.currentThread().name))\n    con.wait()\n    print('{} cousumes one time.'.format(threading.currentThread().name))\n    con.release()\n\ndef producer(con):\n    print('prodece and notify')\n    con.acquire()\n    con.notify_all()\n    con.release()\n\nthreads, condition = [], Condition()\n\nfor i in range(5):\n    t = Thread(target=consumer, args=(condition,))\n    threads.append(t)\n\nfor t in threads:\n    t.start()\n\nproduce = Thread(target=producer, args=(condition,))\nproduce.start()\nproduce.join()\nfor t in threads:\n    t.join()\nprint('end')\n# output:\n# Thread-1 is waiting\n# Thread-2 is waiting\n# Thread-3 is waiting\n# Thread-4 is waiting\n# Thread-5 is waiting\n# prodece and notify\n# Thread-1 cousumes one time.\n# Thread-4 cousumes one time.\n# Thread-5 cousumes one time.\n# Thread-2 cousumes one time.\n# Thread-3 cousumes one time.\n# end\n```\n\n### Semaphore 信号量\n\n方法与Lock()一样，但是可以在创建信号量时可以传入一个大于０的整数，当传入的整数为１时与Lock作用相同。信号量一般用于限制并发的数量，如连接数据库服务器时需要在连接数量控制在一定范围内。\n\n```python\ndef hello(sem):\n    sem.acquire()\n    time.sleep(1)\n    print('{} is running'.format(threading.currentThread().name))\n    sem.release()\n\nthreads, sem = [], Semaphore(5)\n\nfor i in range(100):\n    t = Thread(target=hello, args=(sem,))\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n```\n\n可以在自己的电脑上运行一下，会看到print结果是5个5个的出现，sleep时间长点效果更明显。可以看到虽然开了100个线程，但是同时在运行只有5个。\n\n### Event 事件\n\n一个线程标识一个事件，其他线程等待它。一个事件对象管理一个内部标志，这个标志可以用set()置为true,用clear()置为false。wait()方法会一直阻塞直到标志为true。这个看起来似乎跟条件有点像。\n\n```python\ndef consumer(event):\n    print('{} is waiting for an event.'.format(threading.currentThread().name))\n    event.wait()\n    print('{} finish.'.format(threading.currentThread().name))\n\ndef producer(event):\n    print('producer')\n    event.set()\n\nthreads, event = [], Event()\n\nfor i in range(3):\n    t = Thread(target=consumer, args=(event,))\n    threads.append(t)\n    t.start()\n\nproduce = Thread(target=producer, args=(event,))\nproduce.start()\nfor t in threads:\n    t.join()\nproduce.join()\nprint('end')\n# output:\n# Thread-1 is waiting for an event.\n# Thread-2 is waiting for an event.\n# Thread-3 is waiting for an event.\n# producer\n# Thread-2 finish.\n# Thread-3 finish.\n# Thread-1 finish.\n# end\n```\n\n### 上下文管理器\n\n上下文管理协议是Python的一个语法糖吧，用来方便资源的申请与释放。实现了上下文管理协议的类就可以用with语句包裹，简化代码的书写。具体实现查阅资料。\n\n上面介绍的那么多同步机制大多数都有一个申请锁和释放锁的步骤，可以用with语句简化这些操作，支持with语法的有lock, Rlock, conditions和semaphore.官网示例如下：\n\n```python\nwith some_lock:\n    # do something\n```\n\n等价于\n\n```python\nsome_lock.acquire()\ntry:\n    # do something\nfinally:\n    some_lock.release()\n```\n\n## 最后\n\n如果还有疑问，标准库是你最好的选择！刚开始看也许看不下去，有这么几个建议。\n\n1. 看简短一点的模块\n2. 积累专业词汇量\n3. 找自己熟悉的模块入手，这样你就能大概的猜出它的意思","slug":"Python多线程","published":1,"updated":"2019-02-03T07:16:46.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkll6000euetuy08mel3i","content":"<p>最近在学习并发编程，打算写一个并发编程系列的文章。之前也看过很多Python多线程多进程的教程、博客等，但收益不大。因为大多数文章上来就是写几个对照代码，不去解释那些库方法的作用，然后得出多线程多进程确实快。这种教程相当于让我死记硬背，这是我无法接受的。</p>\n<p>经过长期摸索，我发现了一个神奇的网址，那就是<a href=\"https://docs.python.org/3/library/index.html\" target=\"_blank\" rel=\"noopener\">The Python Standard Library</a>.这在我刚学Python时就了解过，但当时看到整页整页的英文我就头大，现在慢慢适应了，发现它确实很好，对标准库的介绍非常详细。如果可以接受直接去看它就行，我的文章只是在它之上的一个翻译和总结。</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>学习并发编程首先要了解一些基本概念，线程，进程，协程，IO等概念，不了解的可以学习一下操作系统。</p>\n<h2 id=\"GIL\"><a href=\"#GIL\" class=\"headerlink\" title=\"GIL\"></a>GIL</h2><p>Python有个历史遗留问题，那就是全局解释器锁，一个进程同一个时刻只有一个线程在执行，如果将多线程用于CPU计算密集行工作可能效果不如单线程，但是在I/O这种耗时操作方面还是有用的，这方面可以查阅GIL相关资料。<br><a id=\"more\"></a></p>\n<h2 id=\"threading\"><a href=\"#threading\" class=\"headerlink\" title=\"threading\"></a>threading</h2><p>threading是Python标准的多线程接口，是对底层的_thread模块的封装， 使多线程用起来更加方便。</p>\n<p>这个模块定义了如下几个函数(列举部分用到的)：</p>\n<ol>\n<li><p>threading.active_count(): 返回当前存活的线程数量</p>\n</li>\n<li><p>threading.current_thread(): 返回当前线程对象</p>\n</li>\n<li><p>threading.enumerate(): 返回一个列表，列表包含所有存活的线程对象</p>\n</li>\n<li><p>threading.main_thread()： 返回主线程对象</p>\n</li>\n</ol>\n<h3 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h3><p>有两种方法可以新创建一个线程对象，都基于Thread类。第一种是传一个可调用的对象（一般是函数）给Thread的构造器，第二种是继承Thread类，重写它的run方法。</p>\n<p>一旦thread对象被创建，需要调用对象的start()方法让他在一个单独的线程中运行，即运行run方法。</p>\n<h3 id=\"class-threading-Thread\"><a href=\"#class-threading-Thread\" class=\"headerlink\" title=\"class threading.Thread\"></a>class threading.Thread</h3><p>class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)。</p>\n<p>构造Thread类时传入的参数必须是关键字参数。</p>\n<p>group可忽略，target为需要执行的函数func，name为线程的名字（没实际意义，可忽略），args为func需要的参数元祖(注意是元祖，元祖的单个形式为<code>(arg,)</code>)，kwargs为func需要的关键字参数，daemon设置是否为守护进程。</p>\n<p><strong>start()</strong>： 启动线程</p>\n<p><strong>run()</strong>： 线程运行后执行的函数</p>\n<p><strong>join()</strong>: This blocks the calling thread until the thread whose join() method is called is terminated.比如在A线程中调用B.join()，A就会阻塞，直到B运行结束，看个例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">    print(num)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        t = Thread(target=hello, args=(i,))</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">        t.join()</span><br><span class=\"line\">    print(<span class=\"string\">'1111111'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output: 节省篇幅，用，代替换行</span></span><br><span class=\"line\"><span class=\"comment\"># 0， 1, 2, 3, 4, 5, 6, 7, 8, 9, 1111111</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">    print(<span class=\"string\">'22222'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># 0, 1, 2, 3, 4, 6, 5, 22222, 8, 7, 9</span></span><br></pre></td></tr></table></figure>\n<p>注意Print(‘22222’)的位置。the calling thread在这里就是主线程，the thread whose join is called在这里是threads列表里的对象。所以这句话意思就是主线程会一直阻塞，直到所有threads里的thread执行完毕。如果不调用join()方法，主线程就不会等待子线程的执行。</p>\n<h2 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h2><p>不同的线程可能需要对同一个资源进行修改，如果不加控制，会出现意想不到的结果，来看个神奇的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> count</span><br><span class=\"line\">    temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.0001</span>)</span><br><span class=\"line\">    count = temp</span><br><span class=\"line\"></span><br><span class=\"line\">threads = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = Thread(target=add)</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'count=&#123;&#125;'</span>.format(count))</span><br><span class=\"line\"><span class=\"comment\"># output: 运行三次的结果</span></span><br><span class=\"line\"><span class=\"comment\"># 3, 4， 4</span></span><br></pre></td></tr></table></figure>\n<p>正常来说count的值应该是10,因为我调用了10个线程。但结果却是3或4或其他数，原因在于time.sleep()和多线程并发，time的作用只是让线程有机会交叉执行。考虑两个线程并发执行。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">A线程</th>\n<th style=\"text-align:center\">B线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">global count(count=0)</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">temp = count+1（temp=1)</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">time.sleep()</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">global count(count=0)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">temp = count+1 (temp=1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">time.sleep()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count = temp(count=1)</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">count = temp(count=1)</td>\n</tr>\n</tbody>\n</table>\n<p>如果不加控制，并发操作会导致意料不到的后果，所以需要采取一些手段来控制并发的执行顺序。</p>\n<h3 id=\"Lock-锁\"><a href=\"#Lock-锁\" class=\"headerlink\" title=\"Lock 锁\"></a>Lock 锁</h3><p>锁有两个状态，上锁了(locked)和没上锁(unlocked)。一个锁对象创建时是没上锁的状态。锁有两个基本函数，acquire()用来上锁，release()用来释放锁。如果锁处于上锁状态，不能调用acquire();属于未上锁状态，不能调用release()，否则会引起错误。对上面一个例子进行加锁处理。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(lock)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> count</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.0001</span>)</span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\">    count = temp</span><br><span class=\"line\"></span><br><span class=\"line\">threads = []</span><br><span class=\"line\">lock = Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = Thread(target=add, args=(lock,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'count=&#123;&#125;'</span>.format(count))</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># 10</span></span><br></pre></td></tr></table></figure>\n<p>锁如果不恰当控制会出现死锁的情况，关于死锁的原因和解决办法在操作系统中也有涉及，不了解的学习一下操作系统，我这篇文章只介绍多线程模块的基本用法。</p>\n<h3 id=\"RLock-可重入锁\"><a href=\"#RLock-可重入锁\" class=\"headerlink\" title=\"RLock 可重入锁\"></a>RLock 可重入锁</h3><p>对于这个锁我有点困惑，想不到它的实际应用场景，可重入锁建立在锁的基础上，获得锁A的线程可以对锁A进行再次加锁而不会陷入死锁，但释放操作也需要相同次数，但是其他线程无法在锁住的情况下获得锁，同样对上面例子进行修改。还没找到一个很有说服力的需要加多次锁的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ...不变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(lock)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> count</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.0001</span>)</span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\">    count = temp</span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\"><span class=\"comment\"># ...不变</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Condition-条件\"><a href=\"#Condition-条件\" class=\"headerlink\" title=\"Condition 条件\"></a>Condition 条件</h3><p>条件也是建立在锁的基础上，在创建条件对象时可以传入一个锁或可重入锁，不传入参数则默认生成一个可重入锁。一些线程A等待条件而阻塞，一些线程B发出条件满足的信号，则等待的线程A可以继续运行。线程A首先acquire()加锁，在wait()处释放锁并阻塞，当其他线程发出条件满足信号，发出条件满足信号的方法有两个，一个是notify()，唤醒一个等待线程，另一个是notify_all()唤醒所有等待线程;A线程的wait()重新加锁并返回。经典的场景可能就是消费者和生产者模式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">(con)</span>:</span></span><br><span class=\"line\">    con.acquire()</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; is waiting'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    con.wait()</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; cousumes one time.'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    con.release()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">producer</span><span class=\"params\">(con)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'prodece and notify'</span>)</span><br><span class=\"line\">    con.acquire()</span><br><span class=\"line\">    con.notify_all()</span><br><span class=\"line\">    con.release()</span><br><span class=\"line\"></span><br><span class=\"line\">threads, condition = [], Condition()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">    t = Thread(target=consumer, args=(condition,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">produce = Thread(target=producer, args=(condition,))</span><br><span class=\"line\">produce.start()</span><br><span class=\"line\">produce.join()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\">print(<span class=\"string\">'end'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-4 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-5 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># prodece and notify</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-4 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-5 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Semaphore-信号量\"><a href=\"#Semaphore-信号量\" class=\"headerlink\" title=\"Semaphore 信号量\"></a>Semaphore 信号量</h3><p>方法与Lock()一样，但是可以在创建信号量时可以传入一个大于０的整数，当传入的整数为１时与Lock作用相同。信号量一般用于限制并发的数量，如连接数据库服务器时需要在连接数量控制在一定范围内。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">(sem)</span>:</span></span><br><span class=\"line\">    sem.acquire()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; is running'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    sem.release()</span><br><span class=\"line\"></span><br><span class=\"line\">threads, sem = [], Semaphore(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100</span>):</span><br><span class=\"line\">    t = Thread(target=hello, args=(sem,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br></pre></td></tr></table></figure>\n<p>可以在自己的电脑上运行一下，会看到print结果是5个5个的出现，sleep时间长点效果更明显。可以看到虽然开了100个线程，但是同时在运行只有5个。</p>\n<h3 id=\"Event-事件\"><a href=\"#Event-事件\" class=\"headerlink\" title=\"Event 事件\"></a>Event 事件</h3><p>一个线程标识一个事件，其他线程等待它。一个事件对象管理一个内部标志，这个标志可以用set()置为true,用clear()置为false。wait()方法会一直阻塞直到标志为true。这个看起来似乎跟条件有点像。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">(event)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; is waiting for an event.'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    event.wait()</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; finish.'</span>.format(threading.currentThread().name))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">producer</span><span class=\"params\">(event)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'producer'</span>)</span><br><span class=\"line\">    event.set()</span><br><span class=\"line\"></span><br><span class=\"line\">threads, event = [], Event()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">    t = Thread(target=consumer, args=(event,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">produce = Thread(target=producer, args=(event,))</span><br><span class=\"line\">produce.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\">produce.join()</span><br><span class=\"line\">print(<span class=\"string\">'end'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 is waiting for an event.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 is waiting for an event.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 is waiting for an event.</span></span><br><span class=\"line\"><span class=\"comment\"># producer</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 finish.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 finish.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 finish.</span></span><br><span class=\"line\"><span class=\"comment\"># end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"上下文管理器\"><a href=\"#上下文管理器\" class=\"headerlink\" title=\"上下文管理器\"></a>上下文管理器</h3><p>上下文管理协议是Python的一个语法糖吧，用来方便资源的申请与释放。实现了上下文管理协议的类就可以用with语句包裹，简化代码的书写。具体实现查阅资料。</p>\n<p>上面介绍的那么多同步机制大多数都有一个申请锁和释放锁的步骤，可以用with语句简化这些操作，支持with语法的有lock, Rlock, conditions和semaphore.官网示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> some_lock:</span><br><span class=\"line\">    <span class=\"comment\"># do something</span></span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">some_lock.acquire()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># do something</span></span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    some_lock.release()</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果还有疑问，标准库是你最好的选择！刚开始看也许看不下去，有这么几个建议。</p>\n<ol>\n<li>看简短一点的模块</li>\n<li>积累专业词汇量</li>\n<li>找自己熟悉的模块入手，这样你就能大概的猜出它的意思</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>最近在学习并发编程，打算写一个并发编程系列的文章。之前也看过很多Python多线程多进程的教程、博客等，但收益不大。因为大多数文章上来就是写几个对照代码，不去解释那些库方法的作用，然后得出多线程多进程确实快。这种教程相当于让我死记硬背，这是我无法接受的。</p>\n<p>经过长期摸索，我发现了一个神奇的网址，那就是<a href=\"https://docs.python.org/3/library/index.html\" target=\"_blank\" rel=\"noopener\">The Python Standard Library</a>.这在我刚学Python时就了解过，但当时看到整页整页的英文我就头大，现在慢慢适应了，发现它确实很好，对标准库的介绍非常详细。如果可以接受直接去看它就行，我的文章只是在它之上的一个翻译和总结。</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>学习并发编程首先要了解一些基本概念，线程，进程，协程，IO等概念，不了解的可以学习一下操作系统。</p>\n<h2 id=\"GIL\"><a href=\"#GIL\" class=\"headerlink\" title=\"GIL\"></a>GIL</h2><p>Python有个历史遗留问题，那就是全局解释器锁，一个进程同一个时刻只有一个线程在执行，如果将多线程用于CPU计算密集行工作可能效果不如单线程，但是在I/O这种耗时操作方面还是有用的，这方面可以查阅GIL相关资料。<br>","more":"</p>\n<h2 id=\"threading\"><a href=\"#threading\" class=\"headerlink\" title=\"threading\"></a>threading</h2><p>threading是Python标准的多线程接口，是对底层的_thread模块的封装， 使多线程用起来更加方便。</p>\n<p>这个模块定义了如下几个函数(列举部分用到的)：</p>\n<ol>\n<li><p>threading.active_count(): 返回当前存活的线程数量</p>\n</li>\n<li><p>threading.current_thread(): 返回当前线程对象</p>\n</li>\n<li><p>threading.enumerate(): 返回一个列表，列表包含所有存活的线程对象</p>\n</li>\n<li><p>threading.main_thread()： 返回主线程对象</p>\n</li>\n</ol>\n<h3 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h3><p>有两种方法可以新创建一个线程对象，都基于Thread类。第一种是传一个可调用的对象（一般是函数）给Thread的构造器，第二种是继承Thread类，重写它的run方法。</p>\n<p>一旦thread对象被创建，需要调用对象的start()方法让他在一个单独的线程中运行，即运行run方法。</p>\n<h3 id=\"class-threading-Thread\"><a href=\"#class-threading-Thread\" class=\"headerlink\" title=\"class threading.Thread\"></a>class threading.Thread</h3><p>class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)。</p>\n<p>构造Thread类时传入的参数必须是关键字参数。</p>\n<p>group可忽略，target为需要执行的函数func，name为线程的名字（没实际意义，可忽略），args为func需要的参数元祖(注意是元祖，元祖的单个形式为<code>(arg,)</code>)，kwargs为func需要的关键字参数，daemon设置是否为守护进程。</p>\n<p><strong>start()</strong>： 启动线程</p>\n<p><strong>run()</strong>： 线程运行后执行的函数</p>\n<p><strong>join()</strong>: This blocks the calling thread until the thread whose join() method is called is terminated.比如在A线程中调用B.join()，A就会阻塞，直到B运行结束，看个例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">    print(num)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        t = Thread(target=hello, args=(i,))</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">        t.join()</span><br><span class=\"line\">    print(<span class=\"string\">'1111111'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output: 节省篇幅，用，代替换行</span></span><br><span class=\"line\"><span class=\"comment\"># 0， 1, 2, 3, 4, 5, 6, 7, 8, 9, 1111111</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">    print(<span class=\"string\">'22222'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># 0, 1, 2, 3, 4, 6, 5, 22222, 8, 7, 9</span></span><br></pre></td></tr></table></figure>\n<p>注意Print(‘22222’)的位置。the calling thread在这里就是主线程，the thread whose join is called在这里是threads列表里的对象。所以这句话意思就是主线程会一直阻塞，直到所有threads里的thread执行完毕。如果不调用join()方法，主线程就不会等待子线程的执行。</p>\n<h2 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h2><p>不同的线程可能需要对同一个资源进行修改，如果不加控制，会出现意想不到的结果，来看个神奇的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> count</span><br><span class=\"line\">    temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.0001</span>)</span><br><span class=\"line\">    count = temp</span><br><span class=\"line\"></span><br><span class=\"line\">threads = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = Thread(target=add)</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'count=&#123;&#125;'</span>.format(count))</span><br><span class=\"line\"><span class=\"comment\"># output: 运行三次的结果</span></span><br><span class=\"line\"><span class=\"comment\"># 3, 4， 4</span></span><br></pre></td></tr></table></figure>\n<p>正常来说count的值应该是10,因为我调用了10个线程。但结果却是3或4或其他数，原因在于time.sleep()和多线程并发，time的作用只是让线程有机会交叉执行。考虑两个线程并发执行。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">A线程</th>\n<th style=\"text-align:center\">B线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">global count(count=0)</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">temp = count+1（temp=1)</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">time.sleep()</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">global count(count=0)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">temp = count+1 (temp=1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">time.sleep()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count = temp(count=1)</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">count = temp(count=1)</td>\n</tr>\n</tbody>\n</table>\n<p>如果不加控制，并发操作会导致意料不到的后果，所以需要采取一些手段来控制并发的执行顺序。</p>\n<h3 id=\"Lock-锁\"><a href=\"#Lock-锁\" class=\"headerlink\" title=\"Lock 锁\"></a>Lock 锁</h3><p>锁有两个状态，上锁了(locked)和没上锁(unlocked)。一个锁对象创建时是没上锁的状态。锁有两个基本函数，acquire()用来上锁，release()用来释放锁。如果锁处于上锁状态，不能调用acquire();属于未上锁状态，不能调用release()，否则会引起错误。对上面一个例子进行加锁处理。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(lock)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> count</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.0001</span>)</span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\">    count = temp</span><br><span class=\"line\"></span><br><span class=\"line\">threads = []</span><br><span class=\"line\">lock = Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = Thread(target=add, args=(lock,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'count=&#123;&#125;'</span>.format(count))</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># 10</span></span><br></pre></td></tr></table></figure>\n<p>锁如果不恰当控制会出现死锁的情况，关于死锁的原因和解决办法在操作系统中也有涉及，不了解的学习一下操作系统，我这篇文章只介绍多线程模块的基本用法。</p>\n<h3 id=\"RLock-可重入锁\"><a href=\"#RLock-可重入锁\" class=\"headerlink\" title=\"RLock 可重入锁\"></a>RLock 可重入锁</h3><p>对于这个锁我有点困惑，想不到它的实际应用场景，可重入锁建立在锁的基础上，获得锁A的线程可以对锁A进行再次加锁而不会陷入死锁，但释放操作也需要相同次数，但是其他线程无法在锁住的情况下获得锁，同样对上面例子进行修改。还没找到一个很有说服力的需要加多次锁的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ...不变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(lock)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> count</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.0001</span>)</span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\">    count = temp</span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\"><span class=\"comment\"># ...不变</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Condition-条件\"><a href=\"#Condition-条件\" class=\"headerlink\" title=\"Condition 条件\"></a>Condition 条件</h3><p>条件也是建立在锁的基础上，在创建条件对象时可以传入一个锁或可重入锁，不传入参数则默认生成一个可重入锁。一些线程A等待条件而阻塞，一些线程B发出条件满足的信号，则等待的线程A可以继续运行。线程A首先acquire()加锁，在wait()处释放锁并阻塞，当其他线程发出条件满足信号，发出条件满足信号的方法有两个，一个是notify()，唤醒一个等待线程，另一个是notify_all()唤醒所有等待线程;A线程的wait()重新加锁并返回。经典的场景可能就是消费者和生产者模式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">(con)</span>:</span></span><br><span class=\"line\">    con.acquire()</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; is waiting'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    con.wait()</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; cousumes one time.'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    con.release()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">producer</span><span class=\"params\">(con)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'prodece and notify'</span>)</span><br><span class=\"line\">    con.acquire()</span><br><span class=\"line\">    con.notify_all()</span><br><span class=\"line\">    con.release()</span><br><span class=\"line\"></span><br><span class=\"line\">threads, condition = [], Condition()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">    t = Thread(target=consumer, args=(condition,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">produce = Thread(target=producer, args=(condition,))</span><br><span class=\"line\">produce.start()</span><br><span class=\"line\">produce.join()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\">print(<span class=\"string\">'end'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-4 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-5 is waiting</span></span><br><span class=\"line\"><span class=\"comment\"># prodece and notify</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-4 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-5 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 cousumes one time.</span></span><br><span class=\"line\"><span class=\"comment\"># end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Semaphore-信号量\"><a href=\"#Semaphore-信号量\" class=\"headerlink\" title=\"Semaphore 信号量\"></a>Semaphore 信号量</h3><p>方法与Lock()一样，但是可以在创建信号量时可以传入一个大于０的整数，当传入的整数为１时与Lock作用相同。信号量一般用于限制并发的数量，如连接数据库服务器时需要在连接数量控制在一定范围内。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">(sem)</span>:</span></span><br><span class=\"line\">    sem.acquire()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; is running'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    sem.release()</span><br><span class=\"line\"></span><br><span class=\"line\">threads, sem = [], Semaphore(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100</span>):</span><br><span class=\"line\">    t = Thread(target=hello, args=(sem,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br></pre></td></tr></table></figure>\n<p>可以在自己的电脑上运行一下，会看到print结果是5个5个的出现，sleep时间长点效果更明显。可以看到虽然开了100个线程，但是同时在运行只有5个。</p>\n<h3 id=\"Event-事件\"><a href=\"#Event-事件\" class=\"headerlink\" title=\"Event 事件\"></a>Event 事件</h3><p>一个线程标识一个事件，其他线程等待它。一个事件对象管理一个内部标志，这个标志可以用set()置为true,用clear()置为false。wait()方法会一直阻塞直到标志为true。这个看起来似乎跟条件有点像。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">(event)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; is waiting for an event.'</span>.format(threading.currentThread().name))</span><br><span class=\"line\">    event.wait()</span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; finish.'</span>.format(threading.currentThread().name))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">producer</span><span class=\"params\">(event)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'producer'</span>)</span><br><span class=\"line\">    event.set()</span><br><span class=\"line\"></span><br><span class=\"line\">threads, event = [], Event()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">    t = Thread(target=consumer, args=(event,))</span><br><span class=\"line\">    threads.append(t)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">produce = Thread(target=producer, args=(event,))</span><br><span class=\"line\">produce.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    t.join()</span><br><span class=\"line\">produce.join()</span><br><span class=\"line\">print(<span class=\"string\">'end'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 is waiting for an event.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 is waiting for an event.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 is waiting for an event.</span></span><br><span class=\"line\"><span class=\"comment\"># producer</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-2 finish.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-3 finish.</span></span><br><span class=\"line\"><span class=\"comment\"># Thread-1 finish.</span></span><br><span class=\"line\"><span class=\"comment\"># end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"上下文管理器\"><a href=\"#上下文管理器\" class=\"headerlink\" title=\"上下文管理器\"></a>上下文管理器</h3><p>上下文管理协议是Python的一个语法糖吧，用来方便资源的申请与释放。实现了上下文管理协议的类就可以用with语句包裹，简化代码的书写。具体实现查阅资料。</p>\n<p>上面介绍的那么多同步机制大多数都有一个申请锁和释放锁的步骤，可以用with语句简化这些操作，支持with语法的有lock, Rlock, conditions和semaphore.官网示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> some_lock:</span><br><span class=\"line\">    <span class=\"comment\"># do something</span></span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">some_lock.acquire()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># do something</span></span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    some_lock.release()</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果还有疑问，标准库是你最好的选择！刚开始看也许看不下去，有这么几个建议。</p>\n<ol>\n<li>看简短一点的模块</li>\n<li>积累专业词汇量</li>\n<li>找自己熟悉的模块入手，这样你就能大概的猜出它的意思</li>\n</ol>"},{"title":"Python装饰器(decorator)","date":"2018-05-29T11:10:09.000Z","_content":"装饰器语法是Python中一个很重要的语法，刚学Python时就有接触，但当时理解起来很困难，不过最近这一次学习装饰器的时候豁然开朗，可能是看的次数多了吧，于是记录下来，加深对装饰器的理解。\n\n装饰器是一种设计模式，我买了一本设计模式的书还没有开始看，关于设计模式这一块以后再讨论。\n\n装饰器是用于给一些已有的函数添加一些额外功能的，比如计时、日记、计数等等。这些功能其实也是可以在已有函数中直接实现的，但是为什么不这样做呢？大概有下面这些原因：\n\n1. 已有函数遍布整个项目，修改起来很麻烦，且容易出错\n2. 已有函数为第三方库，无法修改\n3. 需要添加的功能与函数本来的逻辑没有任何关系，将其添加进原函数不合适。\n\n\n<!--more-->\n## 装饰器基础\n\n理解装饰器首先要知道在Python中，函数也是一个对象。像String,List,tuple这些数据结构一样，可以作为其他函数的参数传递。\n\n```python\ndef test(func):\n    print('begin')\n    func()\n    print('after')\n\ndef func_a():\n    print(\"i'm func_a\")\n\ntest(func_a)\n# output:\n# begin\n# i'm func_a\n# after\n```\n\n其次需要知道的是函数也可以定义在另一个函数的内部并且可以被返回。\n\n```python\ndef test():\n    print('1111')\n    def inner():\n        print('22222')\n    return inner\n\na = test()\n# output: 1111 注意这时已经有输出了\na()\n# output: 2222\n```\n\n## decorator语法糖\n\n有了上面那些基础知识，我们已经有能力理解装饰器了。既然装饰器是语法糖，肯定是简化后的语法。那么他没化简之前是一个什么模样呢？\n\n```python\ndef decorator(a_func_to_decorator):\n    def wrapper():\n        # do something before func\n        print('begin------')\n        a_func_to_decorator()\n        # do something after func\n        print('after------')\n    return wrapper\n\ndef func_to_decorator():\n    print(\"chenfeikun zhen shuai\")\n\nfunc_to_decorator = decorator(func_to_decorator)\nfunc_to_decorator()\n# output:\n# begin------\n# chenfeikun zhen shuai\n# after------\n```\n\n上面这就是一个最简单的装饰器了，以后遇到每一个需要装饰的函数，只要将这个函数作为参数重新传入`decorator`函数就行。但是这样写不好看啊，所以Python就推出了一个更漂亮的写法。\n\n```python\ndef decorator(a_func_to_decorator):\n    # 如上\n\n@decorator\ndef func_to_decorator():\n    print(\"chenfeikun tai shuai le\")\n\nfunc_to_decorator()\n# output:\n# begin------\n# chenfeikun tai shuai le\n# after------\n```\n\n所以`@decorator`是对`func_to_decorator = decorator(func_to_decorator)`的一种简写，也就是语法糖。\n\n## 传递参数给被装饰的函数\n\n当然我们需要被装饰的函数一般不会这么简单，这个被装饰的函数可能是需要参数的，那么如何把这些参数原封不动的传递给被装饰的函数呢？因为被装饰函数已经作为最外层函数的参数，所以只能放在里层的`wrapper`函数里了。\n\n```python\ndef decorator(a_func_to_decorator):\n    def wrapper(a, b):\n        print('begin-----')\n        print(a_func_to_decorator(a, b))\n        print('after-----')\n    return wrapper\n\n@decorator\ndef add(c, d):\n    return c+d\n\nadd(5, 9)\n# output:\n# begin-----\n# 14\n# after-----\n```\n\n## 方法与函数\n\n上面我们提到的都是函数,如果类里的方法也需要装饰呢？其实方法和函数几乎是一样的，唯一的区别就是方法需要一个**self**参数。上面也提到了如何传参数，所以很容易就可以写出下面的方法装饰器。\n\n```python\ndef decorator(a_method_to_decorator):\n    def wrapper(self, name):\n        print('begin-----')\n        a_method_to_decorator(self, name)\n        print('after-----')\n    return wrapper\n\nclass Car(object):\n    @decorator\n    def talk(self, name):\n        print('Hi, {}. dududu~~~'.format(name))\n\naudi = Car()\naudi.talk('chenfeikun')\n# output:\n# begin-----\n# Hi, chenfeikun. dududu~~~\n# after-----\n```\n\n正因为函数和方法是如此的相似，我们有时侯可能想要写一个适用于两者的装饰器。那就别忘了Python还有一个重要的特性，它可以传递可变个数的参数，即`*args`和`**kwargs`，这两个参数的含义应该都知道，不知道的可以去看一下，很简单。所以我们又可以写出函数和方法通用的装饰器。\n\n```python\ndef decorator(something_to_decorator):\n    def wrapper(*args, **kwargs):\n        print('begin-----')\n        print('args: {}'.format(args))\n        print('kwargs: {}'.format(kwargs))\n        something_to_decorator(*args, **kwargs)\n        print('after-----')\n    return wrapper\n\nclass Car(object):\n    @decorator\n    def talk(self, *args, **kwargs):\n        print('talk-args: {}'.format(args))\n        print('talk-kwargs: {}'.format(kwargs))\n\n@decorator\ndef talk_2(name):\n    print('my name is {}'.format(name))\n\naudi = Car()\naudi.talk(1,2,3,a='a',b='b')\n# output:\n# begin-----\n# args: (<__main__.Car object at 0x7ff7c0e46240>, 1, 2, 3)\n# kwargs: {'b': 'b', 'a': 'a'}\n# talk-args: (1, 2, 3)\n# talk-kwargs: {'b': 'b', 'a': 'a'}\n# after-----\ntalk_2('chenfeikun')\n# output:\n# begin-----\n# args: ('chenfeikun',)\n# kwargs: {}\n# my name is chenfeikun\n# after-----\n```\n\n## 传递参数给装饰器\n\n如果想向外层的那个`decorator`函数传递参数呢，这能不能做到呢？当然是可以的，不过外层的`decorator`函数和内层的`wrapper`函数的参数都已经被上面提到的功能使用了，哪里还有位置放置新的参数呢？\n\n这其实和装饰器的概念理解起来是一样的，`decorator`函数可以返回一个`wrapper`函数，那么我们可以用一个更外层的函数**A**(不会取名字了，将就一下)来包住`decorator`函数，并将其返回，**A**函数的作用就是返回/生成一个装饰器，那么就可以给**A**传递一些参数来控制如何装饰器，多说无益，代码可能看着简单一些。\n\n```python\ndef A(choose):\n    def decorator_a(a_func_to_decorator):\n        def wrapper():\n            print('decorator_A---begin')\n            a_func_to_decorator()\n            print('decorator_A---after')\n        return wrapper\n\n    def decorator_b(a_func_to_decorator):\n        def wrapper():\n            print('decorator_B---begin')\n            a_func_to_decorator()\n            print('decorator_B---after')\n        return wrapper\n\n    if choose == 'a':\n        return decorator_a\n    return decorator_b\n\ntype_a = A('a')\n@type_a\ndef talk_1():\n    print('talk_1---dududududu~~~~~')\n\n@A('b')\ndef talk_2():\n    print('talk_2---dududududu~~~~~')\ntalk_1()\n# output:\n# decorator_A---begin\n# talk_1---dududududu~~~~~\n# decorator_A---after\ntalk_2()\n# output:\n# decorator_B---begin\n# talk_2---dududududu~~~~~\n# decorator_B---after\n```\n\n对比一下上面**talk_1**和**talk_2**的写法，其实是一样的，但是后面一种更加简单，更符合装饰器的形式。\n\n## functools模块\n\n上面的装饰器还有一个毛病，最后一个代码中的`talk_2`函数其实已经不是原来的`talk_2`函数了，因为装饰器的最初样子为\n```python\ntalk_2 = decorator(talk_2)\n```\n相当于talk_2指向了另外一个对象，这个对象是decorator返回的wrapper，原来与**talk2**绑定的一些属性就会被修改。而**functools**模块就是帮助我们不让这些东西被修改，下面举个例子。\n\n```python\ndef test():\n    pass\n\nprint(test.__name__)\n# output:\n# test\ndef decorator(func):\n    def wrapper():\n        func()\n    return wrapper\n\n@decorator\ndef test():\n    pass\n\nprint(test.__name__)\n# output:\n# wrapper\n```\n\n可以看到函数的__name__属性被修改了，但是用了functools模块可以解决这个问题。\n\n```python\nimport functools\ndef decorator(func):\n    @functools.wraps(func)\n    def wrapper():\n        func()\n    return wrapper\n\n@decorator\ndef test():\n    pass\n\nprint(test.__name__)\n# output:\n# test\n```\n\n## 参考资料\n\n[stackoverflow](https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators)","source":"_posts/Python装饰器-decorator.md","raw":"---\ntitle: Python装饰器(decorator)\ndate: 2018-05-29 19:10:09\ntags:\n    - Python\n---\n装饰器语法是Python中一个很重要的语法，刚学Python时就有接触，但当时理解起来很困难，不过最近这一次学习装饰器的时候豁然开朗，可能是看的次数多了吧，于是记录下来，加深对装饰器的理解。\n\n装饰器是一种设计模式，我买了一本设计模式的书还没有开始看，关于设计模式这一块以后再讨论。\n\n装饰器是用于给一些已有的函数添加一些额外功能的，比如计时、日记、计数等等。这些功能其实也是可以在已有函数中直接实现的，但是为什么不这样做呢？大概有下面这些原因：\n\n1. 已有函数遍布整个项目，修改起来很麻烦，且容易出错\n2. 已有函数为第三方库，无法修改\n3. 需要添加的功能与函数本来的逻辑没有任何关系，将其添加进原函数不合适。\n\n\n<!--more-->\n## 装饰器基础\n\n理解装饰器首先要知道在Python中，函数也是一个对象。像String,List,tuple这些数据结构一样，可以作为其他函数的参数传递。\n\n```python\ndef test(func):\n    print('begin')\n    func()\n    print('after')\n\ndef func_a():\n    print(\"i'm func_a\")\n\ntest(func_a)\n# output:\n# begin\n# i'm func_a\n# after\n```\n\n其次需要知道的是函数也可以定义在另一个函数的内部并且可以被返回。\n\n```python\ndef test():\n    print('1111')\n    def inner():\n        print('22222')\n    return inner\n\na = test()\n# output: 1111 注意这时已经有输出了\na()\n# output: 2222\n```\n\n## decorator语法糖\n\n有了上面那些基础知识，我们已经有能力理解装饰器了。既然装饰器是语法糖，肯定是简化后的语法。那么他没化简之前是一个什么模样呢？\n\n```python\ndef decorator(a_func_to_decorator):\n    def wrapper():\n        # do something before func\n        print('begin------')\n        a_func_to_decorator()\n        # do something after func\n        print('after------')\n    return wrapper\n\ndef func_to_decorator():\n    print(\"chenfeikun zhen shuai\")\n\nfunc_to_decorator = decorator(func_to_decorator)\nfunc_to_decorator()\n# output:\n# begin------\n# chenfeikun zhen shuai\n# after------\n```\n\n上面这就是一个最简单的装饰器了，以后遇到每一个需要装饰的函数，只要将这个函数作为参数重新传入`decorator`函数就行。但是这样写不好看啊，所以Python就推出了一个更漂亮的写法。\n\n```python\ndef decorator(a_func_to_decorator):\n    # 如上\n\n@decorator\ndef func_to_decorator():\n    print(\"chenfeikun tai shuai le\")\n\nfunc_to_decorator()\n# output:\n# begin------\n# chenfeikun tai shuai le\n# after------\n```\n\n所以`@decorator`是对`func_to_decorator = decorator(func_to_decorator)`的一种简写，也就是语法糖。\n\n## 传递参数给被装饰的函数\n\n当然我们需要被装饰的函数一般不会这么简单，这个被装饰的函数可能是需要参数的，那么如何把这些参数原封不动的传递给被装饰的函数呢？因为被装饰函数已经作为最外层函数的参数，所以只能放在里层的`wrapper`函数里了。\n\n```python\ndef decorator(a_func_to_decorator):\n    def wrapper(a, b):\n        print('begin-----')\n        print(a_func_to_decorator(a, b))\n        print('after-----')\n    return wrapper\n\n@decorator\ndef add(c, d):\n    return c+d\n\nadd(5, 9)\n# output:\n# begin-----\n# 14\n# after-----\n```\n\n## 方法与函数\n\n上面我们提到的都是函数,如果类里的方法也需要装饰呢？其实方法和函数几乎是一样的，唯一的区别就是方法需要一个**self**参数。上面也提到了如何传参数，所以很容易就可以写出下面的方法装饰器。\n\n```python\ndef decorator(a_method_to_decorator):\n    def wrapper(self, name):\n        print('begin-----')\n        a_method_to_decorator(self, name)\n        print('after-----')\n    return wrapper\n\nclass Car(object):\n    @decorator\n    def talk(self, name):\n        print('Hi, {}. dududu~~~'.format(name))\n\naudi = Car()\naudi.talk('chenfeikun')\n# output:\n# begin-----\n# Hi, chenfeikun. dududu~~~\n# after-----\n```\n\n正因为函数和方法是如此的相似，我们有时侯可能想要写一个适用于两者的装饰器。那就别忘了Python还有一个重要的特性，它可以传递可变个数的参数，即`*args`和`**kwargs`，这两个参数的含义应该都知道，不知道的可以去看一下，很简单。所以我们又可以写出函数和方法通用的装饰器。\n\n```python\ndef decorator(something_to_decorator):\n    def wrapper(*args, **kwargs):\n        print('begin-----')\n        print('args: {}'.format(args))\n        print('kwargs: {}'.format(kwargs))\n        something_to_decorator(*args, **kwargs)\n        print('after-----')\n    return wrapper\n\nclass Car(object):\n    @decorator\n    def talk(self, *args, **kwargs):\n        print('talk-args: {}'.format(args))\n        print('talk-kwargs: {}'.format(kwargs))\n\n@decorator\ndef talk_2(name):\n    print('my name is {}'.format(name))\n\naudi = Car()\naudi.talk(1,2,3,a='a',b='b')\n# output:\n# begin-----\n# args: (<__main__.Car object at 0x7ff7c0e46240>, 1, 2, 3)\n# kwargs: {'b': 'b', 'a': 'a'}\n# talk-args: (1, 2, 3)\n# talk-kwargs: {'b': 'b', 'a': 'a'}\n# after-----\ntalk_2('chenfeikun')\n# output:\n# begin-----\n# args: ('chenfeikun',)\n# kwargs: {}\n# my name is chenfeikun\n# after-----\n```\n\n## 传递参数给装饰器\n\n如果想向外层的那个`decorator`函数传递参数呢，这能不能做到呢？当然是可以的，不过外层的`decorator`函数和内层的`wrapper`函数的参数都已经被上面提到的功能使用了，哪里还有位置放置新的参数呢？\n\n这其实和装饰器的概念理解起来是一样的，`decorator`函数可以返回一个`wrapper`函数，那么我们可以用一个更外层的函数**A**(不会取名字了，将就一下)来包住`decorator`函数，并将其返回，**A**函数的作用就是返回/生成一个装饰器，那么就可以给**A**传递一些参数来控制如何装饰器，多说无益，代码可能看着简单一些。\n\n```python\ndef A(choose):\n    def decorator_a(a_func_to_decorator):\n        def wrapper():\n            print('decorator_A---begin')\n            a_func_to_decorator()\n            print('decorator_A---after')\n        return wrapper\n\n    def decorator_b(a_func_to_decorator):\n        def wrapper():\n            print('decorator_B---begin')\n            a_func_to_decorator()\n            print('decorator_B---after')\n        return wrapper\n\n    if choose == 'a':\n        return decorator_a\n    return decorator_b\n\ntype_a = A('a')\n@type_a\ndef talk_1():\n    print('talk_1---dududududu~~~~~')\n\n@A('b')\ndef talk_2():\n    print('talk_2---dududududu~~~~~')\ntalk_1()\n# output:\n# decorator_A---begin\n# talk_1---dududududu~~~~~\n# decorator_A---after\ntalk_2()\n# output:\n# decorator_B---begin\n# talk_2---dududududu~~~~~\n# decorator_B---after\n```\n\n对比一下上面**talk_1**和**talk_2**的写法，其实是一样的，但是后面一种更加简单，更符合装饰器的形式。\n\n## functools模块\n\n上面的装饰器还有一个毛病，最后一个代码中的`talk_2`函数其实已经不是原来的`talk_2`函数了，因为装饰器的最初样子为\n```python\ntalk_2 = decorator(talk_2)\n```\n相当于talk_2指向了另外一个对象，这个对象是decorator返回的wrapper，原来与**talk2**绑定的一些属性就会被修改。而**functools**模块就是帮助我们不让这些东西被修改，下面举个例子。\n\n```python\ndef test():\n    pass\n\nprint(test.__name__)\n# output:\n# test\ndef decorator(func):\n    def wrapper():\n        func()\n    return wrapper\n\n@decorator\ndef test():\n    pass\n\nprint(test.__name__)\n# output:\n# wrapper\n```\n\n可以看到函数的__name__属性被修改了，但是用了functools模块可以解决这个问题。\n\n```python\nimport functools\ndef decorator(func):\n    @functools.wraps(func)\n    def wrapper():\n        func()\n    return wrapper\n\n@decorator\ndef test():\n    pass\n\nprint(test.__name__)\n# output:\n# test\n```\n\n## 参考资料\n\n[stackoverflow](https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators)","slug":"Python装饰器-decorator","published":1,"updated":"2019-02-03T07:16:46.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkll7000fuetunmcfl37y","content":"<p>装饰器语法是Python中一个很重要的语法，刚学Python时就有接触，但当时理解起来很困难，不过最近这一次学习装饰器的时候豁然开朗，可能是看的次数多了吧，于是记录下来，加深对装饰器的理解。</p>\n<p>装饰器是一种设计模式，我买了一本设计模式的书还没有开始看，关于设计模式这一块以后再讨论。</p>\n<p>装饰器是用于给一些已有的函数添加一些额外功能的，比如计时、日记、计数等等。这些功能其实也是可以在已有函数中直接实现的，但是为什么不这样做呢？大概有下面这些原因：</p>\n<ol>\n<li>已有函数遍布整个项目，修改起来很麻烦，且容易出错</li>\n<li>已有函数为第三方库，无法修改</li>\n<li>需要添加的功能与函数本来的逻辑没有任何关系，将其添加进原函数不合适。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"装饰器基础\"><a href=\"#装饰器基础\" class=\"headerlink\" title=\"装饰器基础\"></a>装饰器基础</h2><p>理解装饰器首先要知道在Python中，函数也是一个对象。像String,List,tuple这些数据结构一样，可以作为其他函数的参数传递。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'begin'</span>)</span><br><span class=\"line\">    func()</span><br><span class=\"line\">    print(<span class=\"string\">'after'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_a</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"i'm func_a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">test(func_a)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin</span></span><br><span class=\"line\"><span class=\"comment\"># i'm func_a</span></span><br><span class=\"line\"><span class=\"comment\"># after</span></span><br></pre></td></tr></table></figure>\n<p>其次需要知道的是函数也可以定义在另一个函数的内部并且可以被返回。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'1111'</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'22222'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\">a = test()</span><br><span class=\"line\"><span class=\"comment\"># output: 1111 注意这时已经有输出了</span></span><br><span class=\"line\">a()</span><br><span class=\"line\"><span class=\"comment\"># output: 2222</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"decorator语法糖\"><a href=\"#decorator语法糖\" class=\"headerlink\" title=\"decorator语法糖\"></a>decorator语法糖</h2><p>有了上面那些基础知识，我们已经有能力理解装饰器了。既然装饰器是语法糖，肯定是简化后的语法。那么他没化简之前是一个什么模样呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># do something before func</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin------'</span>)</span><br><span class=\"line\">        a_func_to_decorator()</span><br><span class=\"line\">        <span class=\"comment\"># do something after func</span></span><br><span class=\"line\">        print(<span class=\"string\">'after------'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_to_decorator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"chenfeikun zhen shuai\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">func_to_decorator = decorator(func_to_decorator)</span><br><span class=\"line\">func_to_decorator()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin------</span></span><br><span class=\"line\"><span class=\"comment\"># chenfeikun zhen shuai</span></span><br><span class=\"line\"><span class=\"comment\"># after------</span></span><br></pre></td></tr></table></figure>\n<p>上面这就是一个最简单的装饰器了，以后遇到每一个需要装饰的函数，只要将这个函数作为参数重新传入<code>decorator</code>函数就行。但是这样写不好看啊，所以Python就推出了一个更漂亮的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 如上</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_to_decorator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"chenfeikun tai shuai le\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">func_to_decorator()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin------</span></span><br><span class=\"line\"><span class=\"comment\"># chenfeikun tai shuai le</span></span><br><span class=\"line\"><span class=\"comment\"># after------</span></span><br></pre></td></tr></table></figure>\n<p>所以<code>@decorator</code>是对<code>func_to_decorator = decorator(func_to_decorator)</code>的一种简写，也就是语法糖。</p>\n<h2 id=\"传递参数给被装饰的函数\"><a href=\"#传递参数给被装饰的函数\" class=\"headerlink\" title=\"传递参数给被装饰的函数\"></a>传递参数给被装饰的函数</h2><p>当然我们需要被装饰的函数一般不会这么简单，这个被装饰的函数可能是需要参数的，那么如何把这些参数原封不动的传递给被装饰的函数呢？因为被装饰函数已经作为最外层函数的参数，所以只能放在里层的<code>wrapper</code>函数里了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin-----'</span>)</span><br><span class=\"line\">        print(a_func_to_decorator(a, b))</span><br><span class=\"line\">        print(<span class=\"string\">'after-----'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(c, d)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c+d</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">5</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># 14</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"方法与函数\"><a href=\"#方法与函数\" class=\"headerlink\" title=\"方法与函数\"></a>方法与函数</h2><p>上面我们提到的都是函数,如果类里的方法也需要装饰呢？其实方法和函数几乎是一样的，唯一的区别就是方法需要一个<strong>self</strong>参数。上面也提到了如何传参数，所以很容易就可以写出下面的方法装饰器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_method_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin-----'</span>)</span><br><span class=\"line\">        a_method_to_decorator(self, name)</span><br><span class=\"line\">        print(<span class=\"string\">'after-----'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @decorator</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Hi, &#123;&#125;. dududu~~~'</span>.format(name))</span><br><span class=\"line\"></span><br><span class=\"line\">audi = Car()</span><br><span class=\"line\">audi.talk(<span class=\"string\">'chenfeikun'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># Hi, chenfeikun. dududu~~~</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br></pre></td></tr></table></figure>\n<p>正因为函数和方法是如此的相似，我们有时侯可能想要写一个适用于两者的装饰器。那就别忘了Python还有一个重要的特性，它可以传递可变个数的参数，即<code>*args</code>和<code>**kwargs</code>，这两个参数的含义应该都知道，不知道的可以去看一下，很简单。所以我们又可以写出函数和方法通用的装饰器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(something_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin-----'</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'args: &#123;&#125;'</span>.format(args))</span><br><span class=\"line\">        print(<span class=\"string\">'kwargs: &#123;&#125;'</span>.format(kwargs))</span><br><span class=\"line\">        something_to_decorator(*args, **kwargs)</span><br><span class=\"line\">        print(<span class=\"string\">'after-----'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @decorator</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'talk-args: &#123;&#125;'</span>.format(args))</span><br><span class=\"line\">        print(<span class=\"string\">'talk-kwargs: &#123;&#125;'</span>.format(kwargs))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk_2</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'my name is &#123;&#125;'</span>.format(name))</span><br><span class=\"line\"></span><br><span class=\"line\">audi = Car()</span><br><span class=\"line\">audi.talk(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,a=<span class=\"string\">'a'</span>,b=<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># args: (&lt;__main__.Car object at 0x7ff7c0e46240&gt;, 1, 2, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># kwargs: &#123;'b': 'b', 'a': 'a'&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># talk-args: (1, 2, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># talk-kwargs: &#123;'b': 'b', 'a': 'a'&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br><span class=\"line\">talk_2(<span class=\"string\">'chenfeikun'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># args: ('chenfeikun',)</span></span><br><span class=\"line\"><span class=\"comment\"># kwargs: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># my name is chenfeikun</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"传递参数给装饰器\"><a href=\"#传递参数给装饰器\" class=\"headerlink\" title=\"传递参数给装饰器\"></a>传递参数给装饰器</h2><p>如果想向外层的那个<code>decorator</code>函数传递参数呢，这能不能做到呢？当然是可以的，不过外层的<code>decorator</code>函数和内层的<code>wrapper</code>函数的参数都已经被上面提到的功能使用了，哪里还有位置放置新的参数呢？</p>\n<p>这其实和装饰器的概念理解起来是一样的，<code>decorator</code>函数可以返回一个<code>wrapper</code>函数，那么我们可以用一个更外层的函数<strong>A</strong>(不会取名字了，将就一下)来包住<code>decorator</code>函数，并将其返回，<strong>A</strong>函数的作用就是返回/生成一个装饰器，那么就可以给<strong>A</strong>传递一些参数来控制如何装饰器，多说无益，代码可能看着简单一些。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">A</span><span class=\"params\">(choose)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator_a</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'decorator_A---begin'</span>)</span><br><span class=\"line\">            a_func_to_decorator()</span><br><span class=\"line\">            print(<span class=\"string\">'decorator_A---after'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator_b</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'decorator_B---begin'</span>)</span><br><span class=\"line\">            a_func_to_decorator()</span><br><span class=\"line\">            print(<span class=\"string\">'decorator_B---after'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> choose == <span class=\"string\">'a'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decorator_a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator_b</span><br><span class=\"line\"></span><br><span class=\"line\">type_a = A(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"meta\">@type_a</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk_1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'talk_1---dududududu~~~~~'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@A('b')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk_2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'talk_2---dududududu~~~~~'</span>)</span><br><span class=\"line\">talk_1()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_A---begin</span></span><br><span class=\"line\"><span class=\"comment\"># talk_1---dududududu~~~~~</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_A---after</span></span><br><span class=\"line\">talk_2()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_B---begin</span></span><br><span class=\"line\"><span class=\"comment\"># talk_2---dududududu~~~~~</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_B---after</span></span><br></pre></td></tr></table></figure>\n<p>对比一下上面<strong>talk_1</strong>和<strong>talk_2</strong>的写法，其实是一样的，但是后面一种更加简单，更符合装饰器的形式。</p>\n<h2 id=\"functools模块\"><a href=\"#functools模块\" class=\"headerlink\" title=\"functools模块\"></a>functools模块</h2><p>上面的装饰器还有一个毛病，最后一个代码中的<code>talk_2</code>函数其实已经不是原来的<code>talk_2</code>函数了，因为装饰器的最初样子为<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">talk_2 = decorator(talk_2)</span><br></pre></td></tr></table></figure></p>\n<p>相当于talk_2指向了另外一个对象，这个对象是decorator返回的wrapper，原来与<strong>talk2</strong>绑定的一些属性就会被修改。而<strong>functools</strong>模块就是帮助我们不让这些东西被修改，下面举个例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(test.__name__)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(test.__name__)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># wrapper</span></span><br></pre></td></tr></table></figure>\n<p>可以看到函数的<strong>name</strong>属性被修改了，但是用了functools模块可以解决这个问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(test.__name__)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># test</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></p>\n","site":{"data":{}},"excerpt":"<p>装饰器语法是Python中一个很重要的语法，刚学Python时就有接触，但当时理解起来很困难，不过最近这一次学习装饰器的时候豁然开朗，可能是看的次数多了吧，于是记录下来，加深对装饰器的理解。</p>\n<p>装饰器是一种设计模式，我买了一本设计模式的书还没有开始看，关于设计模式这一块以后再讨论。</p>\n<p>装饰器是用于给一些已有的函数添加一些额外功能的，比如计时、日记、计数等等。这些功能其实也是可以在已有函数中直接实现的，但是为什么不这样做呢？大概有下面这些原因：</p>\n<ol>\n<li>已有函数遍布整个项目，修改起来很麻烦，且容易出错</li>\n<li>已有函数为第三方库，无法修改</li>\n<li>需要添加的功能与函数本来的逻辑没有任何关系，将其添加进原函数不合适。</li>\n</ol>","more":"<h2 id=\"装饰器基础\"><a href=\"#装饰器基础\" class=\"headerlink\" title=\"装饰器基础\"></a>装饰器基础</h2><p>理解装饰器首先要知道在Python中，函数也是一个对象。像String,List,tuple这些数据结构一样，可以作为其他函数的参数传递。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'begin'</span>)</span><br><span class=\"line\">    func()</span><br><span class=\"line\">    print(<span class=\"string\">'after'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_a</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"i'm func_a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">test(func_a)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin</span></span><br><span class=\"line\"><span class=\"comment\"># i'm func_a</span></span><br><span class=\"line\"><span class=\"comment\"># after</span></span><br></pre></td></tr></table></figure>\n<p>其次需要知道的是函数也可以定义在另一个函数的内部并且可以被返回。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'1111'</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'22222'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\">a = test()</span><br><span class=\"line\"><span class=\"comment\"># output: 1111 注意这时已经有输出了</span></span><br><span class=\"line\">a()</span><br><span class=\"line\"><span class=\"comment\"># output: 2222</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"decorator语法糖\"><a href=\"#decorator语法糖\" class=\"headerlink\" title=\"decorator语法糖\"></a>decorator语法糖</h2><p>有了上面那些基础知识，我们已经有能力理解装饰器了。既然装饰器是语法糖，肯定是简化后的语法。那么他没化简之前是一个什么模样呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># do something before func</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin------'</span>)</span><br><span class=\"line\">        a_func_to_decorator()</span><br><span class=\"line\">        <span class=\"comment\"># do something after func</span></span><br><span class=\"line\">        print(<span class=\"string\">'after------'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_to_decorator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"chenfeikun zhen shuai\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">func_to_decorator = decorator(func_to_decorator)</span><br><span class=\"line\">func_to_decorator()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin------</span></span><br><span class=\"line\"><span class=\"comment\"># chenfeikun zhen shuai</span></span><br><span class=\"line\"><span class=\"comment\"># after------</span></span><br></pre></td></tr></table></figure>\n<p>上面这就是一个最简单的装饰器了，以后遇到每一个需要装饰的函数，只要将这个函数作为参数重新传入<code>decorator</code>函数就行。但是这样写不好看啊，所以Python就推出了一个更漂亮的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 如上</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_to_decorator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"chenfeikun tai shuai le\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">func_to_decorator()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin------</span></span><br><span class=\"line\"><span class=\"comment\"># chenfeikun tai shuai le</span></span><br><span class=\"line\"><span class=\"comment\"># after------</span></span><br></pre></td></tr></table></figure>\n<p>所以<code>@decorator</code>是对<code>func_to_decorator = decorator(func_to_decorator)</code>的一种简写，也就是语法糖。</p>\n<h2 id=\"传递参数给被装饰的函数\"><a href=\"#传递参数给被装饰的函数\" class=\"headerlink\" title=\"传递参数给被装饰的函数\"></a>传递参数给被装饰的函数</h2><p>当然我们需要被装饰的函数一般不会这么简单，这个被装饰的函数可能是需要参数的，那么如何把这些参数原封不动的传递给被装饰的函数呢？因为被装饰函数已经作为最外层函数的参数，所以只能放在里层的<code>wrapper</code>函数里了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin-----'</span>)</span><br><span class=\"line\">        print(a_func_to_decorator(a, b))</span><br><span class=\"line\">        print(<span class=\"string\">'after-----'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(c, d)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c+d</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">5</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># 14</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"方法与函数\"><a href=\"#方法与函数\" class=\"headerlink\" title=\"方法与函数\"></a>方法与函数</h2><p>上面我们提到的都是函数,如果类里的方法也需要装饰呢？其实方法和函数几乎是一样的，唯一的区别就是方法需要一个<strong>self</strong>参数。上面也提到了如何传参数，所以很容易就可以写出下面的方法装饰器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(a_method_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin-----'</span>)</span><br><span class=\"line\">        a_method_to_decorator(self, name)</span><br><span class=\"line\">        print(<span class=\"string\">'after-----'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @decorator</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Hi, &#123;&#125;. dududu~~~'</span>.format(name))</span><br><span class=\"line\"></span><br><span class=\"line\">audi = Car()</span><br><span class=\"line\">audi.talk(<span class=\"string\">'chenfeikun'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># Hi, chenfeikun. dududu~~~</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br></pre></td></tr></table></figure>\n<p>正因为函数和方法是如此的相似，我们有时侯可能想要写一个适用于两者的装饰器。那就别忘了Python还有一个重要的特性，它可以传递可变个数的参数，即<code>*args</code>和<code>**kwargs</code>，这两个参数的含义应该都知道，不知道的可以去看一下，很简单。所以我们又可以写出函数和方法通用的装饰器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(something_to_decorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'begin-----'</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'args: &#123;&#125;'</span>.format(args))</span><br><span class=\"line\">        print(<span class=\"string\">'kwargs: &#123;&#125;'</span>.format(kwargs))</span><br><span class=\"line\">        something_to_decorator(*args, **kwargs)</span><br><span class=\"line\">        print(<span class=\"string\">'after-----'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @decorator</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'talk-args: &#123;&#125;'</span>.format(args))</span><br><span class=\"line\">        print(<span class=\"string\">'talk-kwargs: &#123;&#125;'</span>.format(kwargs))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk_2</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'my name is &#123;&#125;'</span>.format(name))</span><br><span class=\"line\"></span><br><span class=\"line\">audi = Car()</span><br><span class=\"line\">audi.talk(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,a=<span class=\"string\">'a'</span>,b=<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># args: (&lt;__main__.Car object at 0x7ff7c0e46240&gt;, 1, 2, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># kwargs: &#123;'b': 'b', 'a': 'a'&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># talk-args: (1, 2, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># talk-kwargs: &#123;'b': 'b', 'a': 'a'&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br><span class=\"line\">talk_2(<span class=\"string\">'chenfeikun'</span>)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># begin-----</span></span><br><span class=\"line\"><span class=\"comment\"># args: ('chenfeikun',)</span></span><br><span class=\"line\"><span class=\"comment\"># kwargs: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># my name is chenfeikun</span></span><br><span class=\"line\"><span class=\"comment\"># after-----</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"传递参数给装饰器\"><a href=\"#传递参数给装饰器\" class=\"headerlink\" title=\"传递参数给装饰器\"></a>传递参数给装饰器</h2><p>如果想向外层的那个<code>decorator</code>函数传递参数呢，这能不能做到呢？当然是可以的，不过外层的<code>decorator</code>函数和内层的<code>wrapper</code>函数的参数都已经被上面提到的功能使用了，哪里还有位置放置新的参数呢？</p>\n<p>这其实和装饰器的概念理解起来是一样的，<code>decorator</code>函数可以返回一个<code>wrapper</code>函数，那么我们可以用一个更外层的函数<strong>A</strong>(不会取名字了，将就一下)来包住<code>decorator</code>函数，并将其返回，<strong>A</strong>函数的作用就是返回/生成一个装饰器，那么就可以给<strong>A</strong>传递一些参数来控制如何装饰器，多说无益，代码可能看着简单一些。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">A</span><span class=\"params\">(choose)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator_a</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'decorator_A---begin'</span>)</span><br><span class=\"line\">            a_func_to_decorator()</span><br><span class=\"line\">            print(<span class=\"string\">'decorator_A---after'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator_b</span><span class=\"params\">(a_func_to_decorator)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'decorator_B---begin'</span>)</span><br><span class=\"line\">            a_func_to_decorator()</span><br><span class=\"line\">            print(<span class=\"string\">'decorator_B---after'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> choose == <span class=\"string\">'a'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decorator_a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator_b</span><br><span class=\"line\"></span><br><span class=\"line\">type_a = A(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"meta\">@type_a</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk_1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'talk_1---dududududu~~~~~'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@A('b')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk_2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'talk_2---dududududu~~~~~'</span>)</span><br><span class=\"line\">talk_1()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_A---begin</span></span><br><span class=\"line\"><span class=\"comment\"># talk_1---dududududu~~~~~</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_A---after</span></span><br><span class=\"line\">talk_2()</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_B---begin</span></span><br><span class=\"line\"><span class=\"comment\"># talk_2---dududududu~~~~~</span></span><br><span class=\"line\"><span class=\"comment\"># decorator_B---after</span></span><br></pre></td></tr></table></figure>\n<p>对比一下上面<strong>talk_1</strong>和<strong>talk_2</strong>的写法，其实是一样的，但是后面一种更加简单，更符合装饰器的形式。</p>\n<h2 id=\"functools模块\"><a href=\"#functools模块\" class=\"headerlink\" title=\"functools模块\"></a>functools模块</h2><p>上面的装饰器还有一个毛病，最后一个代码中的<code>talk_2</code>函数其实已经不是原来的<code>talk_2</code>函数了，因为装饰器的最初样子为<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">talk_2 = decorator(talk_2)</span><br></pre></td></tr></table></figure></p>\n<p>相当于talk_2指向了另外一个对象，这个对象是decorator返回的wrapper，原来与<strong>talk2</strong>绑定的一些属性就会被修改。而<strong>functools</strong>模块就是帮助我们不让这些东西被修改，下面举个例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(test.__name__)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(test.__name__)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># wrapper</span></span><br></pre></td></tr></table></figure>\n<p>可以看到函数的<strong>name</strong>属性被修改了，但是用了functools模块可以解决这个问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(test.__name__)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># test</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></p>"},{"title":"再见，2018","date":"2019-01-01T03:46:06.000Z","_content":"\n前段时间忙着秋招和实习，\b好久没有更新博客了。在这辞旧迎新的一天，总结一下过去的2018，展望2019，立一些`flag`。同时作为\b新开公众号的第一篇文章，欢迎关注！（Technique and Life)\n\n## 2018\n\n### 校招:Python Vs Java\n\n简单介绍下背景，垫底985计算机本科。2018上半年是大四上学期，忙着春招找实习，python出身的我找实习屡屡碰壁，大厂的职位还是以Java和Cpp为主，即使说着`应届生不看重语言`，面试确总想着问Java基础，不会的话，\b面试是很难通过的。因为大多数科班出身的，计算机相关的基础知识都是比较扎实的，那么同等情况一个合适技术栈的应届生显然更加具有吸引力。\b好在还有一个`头条`招Python岗位的后台开发，运气不错，最终拿到实习Offer。\n\n<!--more-->\n\n找实习之前我就在纠结Python和Java如何选，但是一直用Python的我，对短短几个月转型Java是惧怕的，导致我迟迟没有动手。其次我信了**应届生不看重语言，更注重基础的邪**。于是我把时间都用来学习和复习计算机基础，比如网络，数据库之类的。就从面试情况来看，真的是非常吃亏，投递简历是会发现没有合适的岗位，大多数都写着需要扎实的Java基础，而面试官大多数也都是Java的技术栈，你想让他问别的，他可能也不了解，那面试可谈的东西大大减少，通过的几率就降低了。\n\n网上都流传着，语言不是重点，解决问题的能力才是。但是我觉得大多数人不到那个境界吧，而且公司的项目是有技术包袱的，如果不是新的项目，彻底放弃原来的技术栈，选用新的技术栈是有很大成本的，且公司的老人更加的不愿意变换语言。\b因此，掌握主流的技术还是必要的，大牛例外。主流意味着\b更多的机会，更多的学习资料、社区等，目前来看cpp和Java依然是后台开发的主流，python和Go的话也有市场，但是体量不如前两种语言大。\n\n### 头条实习之旅\n\n前面提到了，我投递的头条的Python后台开发岗位，很不巧的是我\b被分配到了基础设施部门，除了脚本用Python，其他几乎都是Java和Cpp,在用Python滑水两个月后，开始转型Java，这时候真正的意识到了危机，因为实习面试已经受挫，秋招如果继续找Python很可能找不到。\b这段时间也许是因为压力比较大，学的比较认真，很多东西学起来更快了，更容易了，很快就能用Java照着之前的代码，写点小的需求了。就这样一边学习，一边做点需求，但是由于半路出家，技术栈与部门差太多，最终没能转正，秋招也完美错过，当时真的压力很大，开始疯狂的投递补招和重新复习基础知识，晚上也经常失眠，所幸最后找到了BAT其中的一个开发offer,即使有\b不满意的地方，但也是可以接受的。（头条里我的导师还是不错的，让我一边实习一边找工作，也想要在我找工作的时候帮助我，但是我知道主要还是得靠自己的实力，所以并没有让他帮我，不过非常感谢！）\n\n截止到今天，已经实习了半年了，还将继续实习一个月吧，谈谈我的收获和感受。首先说说对头条的看法吧，正如大家都知道的，除了加班多，其他的各方面真的是非常完美了。尤其是包三餐，对独自在外的应届生来说是非常有吸引力的，部门的话可能差距就比较大了，就我所在的部门来说，同事还是非常nice的，也感觉到他们的技术非常强（可能是我菜- -！），虽然没能转正，但是还是很感谢他们。\n\n程序员还是要注重技术的积累，闲事少谈，下面就来谈谈实习对技术成长的帮助吧。实习是第一次从学校到职场的跨越，是第一次把所学运用到实际的过程，会发现很多的不足，受限于技术与眼界。下面列几个想到的点：\n\n#### 规范、合作\n\n首先是合作与规范的问题，公司的项目一般来说都比较大，需要多人合作，\b那么如何\b合作就成为一个问题，需要与同事正确沟通，确认需求和方案的可行性，需要熟练掌握git操作...之前一直没搞懂的git命令就这样被逼着学会了。其次是规范的问题，公司的项目必须有严格的流程，本地测试->review->合并分支->测试->上线...等一系列步骤，而我之前在学校的实验室时，这些操作几乎没有，只有拷贝到服务器，然后运行，出了问题再解决。但是公司的项目上线后必须保证正确性，不然有重大损失，所以一些必要的开发流程规范是需要遵守的。\n\n#### 规模、技术栈、系统设计\n\n\b也许因为我呆的是基础设施部门吧，小组做的项目体量非常大，服务器数量多，依赖的其他服务多，设计到的技术也非常多，我刚接触时一脸茫然。但是就是参与这个项目让我学到了很多，其中最重要的就要数系统设计了，了解了一个大型项目的整体框架，对一些典型的场景的宏观解决方案有一些认识（面试时还挺有用），如何解藕，并行，分布式等等...但是具体实现的话还是有非常大的难度，因为设计到的技术非常多，数据库就包含4种，还有各种中间件等，花了很长时间才了解了下这些东西的作用，但是更细致的暂时没有时间和能力去了解，不过我觉得也受益匪浅，因为这是一个从0到1的过程，我以后遇到类似的问题会想到有这么个东西可以用，而不是束手无策。\n\n#### 监控、故障恢复、测试\n\n一个项目，除了本身的业务代码以外，还有很多其他东西需要完善。比如测试，测试代码\b可以在\b上线之前验证一下程序的正确性，但是测试代码本身的质量就仁者见仁，智者见智了。前面提到了，项目会依赖很多其他的服务，那么其他服务出现故障时，自己的服务如何应对呢；还有如果网络出问题，服务器本身硬件出问题，如何去监测到并识别出来，也是需要解决的问题。因此除去业务代码，还需要很多的其他措施来保证程序的稳定性。\n\n也有人担心实习会不会因为太忙，没有时间复习与准备秋招。但我个人觉得，去实习的话性价比更高一些，可以让自己有更丰富的实战项目经验，有更多的谈资。复习的话，自己抽出时间复习点基础知识就行了。\n\n### 面试经验\n\n后台开发的面经网上太多了，我就简单的谈谈整个春招实习和秋招的面试感受。就我个人来说，春招和秋招相比有两个变化，第一个是春招时只会Python，第二个是没有项目经验（学校的渣渣项目，面试官根本不想听）；而秋招时，我\b投递的都是Java开发，而且有了一个大型项目的经历。而这两个变化带来的面试变化也非常的明显，春招时时这样的：\n\n```\n面试官：你开发的主要语言是什么？\n我：Python\n面试官：Python我不太会啊。我们聊点其他的吧....\n\n面试官：你介绍下你的项目吧。\n我：学校的小项目......\n面试官：嗯，我来问你些基础知识吧...（尽管我基础知识答的还行，但是大多数都挂了）\n```\n\n秋招时：\n```\n面试官：你开发的主要语言是什么？\n我：Python和Java\n面试官：你会Java啊，那我问你些Java基础呢。hashmap..线程池..锁\n我：\b使劲吹...使劲吹...\n面试官：Java掌握的还可以啊。（忽视了我的Python！！！）聊聊你的项目呢。\n我：实习的项目经历....吧啦吧啦...吧啦吧啦...\n面试官：这个项目不错啊，这个模块是干啥的...那个是干啥的...他们怎么交互的...你做了哪些...\n我：吧啦吧啦...吧啦吧啦...\n```\n\n可以明显的看出，秋招时，我能聊的东西更多了，而且是面试官关心的东西Java和项目经历。而面试时，聊的越多，聊的越顺畅，通过的几率就更大。除了这两个之外，比较重要的\b就是算法了，算法这东西我也比较讨厌，但是没办法，多刷刷`leetcode`吧。\n\n## 2019\n\n2018还发生了很多其他不好的事，是不幸的一年，但是既来之则安之，抱怨无济于事，只有努力让生活变得更加美好。这里立下一些小的flag。\n\n### 更新博客与公众号\n\n因为实习的原因博客荒废了很久，2019年要提高博客的数量与质量。同时想要创建两个公众号，一个用于博客的备份，一个用于刷leetcode。博客的备份公众号就是想简单的增加一个展示文章的平台。而leetcode的公众号则是基于我找工作的经历想要准备的，算法在面试中是重要的一环，而且是难以把握的一环，多刷一刷保持手感，提高自己的竞争力。\n\n### 毕业\n\n大学生涯就快结束了，好好享受这段时光，\b相比于工作，学校生活真的是轻松而且惬意的，做完毕设，顺利毕业。\n\n## Technique and Life\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![Technique and Life](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","source":"_posts/再见，2018.md","raw":"---\ntitle: 再见，2018\ndate: 2019-01-01 11:46:06\ntags:\n    - 随笔\n---\n\n前段时间忙着秋招和实习，\b好久没有更新博客了。在这辞旧迎新的一天，总结一下过去的2018，展望2019，立一些`flag`。同时作为\b新开公众号的第一篇文章，欢迎关注！（Technique and Life)\n\n## 2018\n\n### 校招:Python Vs Java\n\n简单介绍下背景，垫底985计算机本科。2018上半年是大四上学期，忙着春招找实习，python出身的我找实习屡屡碰壁，大厂的职位还是以Java和Cpp为主，即使说着`应届生不看重语言`，面试确总想着问Java基础，不会的话，\b面试是很难通过的。因为大多数科班出身的，计算机相关的基础知识都是比较扎实的，那么同等情况一个合适技术栈的应届生显然更加具有吸引力。\b好在还有一个`头条`招Python岗位的后台开发，运气不错，最终拿到实习Offer。\n\n<!--more-->\n\n找实习之前我就在纠结Python和Java如何选，但是一直用Python的我，对短短几个月转型Java是惧怕的，导致我迟迟没有动手。其次我信了**应届生不看重语言，更注重基础的邪**。于是我把时间都用来学习和复习计算机基础，比如网络，数据库之类的。就从面试情况来看，真的是非常吃亏，投递简历是会发现没有合适的岗位，大多数都写着需要扎实的Java基础，而面试官大多数也都是Java的技术栈，你想让他问别的，他可能也不了解，那面试可谈的东西大大减少，通过的几率就降低了。\n\n网上都流传着，语言不是重点，解决问题的能力才是。但是我觉得大多数人不到那个境界吧，而且公司的项目是有技术包袱的，如果不是新的项目，彻底放弃原来的技术栈，选用新的技术栈是有很大成本的，且公司的老人更加的不愿意变换语言。\b因此，掌握主流的技术还是必要的，大牛例外。主流意味着\b更多的机会，更多的学习资料、社区等，目前来看cpp和Java依然是后台开发的主流，python和Go的话也有市场，但是体量不如前两种语言大。\n\n### 头条实习之旅\n\n前面提到了，我投递的头条的Python后台开发岗位，很不巧的是我\b被分配到了基础设施部门，除了脚本用Python，其他几乎都是Java和Cpp,在用Python滑水两个月后，开始转型Java，这时候真正的意识到了危机，因为实习面试已经受挫，秋招如果继续找Python很可能找不到。\b这段时间也许是因为压力比较大，学的比较认真，很多东西学起来更快了，更容易了，很快就能用Java照着之前的代码，写点小的需求了。就这样一边学习，一边做点需求，但是由于半路出家，技术栈与部门差太多，最终没能转正，秋招也完美错过，当时真的压力很大，开始疯狂的投递补招和重新复习基础知识，晚上也经常失眠，所幸最后找到了BAT其中的一个开发offer,即使有\b不满意的地方，但也是可以接受的。（头条里我的导师还是不错的，让我一边实习一边找工作，也想要在我找工作的时候帮助我，但是我知道主要还是得靠自己的实力，所以并没有让他帮我，不过非常感谢！）\n\n截止到今天，已经实习了半年了，还将继续实习一个月吧，谈谈我的收获和感受。首先说说对头条的看法吧，正如大家都知道的，除了加班多，其他的各方面真的是非常完美了。尤其是包三餐，对独自在外的应届生来说是非常有吸引力的，部门的话可能差距就比较大了，就我所在的部门来说，同事还是非常nice的，也感觉到他们的技术非常强（可能是我菜- -！），虽然没能转正，但是还是很感谢他们。\n\n程序员还是要注重技术的积累，闲事少谈，下面就来谈谈实习对技术成长的帮助吧。实习是第一次从学校到职场的跨越，是第一次把所学运用到实际的过程，会发现很多的不足，受限于技术与眼界。下面列几个想到的点：\n\n#### 规范、合作\n\n首先是合作与规范的问题，公司的项目一般来说都比较大，需要多人合作，\b那么如何\b合作就成为一个问题，需要与同事正确沟通，确认需求和方案的可行性，需要熟练掌握git操作...之前一直没搞懂的git命令就这样被逼着学会了。其次是规范的问题，公司的项目必须有严格的流程，本地测试->review->合并分支->测试->上线...等一系列步骤，而我之前在学校的实验室时，这些操作几乎没有，只有拷贝到服务器，然后运行，出了问题再解决。但是公司的项目上线后必须保证正确性，不然有重大损失，所以一些必要的开发流程规范是需要遵守的。\n\n#### 规模、技术栈、系统设计\n\n\b也许因为我呆的是基础设施部门吧，小组做的项目体量非常大，服务器数量多，依赖的其他服务多，设计到的技术也非常多，我刚接触时一脸茫然。但是就是参与这个项目让我学到了很多，其中最重要的就要数系统设计了，了解了一个大型项目的整体框架，对一些典型的场景的宏观解决方案有一些认识（面试时还挺有用），如何解藕，并行，分布式等等...但是具体实现的话还是有非常大的难度，因为设计到的技术非常多，数据库就包含4种，还有各种中间件等，花了很长时间才了解了下这些东西的作用，但是更细致的暂时没有时间和能力去了解，不过我觉得也受益匪浅，因为这是一个从0到1的过程，我以后遇到类似的问题会想到有这么个东西可以用，而不是束手无策。\n\n#### 监控、故障恢复、测试\n\n一个项目，除了本身的业务代码以外，还有很多其他东西需要完善。比如测试，测试代码\b可以在\b上线之前验证一下程序的正确性，但是测试代码本身的质量就仁者见仁，智者见智了。前面提到了，项目会依赖很多其他的服务，那么其他服务出现故障时，自己的服务如何应对呢；还有如果网络出问题，服务器本身硬件出问题，如何去监测到并识别出来，也是需要解决的问题。因此除去业务代码，还需要很多的其他措施来保证程序的稳定性。\n\n也有人担心实习会不会因为太忙，没有时间复习与准备秋招。但我个人觉得，去实习的话性价比更高一些，可以让自己有更丰富的实战项目经验，有更多的谈资。复习的话，自己抽出时间复习点基础知识就行了。\n\n### 面试经验\n\n后台开发的面经网上太多了，我就简单的谈谈整个春招实习和秋招的面试感受。就我个人来说，春招和秋招相比有两个变化，第一个是春招时只会Python，第二个是没有项目经验（学校的渣渣项目，面试官根本不想听）；而秋招时，我\b投递的都是Java开发，而且有了一个大型项目的经历。而这两个变化带来的面试变化也非常的明显，春招时时这样的：\n\n```\n面试官：你开发的主要语言是什么？\n我：Python\n面试官：Python我不太会啊。我们聊点其他的吧....\n\n面试官：你介绍下你的项目吧。\n我：学校的小项目......\n面试官：嗯，我来问你些基础知识吧...（尽管我基础知识答的还行，但是大多数都挂了）\n```\n\n秋招时：\n```\n面试官：你开发的主要语言是什么？\n我：Python和Java\n面试官：你会Java啊，那我问你些Java基础呢。hashmap..线程池..锁\n我：\b使劲吹...使劲吹...\n面试官：Java掌握的还可以啊。（忽视了我的Python！！！）聊聊你的项目呢。\n我：实习的项目经历....吧啦吧啦...吧啦吧啦...\n面试官：这个项目不错啊，这个模块是干啥的...那个是干啥的...他们怎么交互的...你做了哪些...\n我：吧啦吧啦...吧啦吧啦...\n```\n\n可以明显的看出，秋招时，我能聊的东西更多了，而且是面试官关心的东西Java和项目经历。而面试时，聊的越多，聊的越顺畅，通过的几率就更大。除了这两个之外，比较重要的\b就是算法了，算法这东西我也比较讨厌，但是没办法，多刷刷`leetcode`吧。\n\n## 2019\n\n2018还发生了很多其他不好的事，是不幸的一年，但是既来之则安之，抱怨无济于事，只有努力让生活变得更加美好。这里立下一些小的flag。\n\n### 更新博客与公众号\n\n因为实习的原因博客荒废了很久，2019年要提高博客的数量与质量。同时想要创建两个公众号，一个用于博客的备份，一个用于刷leetcode。博客的备份公众号就是想简单的增加一个展示文章的平台。而leetcode的公众号则是基于我找工作的经历想要准备的，算法在面试中是重要的一环，而且是难以把握的一环，多刷一刷保持手感，提高自己的竞争力。\n\n### 毕业\n\n大学生涯就快结束了，好好享受这段时光，\b相比于工作，学校生活真的是轻松而且惬意的，做完毕设，顺利毕业。\n\n## Technique and Life\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![Technique and Life](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","slug":"再见，2018","published":1,"updated":"2019-02-03T07:16:46.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkll8000huetuznqs00ln","content":"<p>前段时间忙着秋招和实习，\b好久没有更新博客了。在这辞旧迎新的一天，总结一下过去的2018，展望2019，立一些<code>flag</code>。同时作为\b新开公众号的第一篇文章，欢迎关注！（Technique and Life)</p>\n<h2 id=\"2018\"><a href=\"#2018\" class=\"headerlink\" title=\"2018\"></a>2018</h2><h3 id=\"校招-Python-Vs-Java\"><a href=\"#校招-Python-Vs-Java\" class=\"headerlink\" title=\"校招:Python Vs Java\"></a>校招:Python Vs Java</h3><p>简单介绍下背景，垫底985计算机本科。2018上半年是大四上学期，忙着春招找实习，python出身的我找实习屡屡碰壁，大厂的职位还是以Java和Cpp为主，即使说着<code>应届生不看重语言</code>，面试确总想着问Java基础，不会的话，\b面试是很难通过的。因为大多数科班出身的，计算机相关的基础知识都是比较扎实的，那么同等情况一个合适技术栈的应届生显然更加具有吸引力。\b好在还有一个<code>头条</code>招Python岗位的后台开发，运气不错，最终拿到实习Offer。</p>\n<a id=\"more\"></a>\n<p>找实习之前我就在纠结Python和Java如何选，但是一直用Python的我，对短短几个月转型Java是惧怕的，导致我迟迟没有动手。其次我信了<strong>应届生不看重语言，更注重基础的邪</strong>。于是我把时间都用来学习和复习计算机基础，比如网络，数据库之类的。就从面试情况来看，真的是非常吃亏，投递简历是会发现没有合适的岗位，大多数都写着需要扎实的Java基础，而面试官大多数也都是Java的技术栈，你想让他问别的，他可能也不了解，那面试可谈的东西大大减少，通过的几率就降低了。</p>\n<p>网上都流传着，语言不是重点，解决问题的能力才是。但是我觉得大多数人不到那个境界吧，而且公司的项目是有技术包袱的，如果不是新的项目，彻底放弃原来的技术栈，选用新的技术栈是有很大成本的，且公司的老人更加的不愿意变换语言。\b因此，掌握主流的技术还是必要的，大牛例外。主流意味着\b更多的机会，更多的学习资料、社区等，目前来看cpp和Java依然是后台开发的主流，python和Go的话也有市场，但是体量不如前两种语言大。</p>\n<h3 id=\"头条实习之旅\"><a href=\"#头条实习之旅\" class=\"headerlink\" title=\"头条实习之旅\"></a>头条实习之旅</h3><p>前面提到了，我投递的头条的Python后台开发岗位，很不巧的是我\b被分配到了基础设施部门，除了脚本用Python，其他几乎都是Java和Cpp,在用Python滑水两个月后，开始转型Java，这时候真正的意识到了危机，因为实习面试已经受挫，秋招如果继续找Python很可能找不到。\b这段时间也许是因为压力比较大，学的比较认真，很多东西学起来更快了，更容易了，很快就能用Java照着之前的代码，写点小的需求了。就这样一边学习，一边做点需求，但是由于半路出家，技术栈与部门差太多，最终没能转正，秋招也完美错过，当时真的压力很大，开始疯狂的投递补招和重新复习基础知识，晚上也经常失眠，所幸最后找到了BAT其中的一个开发offer,即使有\b不满意的地方，但也是可以接受的。（头条里我的导师还是不错的，让我一边实习一边找工作，也想要在我找工作的时候帮助我，但是我知道主要还是得靠自己的实力，所以并没有让他帮我，不过非常感谢！）</p>\n<p>截止到今天，已经实习了半年了，还将继续实习一个月吧，谈谈我的收获和感受。首先说说对头条的看法吧，正如大家都知道的，除了加班多，其他的各方面真的是非常完美了。尤其是包三餐，对独自在外的应届生来说是非常有吸引力的，部门的话可能差距就比较大了，就我所在的部门来说，同事还是非常nice的，也感觉到他们的技术非常强（可能是我菜- -！），虽然没能转正，但是还是很感谢他们。</p>\n<p>程序员还是要注重技术的积累，闲事少谈，下面就来谈谈实习对技术成长的帮助吧。实习是第一次从学校到职场的跨越，是第一次把所学运用到实际的过程，会发现很多的不足，受限于技术与眼界。下面列几个想到的点：</p>\n<h4 id=\"规范、合作\"><a href=\"#规范、合作\" class=\"headerlink\" title=\"规范、合作\"></a>规范、合作</h4><p>首先是合作与规范的问题，公司的项目一般来说都比较大，需要多人合作，\b那么如何\b合作就成为一个问题，需要与同事正确沟通，确认需求和方案的可行性，需要熟练掌握git操作…之前一直没搞懂的git命令就这样被逼着学会了。其次是规范的问题，公司的项目必须有严格的流程，本地测试-&gt;review-&gt;合并分支-&gt;测试-&gt;上线…等一系列步骤，而我之前在学校的实验室时，这些操作几乎没有，只有拷贝到服务器，然后运行，出了问题再解决。但是公司的项目上线后必须保证正确性，不然有重大损失，所以一些必要的开发流程规范是需要遵守的。</p>\n<h4 id=\"规模、技术栈、系统设计\"><a href=\"#规模、技术栈、系统设计\" class=\"headerlink\" title=\"规模、技术栈、系统设计\"></a>规模、技术栈、系统设计</h4><p>\b也许因为我呆的是基础设施部门吧，小组做的项目体量非常大，服务器数量多，依赖的其他服务多，设计到的技术也非常多，我刚接触时一脸茫然。但是就是参与这个项目让我学到了很多，其中最重要的就要数系统设计了，了解了一个大型项目的整体框架，对一些典型的场景的宏观解决方案有一些认识（面试时还挺有用），如何解藕，并行，分布式等等…但是具体实现的话还是有非常大的难度，因为设计到的技术非常多，数据库就包含4种，还有各种中间件等，花了很长时间才了解了下这些东西的作用，但是更细致的暂时没有时间和能力去了解，不过我觉得也受益匪浅，因为这是一个从0到1的过程，我以后遇到类似的问题会想到有这么个东西可以用，而不是束手无策。</p>\n<h4 id=\"监控、故障恢复、测试\"><a href=\"#监控、故障恢复、测试\" class=\"headerlink\" title=\"监控、故障恢复、测试\"></a>监控、故障恢复、测试</h4><p>一个项目，除了本身的业务代码以外，还有很多其他东西需要完善。比如测试，测试代码\b可以在\b上线之前验证一下程序的正确性，但是测试代码本身的质量就仁者见仁，智者见智了。前面提到了，项目会依赖很多其他的服务，那么其他服务出现故障时，自己的服务如何应对呢；还有如果网络出问题，服务器本身硬件出问题，如何去监测到并识别出来，也是需要解决的问题。因此除去业务代码，还需要很多的其他措施来保证程序的稳定性。</p>\n<p>也有人担心实习会不会因为太忙，没有时间复习与准备秋招。但我个人觉得，去实习的话性价比更高一些，可以让自己有更丰富的实战项目经验，有更多的谈资。复习的话，自己抽出时间复习点基础知识就行了。</p>\n<h3 id=\"面试经验\"><a href=\"#面试经验\" class=\"headerlink\" title=\"面试经验\"></a>面试经验</h3><p>后台开发的面经网上太多了，我就简单的谈谈整个春招实习和秋招的面试感受。就我个人来说，春招和秋招相比有两个变化，第一个是春招时只会Python，第二个是没有项目经验（学校的渣渣项目，面试官根本不想听）；而秋招时，我\b投递的都是Java开发，而且有了一个大型项目的经历。而这两个变化带来的面试变化也非常的明显，春招时时这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">面试官：你开发的主要语言是什么？</span><br><span class=\"line\">我：Python</span><br><span class=\"line\">面试官：Python我不太会啊。我们聊点其他的吧....</span><br><span class=\"line\"></span><br><span class=\"line\">面试官：你介绍下你的项目吧。</span><br><span class=\"line\">我：学校的小项目......</span><br><span class=\"line\">面试官：嗯，我来问你些基础知识吧...（尽管我基础知识答的还行，但是大多数都挂了）</span><br></pre></td></tr></table></figure>\n<p>秋招时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">面试官：你开发的主要语言是什么？</span><br><span class=\"line\">我：Python和Java</span><br><span class=\"line\">面试官：你会Java啊，那我问你些Java基础呢。hashmap..线程池..锁</span><br><span class=\"line\">我：\b使劲吹...使劲吹...</span><br><span class=\"line\">面试官：Java掌握的还可以啊。（忽视了我的Python！！！）聊聊你的项目呢。</span><br><span class=\"line\">我：实习的项目经历....吧啦吧啦...吧啦吧啦...</span><br><span class=\"line\">面试官：这个项目不错啊，这个模块是干啥的...那个是干啥的...他们怎么交互的...你做了哪些...</span><br><span class=\"line\">我：吧啦吧啦...吧啦吧啦...</span><br></pre></td></tr></table></figure></p>\n<p>可以明显的看出，秋招时，我能聊的东西更多了，而且是面试官关心的东西Java和项目经历。而面试时，聊的越多，聊的越顺畅，通过的几率就更大。除了这两个之外，比较重要的\b就是算法了，算法这东西我也比较讨厌，但是没办法，多刷刷<code>leetcode</code>吧。</p>\n<h2 id=\"2019\"><a href=\"#2019\" class=\"headerlink\" title=\"2019\"></a>2019</h2><p>2018还发生了很多其他不好的事，是不幸的一年，但是既来之则安之，抱怨无济于事，只有努力让生活变得更加美好。这里立下一些小的flag。</p>\n<h3 id=\"更新博客与公众号\"><a href=\"#更新博客与公众号\" class=\"headerlink\" title=\"更新博客与公众号\"></a>更新博客与公众号</h3><p>因为实习的原因博客荒废了很久，2019年要提高博客的数量与质量。同时想要创建两个公众号，一个用于博客的备份，一个用于刷leetcode。博客的备份公众号就是想简单的增加一个展示文章的平台。而leetcode的公众号则是基于我找工作的经历想要准备的，算法在面试中是重要的一环，而且是难以把握的一环，多刷一刷保持手感，提高自己的竞争力。</p>\n<h3 id=\"毕业\"><a href=\"#毕业\" class=\"headerlink\" title=\"毕业\"></a>毕业</h3><p>大学生涯就快结束了，好好享受这段时光，\b相比于工作，学校生活真的是轻松而且惬意的，做完毕设，顺利毕业。</p>\n<h2 id=\"Technique-and-Life\"><a href=\"#Technique-and-Life\" class=\"headerlink\" title=\"Technique and Life\"></a>Technique and Life</h2><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"Technique and Life\"></p>\n","site":{"data":{}},"excerpt":"<p>前段时间忙着秋招和实习，\b好久没有更新博客了。在这辞旧迎新的一天，总结一下过去的2018，展望2019，立一些<code>flag</code>。同时作为\b新开公众号的第一篇文章，欢迎关注！（Technique and Life)</p>\n<h2 id=\"2018\"><a href=\"#2018\" class=\"headerlink\" title=\"2018\"></a>2018</h2><h3 id=\"校招-Python-Vs-Java\"><a href=\"#校招-Python-Vs-Java\" class=\"headerlink\" title=\"校招:Python Vs Java\"></a>校招:Python Vs Java</h3><p>简单介绍下背景，垫底985计算机本科。2018上半年是大四上学期，忙着春招找实习，python出身的我找实习屡屡碰壁，大厂的职位还是以Java和Cpp为主，即使说着<code>应届生不看重语言</code>，面试确总想着问Java基础，不会的话，\b面试是很难通过的。因为大多数科班出身的，计算机相关的基础知识都是比较扎实的，那么同等情况一个合适技术栈的应届生显然更加具有吸引力。\b好在还有一个<code>头条</code>招Python岗位的后台开发，运气不错，最终拿到实习Offer。</p>","more":"<p>找实习之前我就在纠结Python和Java如何选，但是一直用Python的我，对短短几个月转型Java是惧怕的，导致我迟迟没有动手。其次我信了<strong>应届生不看重语言，更注重基础的邪</strong>。于是我把时间都用来学习和复习计算机基础，比如网络，数据库之类的。就从面试情况来看，真的是非常吃亏，投递简历是会发现没有合适的岗位，大多数都写着需要扎实的Java基础，而面试官大多数也都是Java的技术栈，你想让他问别的，他可能也不了解，那面试可谈的东西大大减少，通过的几率就降低了。</p>\n<p>网上都流传着，语言不是重点，解决问题的能力才是。但是我觉得大多数人不到那个境界吧，而且公司的项目是有技术包袱的，如果不是新的项目，彻底放弃原来的技术栈，选用新的技术栈是有很大成本的，且公司的老人更加的不愿意变换语言。\b因此，掌握主流的技术还是必要的，大牛例外。主流意味着\b更多的机会，更多的学习资料、社区等，目前来看cpp和Java依然是后台开发的主流，python和Go的话也有市场，但是体量不如前两种语言大。</p>\n<h3 id=\"头条实习之旅\"><a href=\"#头条实习之旅\" class=\"headerlink\" title=\"头条实习之旅\"></a>头条实习之旅</h3><p>前面提到了，我投递的头条的Python后台开发岗位，很不巧的是我\b被分配到了基础设施部门，除了脚本用Python，其他几乎都是Java和Cpp,在用Python滑水两个月后，开始转型Java，这时候真正的意识到了危机，因为实习面试已经受挫，秋招如果继续找Python很可能找不到。\b这段时间也许是因为压力比较大，学的比较认真，很多东西学起来更快了，更容易了，很快就能用Java照着之前的代码，写点小的需求了。就这样一边学习，一边做点需求，但是由于半路出家，技术栈与部门差太多，最终没能转正，秋招也完美错过，当时真的压力很大，开始疯狂的投递补招和重新复习基础知识，晚上也经常失眠，所幸最后找到了BAT其中的一个开发offer,即使有\b不满意的地方，但也是可以接受的。（头条里我的导师还是不错的，让我一边实习一边找工作，也想要在我找工作的时候帮助我，但是我知道主要还是得靠自己的实力，所以并没有让他帮我，不过非常感谢！）</p>\n<p>截止到今天，已经实习了半年了，还将继续实习一个月吧，谈谈我的收获和感受。首先说说对头条的看法吧，正如大家都知道的，除了加班多，其他的各方面真的是非常完美了。尤其是包三餐，对独自在外的应届生来说是非常有吸引力的，部门的话可能差距就比较大了，就我所在的部门来说，同事还是非常nice的，也感觉到他们的技术非常强（可能是我菜- -！），虽然没能转正，但是还是很感谢他们。</p>\n<p>程序员还是要注重技术的积累，闲事少谈，下面就来谈谈实习对技术成长的帮助吧。实习是第一次从学校到职场的跨越，是第一次把所学运用到实际的过程，会发现很多的不足，受限于技术与眼界。下面列几个想到的点：</p>\n<h4 id=\"规范、合作\"><a href=\"#规范、合作\" class=\"headerlink\" title=\"规范、合作\"></a>规范、合作</h4><p>首先是合作与规范的问题，公司的项目一般来说都比较大，需要多人合作，\b那么如何\b合作就成为一个问题，需要与同事正确沟通，确认需求和方案的可行性，需要熟练掌握git操作…之前一直没搞懂的git命令就这样被逼着学会了。其次是规范的问题，公司的项目必须有严格的流程，本地测试-&gt;review-&gt;合并分支-&gt;测试-&gt;上线…等一系列步骤，而我之前在学校的实验室时，这些操作几乎没有，只有拷贝到服务器，然后运行，出了问题再解决。但是公司的项目上线后必须保证正确性，不然有重大损失，所以一些必要的开发流程规范是需要遵守的。</p>\n<h4 id=\"规模、技术栈、系统设计\"><a href=\"#规模、技术栈、系统设计\" class=\"headerlink\" title=\"规模、技术栈、系统设计\"></a>规模、技术栈、系统设计</h4><p>\b也许因为我呆的是基础设施部门吧，小组做的项目体量非常大，服务器数量多，依赖的其他服务多，设计到的技术也非常多，我刚接触时一脸茫然。但是就是参与这个项目让我学到了很多，其中最重要的就要数系统设计了，了解了一个大型项目的整体框架，对一些典型的场景的宏观解决方案有一些认识（面试时还挺有用），如何解藕，并行，分布式等等…但是具体实现的话还是有非常大的难度，因为设计到的技术非常多，数据库就包含4种，还有各种中间件等，花了很长时间才了解了下这些东西的作用，但是更细致的暂时没有时间和能力去了解，不过我觉得也受益匪浅，因为这是一个从0到1的过程，我以后遇到类似的问题会想到有这么个东西可以用，而不是束手无策。</p>\n<h4 id=\"监控、故障恢复、测试\"><a href=\"#监控、故障恢复、测试\" class=\"headerlink\" title=\"监控、故障恢复、测试\"></a>监控、故障恢复、测试</h4><p>一个项目，除了本身的业务代码以外，还有很多其他东西需要完善。比如测试，测试代码\b可以在\b上线之前验证一下程序的正确性，但是测试代码本身的质量就仁者见仁，智者见智了。前面提到了，项目会依赖很多其他的服务，那么其他服务出现故障时，自己的服务如何应对呢；还有如果网络出问题，服务器本身硬件出问题，如何去监测到并识别出来，也是需要解决的问题。因此除去业务代码，还需要很多的其他措施来保证程序的稳定性。</p>\n<p>也有人担心实习会不会因为太忙，没有时间复习与准备秋招。但我个人觉得，去实习的话性价比更高一些，可以让自己有更丰富的实战项目经验，有更多的谈资。复习的话，自己抽出时间复习点基础知识就行了。</p>\n<h3 id=\"面试经验\"><a href=\"#面试经验\" class=\"headerlink\" title=\"面试经验\"></a>面试经验</h3><p>后台开发的面经网上太多了，我就简单的谈谈整个春招实习和秋招的面试感受。就我个人来说，春招和秋招相比有两个变化，第一个是春招时只会Python，第二个是没有项目经验（学校的渣渣项目，面试官根本不想听）；而秋招时，我\b投递的都是Java开发，而且有了一个大型项目的经历。而这两个变化带来的面试变化也非常的明显，春招时时这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">面试官：你开发的主要语言是什么？</span><br><span class=\"line\">我：Python</span><br><span class=\"line\">面试官：Python我不太会啊。我们聊点其他的吧....</span><br><span class=\"line\"></span><br><span class=\"line\">面试官：你介绍下你的项目吧。</span><br><span class=\"line\">我：学校的小项目......</span><br><span class=\"line\">面试官：嗯，我来问你些基础知识吧...（尽管我基础知识答的还行，但是大多数都挂了）</span><br></pre></td></tr></table></figure>\n<p>秋招时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">面试官：你开发的主要语言是什么？</span><br><span class=\"line\">我：Python和Java</span><br><span class=\"line\">面试官：你会Java啊，那我问你些Java基础呢。hashmap..线程池..锁</span><br><span class=\"line\">我：\b使劲吹...使劲吹...</span><br><span class=\"line\">面试官：Java掌握的还可以啊。（忽视了我的Python！！！）聊聊你的项目呢。</span><br><span class=\"line\">我：实习的项目经历....吧啦吧啦...吧啦吧啦...</span><br><span class=\"line\">面试官：这个项目不错啊，这个模块是干啥的...那个是干啥的...他们怎么交互的...你做了哪些...</span><br><span class=\"line\">我：吧啦吧啦...吧啦吧啦...</span><br></pre></td></tr></table></figure></p>\n<p>可以明显的看出，秋招时，我能聊的东西更多了，而且是面试官关心的东西Java和项目经历。而面试时，聊的越多，聊的越顺畅，通过的几率就更大。除了这两个之外，比较重要的\b就是算法了，算法这东西我也比较讨厌，但是没办法，多刷刷<code>leetcode</code>吧。</p>\n<h2 id=\"2019\"><a href=\"#2019\" class=\"headerlink\" title=\"2019\"></a>2019</h2><p>2018还发生了很多其他不好的事，是不幸的一年，但是既来之则安之，抱怨无济于事，只有努力让生活变得更加美好。这里立下一些小的flag。</p>\n<h3 id=\"更新博客与公众号\"><a href=\"#更新博客与公众号\" class=\"headerlink\" title=\"更新博客与公众号\"></a>更新博客与公众号</h3><p>因为实习的原因博客荒废了很久，2019年要提高博客的数量与质量。同时想要创建两个公众号，一个用于博客的备份，一个用于刷leetcode。博客的备份公众号就是想简单的增加一个展示文章的平台。而leetcode的公众号则是基于我找工作的经历想要准备的，算法在面试中是重要的一环，而且是难以把握的一环，多刷一刷保持手感，提高自己的竞争力。</p>\n<h3 id=\"毕业\"><a href=\"#毕业\" class=\"headerlink\" title=\"毕业\"></a>毕业</h3><p>大学生涯就快结束了，好好享受这段时光，\b相比于工作，学校生活真的是轻松而且惬意的，做完毕设，顺利毕业。</p>\n<h2 id=\"Technique-and-Life\"><a href=\"#Technique-and-Life\" class=\"headerlink\" title=\"Technique and Life\"></a>Technique and Life</h2><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"Technique and Life\"></p>"},{"title":"常用排序算法总结","date":"2018-05-29T10:59:59.000Z","_content":"排序算法非常的多，在学习数据结构和算法时肯定都会学习到关于排序的算法，虽然现在高级语言都自带内置的排序函数，但是理解一些常见排序算法的思想和适用场合也是非常重要的，这也是面试时的经典题目，所以准备找工作的我打算将这些算法复习和整理一遍，所有算法代码采用Python编写。（数组下标从0开始）\n\n## 冒泡排序\n\n冒泡排序应该是第一个学习的排序算法吧，在学习C语言时就会学到，虽然效率比较低，但是在某些不需要全部排序的情况下也是很有效的，比如只需找出前3大的元素时。\n<!--more-->\n\n#### 算法描述\n\n1. 从第一个记录开始，相邻记录两两比较，若前一个记录大于后一个记录，则交换\n\n1. 第一趟将序列中最大的记录放到了最后一个位置\n\n1. n个记录比较n-1趟\n\n#### 代码\n\n```python\ndef bubble_sort(lists):\n    for i in range(len(lists)):\n        for j in range(0, len(lists)-i-1):\n            if lists[j] > lists[j+1]:\n                lists[j], lists[j+1] = lists[j+1], lists[j]\n```\n\n#### 优化冒泡代码\n\n```python\ndef bubble_sort(lists):\n    for i in range(len(lists)):\n        flag = True\n        for j in range(0, len(lists)-i-1):\n            if lists[j] > lists[j+1]:\n                flag = False\n                lists[j], lists[j+1] = lists[j+1], lists[j]\n        if flag:\n            break\n```\n\n#### 算法分析\n\n冒泡排序是稳定的，时间复杂度很容易就看出是O(n^2)，所以是一个比较慢的排序算法。优化的冒泡排序是设置一个标识符，当flag为真时说明没有发生交换，则后面都为有序的，可以直接跳出循环。\n\n## 选择排序\n\n**基本思想**：序列大小为N,则共进行N-1趟排序，第一趟选出最小的与第一个元素交换，第二趟在剩余的无序序列中选出最小的与第二个元素交换，一直进行N-1趟。\n\n#### 代码\n\n```python\ndef select_sort(lists):\n    length, i = len(lists), 0\n    while i < length-1:\n        min_temp = i\n        for j in range(i+1, length):\n            if lists[j] < lists[min_temp]:\n                min_temp = j\n        lists[i], lists[min_temp] = lists[min_temp], lists[i]\n        i += 1\n```\n\n#### 算法分析\n\n时间复杂度O(n^2),算法是稳定的。选择排序与冒泡排序有点相似，每一轮排序结束时最大的元素将被放置到序列的一端，区别在于选择排序只交换一次，冒泡排序可能交换很多次。\n\n## 快速排序\n\n快速排序之所以叫快速排序，那当然是因为他快了~\n\n**基本思想**：任取待排序对象序列中的某个对象v(枢轴，基准，支点)，按照该对象的关键字大小，将整个序列划分为左右两个子序列：\n1. 左侧子序列中所有对象的关键字都小于或等于对象v的关键字；\n1. 右侧子序列中所有对象的关键字都大于或等于对象v的关键字；\n1. 对象v则排在这两个子序列中间(也是它最终的位置)\n\n**算法步骤**：首先选取一个基准元素(pivot)，基准元素可以任意选择，将基准元素与第一个元素交换。令i指向第一个元素，j指向最后一个元素,首先从最后一个元素开始向前遍历序列，遇到比pivot小的元素时，将j指向的值赋值给i指向的位置；然后i加1，从i开始向后遍历，直到遇到比pivot大的元素，赋值给j指向的位置；然后开始移动j....算法一直重复直到i==j，将pivot的值赋值给j指向的位置。到这一步就将序列分成左右两部分，左边部分小于等于pivot，右边部分大于等于pivot，递归执行上述步骤直到左右序列长度都为1\n\n### 讲解示例\n\n有数组如下：\n\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|30 | 2 | 87 | 25| 49 | 50 | 22| 12|\n\n> 令pivot = lists[0] = 30, i = 0, j = 7\n\n> j=7时，lists[7]=12 < pivot，lists[i]=lists[j]\n\n> 得到如下数组: [12, 2, 87, 25, 49, 50, 22, 12]\n\n> i++, i=1时，lists[1]=2 < pivot, i++\n\n> i=2时, lists[2]=87 > pivot, lists[j]=lists[i]\n\n> 得到如下数组：[12, 2, 87, 25, 49, 50, 22, 87]\n\n> j--, j=6, lists[6]=22 < pivot, lists[i]=lists[j]\n\n> 得到如下数组：[12, 2, 22, 25, 49, 50, 22, 87]\n\n> i++, i=3时，lists[i]=25 < pivot, i++\n\n> i=4时, lists[i]=49 > pivot, lists[j]=lists[i]\n\n> 得到如下数组: [12, 2, 22, 25, 49, 50, 49, 87]\n\n> j--, j=5时，lists[j]=50 > pivot, j--\n\n> j=4时, j == i,lists[j]=pivot\n\n> 得到如下数组：[12, 2, 22, 25, 30, 50, 49, 87]\n\n#### 代码\n\n```python\ndef quick_sort(lists, left, right):\n    if left < right:\n        i, j, pivot = left, right, lists[left]\n        while i < j:\n            while i < j:\n                if lists[j] < pivot:\n                    lists[i] = lists[j]\n                    break\n                j -= 1\n            while i < j:\n                if lists[i] > pivot:\n                    lists[j] = lists[i]\n                    break\n                i += 1\n        lists[j] = pivot\n        quick_sort(lists, left, j-1)\n        quick_sort(lists, j+1, right)\n``` \n\n#### 算法分析\n\n快速排序在实际应用中有最好的运行速度，平均时间复杂度为O(nlogn)，但是最坏的情况下位O(n^2)。至于为什么快速排序在时间复杂度为O(nlogn)的一些排序算法中速度最快，感兴趣的可以自己去查查资料。此外影响快速排序效率的关键就是Pivot的选择，常见的有取第一个，取最后一个，取前中后的中间数，pivot如果能正好将序列左右等分，那效率就是最高的。\n\n## 插入排序\n\n插入排序有多种变形算法，我介绍一下直接插入排序、折半插入排序和希尔排序，前两种算法只在插入的时候有些区别，总体思想是一致的。\n\n### 插入排序的思想\n\n> 1. 一个记录是有序的\n> 1. 从第二个记录开始，将每个记录插入到已排好序的序列中\n> 1. 一直进行到第n个记录\n\n### 直接插入排序\n\n直接插入排序第n次循环将下标为n的元素A插入合适的位置，将A依次与前一个元素B比较，若A>=B,则A不动，进入下一次循环；若A<B，则交换AB，重复上述操作。\n\n#### 代码\n\n```python\ndef direct_insert_sort(lists):\n    for i in range(1, len(lists)):\n        if lists[i] >= lists[i-1]:\n            continue\n        lists[i], lists[i-1] = lists[i-1], lists[i]\n        for j in range(i-1, 0, -1):\n            if lists[j] >= lists[j-1]:\n                break\n            lists[j], lists[j-1] = lists[j-1], lists[j]\n    \n```\n\n#### 算法分析\n\n1. 直接插入排序是稳定排序算法\n1. 时间复杂度：最好情况O(1),最坏O(n^2),平均O(n^2)\n1. 空间复杂度O(1)\n\n### 折半插入排序\n\n在插入排序中，第n次循环时，下标0到n-1的元素是有序的，可以用二分查找找到合适位置并插入第n个元素。\n\n#### 代码\n\n```python\ndef binary_insert_sort(lists):\n    for i in range(1, len(lists)):\n        if lists[i] >= lists[i-1]:\n            continue\n        # 折半查找\n        low, high = 0, i-1\n        while low <= high:\n            mid = (high + low) // 2\n            if lists[mid] > lists[i]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        for j in range(i, low, -1):\n            lists[j], lists[j-1] = lists[j-1], lists[j]\n```\n\n#### 算法分析\n\n为什么用low下标作为最终位置呢？可以看while循环的条件是low<=high，且是唯一跳出循环的条件，low与high只以1为增量，所以退出循环时low=high+1，但最后一次有效循环时，low与high与mid是相等的，如果lists[mid] > lists[i],则这个元素应该在mid前面，也就是low前面，如果lists[mid] <= lists[i]，则这个元素应该在mid后面，即low=mid+1这个位置。\n\n### 希尔排序\n\n希尔排序与直接插入算法大致过程是一样的，希尔排序需要进行多趟排序，先进行**宏观**排序，再进行**微观**排序。宏观调整指跳跃式的插入排序\n\n大致过程：\n\n1. 将数组分为若干个子序列进行插入排序\n\n> 例如：将N个记录分成d个子序列\n> {R[1], R[1+d], R[1+2d] ....}\n> {R[2], R[2+d], R[2+2d] ....}\n> ....\n> {R[d], R[d+d], R[d+2d] ....}\n\n2. 其中d为增量，他的值在排序过程中从大到小逐渐减少，最后一次排序变为1\n\n#### 代码\n\n```python\ndef shell_insert_sort(lists, dlta):\n    # para dlta: 增量d的序列，保证最后一个为1\n    for k in dlta:\n        shell_insert(lists, k)\n\n\ndef shell_insert(lists, step):\n    for i in range(step):\n        for j in range(i+step, len(lists), step):\n            if lists[j] >= lists[j-step]:\n                continue\n            lists[j], lists[j-step] = lists[j-step], lists[j]\n            for j in range(j-step, i+step-1, -step):\n                if lists[j] >= lists[j-step]:\n                    break\n                lists[j], lists[j-step] = lists[j-step], lists[j]\n```\n\n#### 算法分析\n\n希尔排序是不稳定的排序方法，即元素的相对顺序会改变。但是希尔排序的平均时间复杂度要比直接插入排序快一些，在O(n^1.3)与O(n^1.5)之间(来自教材)。希尔排序的优势在于减少了元素交换的次数，因为他可以以相对快的速度将大的数转移到数组的后面部分，取决于增量d的序列，因此增量d的序列的选择是算法效率好坏的关键。\n\n## 归并排序\n\n**基本思想**：（1）将N个记录看成n个长度为1的有序子表（2）将两两相邻的有序子表进行归并，若子表个数为奇数，最后一个子表进入下一次归并（3）重复步骤（2），直到归并成一个长度为N的有序表\n\n#### 代码\n\n```python\ndef merge_sort(lists):\n    step, length = 1, len(lists)\n    extend = [0 for i in range(length)]\n    while step < length*2:\n        start = 0\n        while start < length:\n            low, mid = start, min(start+step, length)\n            high, temp = min(start+step+step, length), low\n            start1, end1 = low, mid\n            start2, end2 = mid, high\n            while start1 < end1 and start2 < end2:\n                if lists[start1] < lists[start2]:\n                    extend[temp] = lists[start1]\n                    temp += 1\n                    start1 += 1\n                else:\n                    extend[temp] = lists[start2]\n                    temp += 1\n                    start2 += 1\n            while start1 < end1:\n                extend[temp] = lists[start1]\n                temp += 1\n                start1 += 1\n            while start2 < end2:\n                extend[temp] = lists[start2]\n                temp += 1\n                start2 += 1\n            start += 2 * step\n        lists, extend = extend, lists\n        step += step\n```\n\n#### 算法分析\n\n归并排序有两种方式，一种自上而下，一种自下而上，我的示例代码为自下而上，也称为2路归并。归并排序是一个稳定的排序方法，每趟归并耗费O(n)的时间，归并趟数为logn，所以时间复杂度为O(nlogn)。但是也使用了额外的存储空间，空间复杂度为O(n)。\n\n## 堆排序\n\n堆排序属于选择排序，出发点是利用前一次比较的结果，减少比较次数。\n\n了解堆排序首先需要知道堆的定义，这里用到的堆是完全二叉树，分为小根堆和大根堆。其中最大堆满足如下条件\n\n1. 父结点的值大于等于儿子结点\n\n2. 左右子树都是一个二叉堆\n\n因为待排序的一般是序列，用序列表示如下：\n> A[i] >= A[2*i+1] \n> 且 A[i] > A[2*i+2]\n\n#### 堆排序需要解决两个问题\n\n1. 由一个无序序列建成一个最大(小)堆\n\n1. 弹出堆顶元素，调整剩余元素成为新的堆\n\n#### 算法步骤（大根堆）\n\n1. 建立大根堆\n\n1. 输出堆顶元素，即lists[0]与最后一个未排序的元素交换，第一次为最后一个，第二次为倒数第二个......\n\n1. 交换后，未排序的元素不再满足大根堆的特性，重新建堆\n\n1. 重复2.3两步，知道排序完成\n\n#### 代码\n\n```python\ndef heap_sort(lists):\n    length = len(lists)\n    for i in range(length//2-1, -1, -1):\n        max_heap_adjust(lists, i, length)\n    for i in range(length-1, 0, -1):\n        lists[0], lists[i] = lists[i], lists[0]\n        max_heap_adjust(lists, 0, i)\n\ndef max_heap_adjust(lists, start, end):\n    while True:\n        imax, ileft, iright = start, 2*start+1, 2*start+2\n        if ileft < end and lists[start] < lists[ileft]:\n            imax = ileft\n        if iright < end and lists[imax] < lists[iright]:\n            imax = iright\n        if imax == start:\n            break\n        lists[start], lists[imax] = lists[imax], lists[start]\n        start = imax\n```\n\n#### 算法分析\n\n堆排序是不稳定的排序，时间复杂度为O(nlogn)。且最慢情况下也为O(nlogn)。\n\n这个算法需要对二叉树的一些特性有了解，不然边界情况很容易糊涂了，我自己写代码的时候少了一次循环，改来改去没发现，总觉得是对的，浪费了挺久时间。\n\n## 总结\n\n有些排序代码一下子写出来还是比较难的，但是算法更重要的是理解吧，毕竟写的这些排序算法也不太用的到,而且同样的思想和步骤也能写出不一样的代码，也会影响排序的快慢，开头也提到过了，高级语言的库里一般都自带排序算法，且速度更快，所以理解透彻就行了。下面我简单的以我写的代码测一下三个O(nlogn)时间复杂度的算法和Python内置sort()的速度快慢。序列全部random产生，同一组测试为同一个序列。\n\n### 10000个元素\n\n> <function merge_sort at 0x00000245EC6AA9D8> costs :  0.03701162338256836\n> <function quick_sort at 0x00000245EC6AAC80> costs :  0.025029897689819336\n> <function heap_sort at 0x00000245EC6AAAE8> costs :  0.05319356918334961\n> <function python_sort at 0x00000245EC6AAE18> costs :  0.002984762191772461\n\n### 50000个元素\n\n> <function merge_sort at 0x000002523ECCA9D8> costs :  0.21823906898498535\n> <function quick_sort at 0x000002523ECCAC80> costs :  0.1542985439300537\n> <function heap_sort at 0x000002523ECCAAE8> costs :  0.3872966766357422\n> <function python_sort at 0x000002523ECCAE18> costs :  0.016024351119995117\n\n### 100000个元素\n\n> <function merge_sort at 0x0000023023FBA9D8> costs :  0.4917008876800537\n> <function quick_sort at 0x0000023023FBAC80> costs :  0.3395521640777588\n> <function heap_sort at 0x0000023023FBAAE8> costs :  0.7686326503753662\n> <function python_sort at 0x0000023023FBAE18> costs :  0.03353142738342285\n\n可以看出python自带的排序sort()方法是远远快于我写的排序算法的。。。。不过快排确实是NlogN级别算法中速度最快的。","source":"_posts/常用排序算法总结.md","raw":"---\ntitle: 常用排序算法总结\ndate: 2018-05-29 18:59:59\ntags:\n    - 数据结构\n    - 算法\n---\n排序算法非常的多，在学习数据结构和算法时肯定都会学习到关于排序的算法，虽然现在高级语言都自带内置的排序函数，但是理解一些常见排序算法的思想和适用场合也是非常重要的，这也是面试时的经典题目，所以准备找工作的我打算将这些算法复习和整理一遍，所有算法代码采用Python编写。（数组下标从0开始）\n\n## 冒泡排序\n\n冒泡排序应该是第一个学习的排序算法吧，在学习C语言时就会学到，虽然效率比较低，但是在某些不需要全部排序的情况下也是很有效的，比如只需找出前3大的元素时。\n<!--more-->\n\n#### 算法描述\n\n1. 从第一个记录开始，相邻记录两两比较，若前一个记录大于后一个记录，则交换\n\n1. 第一趟将序列中最大的记录放到了最后一个位置\n\n1. n个记录比较n-1趟\n\n#### 代码\n\n```python\ndef bubble_sort(lists):\n    for i in range(len(lists)):\n        for j in range(0, len(lists)-i-1):\n            if lists[j] > lists[j+1]:\n                lists[j], lists[j+1] = lists[j+1], lists[j]\n```\n\n#### 优化冒泡代码\n\n```python\ndef bubble_sort(lists):\n    for i in range(len(lists)):\n        flag = True\n        for j in range(0, len(lists)-i-1):\n            if lists[j] > lists[j+1]:\n                flag = False\n                lists[j], lists[j+1] = lists[j+1], lists[j]\n        if flag:\n            break\n```\n\n#### 算法分析\n\n冒泡排序是稳定的，时间复杂度很容易就看出是O(n^2)，所以是一个比较慢的排序算法。优化的冒泡排序是设置一个标识符，当flag为真时说明没有发生交换，则后面都为有序的，可以直接跳出循环。\n\n## 选择排序\n\n**基本思想**：序列大小为N,则共进行N-1趟排序，第一趟选出最小的与第一个元素交换，第二趟在剩余的无序序列中选出最小的与第二个元素交换，一直进行N-1趟。\n\n#### 代码\n\n```python\ndef select_sort(lists):\n    length, i = len(lists), 0\n    while i < length-1:\n        min_temp = i\n        for j in range(i+1, length):\n            if lists[j] < lists[min_temp]:\n                min_temp = j\n        lists[i], lists[min_temp] = lists[min_temp], lists[i]\n        i += 1\n```\n\n#### 算法分析\n\n时间复杂度O(n^2),算法是稳定的。选择排序与冒泡排序有点相似，每一轮排序结束时最大的元素将被放置到序列的一端，区别在于选择排序只交换一次，冒泡排序可能交换很多次。\n\n## 快速排序\n\n快速排序之所以叫快速排序，那当然是因为他快了~\n\n**基本思想**：任取待排序对象序列中的某个对象v(枢轴，基准，支点)，按照该对象的关键字大小，将整个序列划分为左右两个子序列：\n1. 左侧子序列中所有对象的关键字都小于或等于对象v的关键字；\n1. 右侧子序列中所有对象的关键字都大于或等于对象v的关键字；\n1. 对象v则排在这两个子序列中间(也是它最终的位置)\n\n**算法步骤**：首先选取一个基准元素(pivot)，基准元素可以任意选择，将基准元素与第一个元素交换。令i指向第一个元素，j指向最后一个元素,首先从最后一个元素开始向前遍历序列，遇到比pivot小的元素时，将j指向的值赋值给i指向的位置；然后i加1，从i开始向后遍历，直到遇到比pivot大的元素，赋值给j指向的位置；然后开始移动j....算法一直重复直到i==j，将pivot的值赋值给j指向的位置。到这一步就将序列分成左右两部分，左边部分小于等于pivot，右边部分大于等于pivot，递归执行上述步骤直到左右序列长度都为1\n\n### 讲解示例\n\n有数组如下：\n\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|30 | 2 | 87 | 25| 49 | 50 | 22| 12|\n\n> 令pivot = lists[0] = 30, i = 0, j = 7\n\n> j=7时，lists[7]=12 < pivot，lists[i]=lists[j]\n\n> 得到如下数组: [12, 2, 87, 25, 49, 50, 22, 12]\n\n> i++, i=1时，lists[1]=2 < pivot, i++\n\n> i=2时, lists[2]=87 > pivot, lists[j]=lists[i]\n\n> 得到如下数组：[12, 2, 87, 25, 49, 50, 22, 87]\n\n> j--, j=6, lists[6]=22 < pivot, lists[i]=lists[j]\n\n> 得到如下数组：[12, 2, 22, 25, 49, 50, 22, 87]\n\n> i++, i=3时，lists[i]=25 < pivot, i++\n\n> i=4时, lists[i]=49 > pivot, lists[j]=lists[i]\n\n> 得到如下数组: [12, 2, 22, 25, 49, 50, 49, 87]\n\n> j--, j=5时，lists[j]=50 > pivot, j--\n\n> j=4时, j == i,lists[j]=pivot\n\n> 得到如下数组：[12, 2, 22, 25, 30, 50, 49, 87]\n\n#### 代码\n\n```python\ndef quick_sort(lists, left, right):\n    if left < right:\n        i, j, pivot = left, right, lists[left]\n        while i < j:\n            while i < j:\n                if lists[j] < pivot:\n                    lists[i] = lists[j]\n                    break\n                j -= 1\n            while i < j:\n                if lists[i] > pivot:\n                    lists[j] = lists[i]\n                    break\n                i += 1\n        lists[j] = pivot\n        quick_sort(lists, left, j-1)\n        quick_sort(lists, j+1, right)\n``` \n\n#### 算法分析\n\n快速排序在实际应用中有最好的运行速度，平均时间复杂度为O(nlogn)，但是最坏的情况下位O(n^2)。至于为什么快速排序在时间复杂度为O(nlogn)的一些排序算法中速度最快，感兴趣的可以自己去查查资料。此外影响快速排序效率的关键就是Pivot的选择，常见的有取第一个，取最后一个，取前中后的中间数，pivot如果能正好将序列左右等分，那效率就是最高的。\n\n## 插入排序\n\n插入排序有多种变形算法，我介绍一下直接插入排序、折半插入排序和希尔排序，前两种算法只在插入的时候有些区别，总体思想是一致的。\n\n### 插入排序的思想\n\n> 1. 一个记录是有序的\n> 1. 从第二个记录开始，将每个记录插入到已排好序的序列中\n> 1. 一直进行到第n个记录\n\n### 直接插入排序\n\n直接插入排序第n次循环将下标为n的元素A插入合适的位置，将A依次与前一个元素B比较，若A>=B,则A不动，进入下一次循环；若A<B，则交换AB，重复上述操作。\n\n#### 代码\n\n```python\ndef direct_insert_sort(lists):\n    for i in range(1, len(lists)):\n        if lists[i] >= lists[i-1]:\n            continue\n        lists[i], lists[i-1] = lists[i-1], lists[i]\n        for j in range(i-1, 0, -1):\n            if lists[j] >= lists[j-1]:\n                break\n            lists[j], lists[j-1] = lists[j-1], lists[j]\n    \n```\n\n#### 算法分析\n\n1. 直接插入排序是稳定排序算法\n1. 时间复杂度：最好情况O(1),最坏O(n^2),平均O(n^2)\n1. 空间复杂度O(1)\n\n### 折半插入排序\n\n在插入排序中，第n次循环时，下标0到n-1的元素是有序的，可以用二分查找找到合适位置并插入第n个元素。\n\n#### 代码\n\n```python\ndef binary_insert_sort(lists):\n    for i in range(1, len(lists)):\n        if lists[i] >= lists[i-1]:\n            continue\n        # 折半查找\n        low, high = 0, i-1\n        while low <= high:\n            mid = (high + low) // 2\n            if lists[mid] > lists[i]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        for j in range(i, low, -1):\n            lists[j], lists[j-1] = lists[j-1], lists[j]\n```\n\n#### 算法分析\n\n为什么用low下标作为最终位置呢？可以看while循环的条件是low<=high，且是唯一跳出循环的条件，low与high只以1为增量，所以退出循环时low=high+1，但最后一次有效循环时，low与high与mid是相等的，如果lists[mid] > lists[i],则这个元素应该在mid前面，也就是low前面，如果lists[mid] <= lists[i]，则这个元素应该在mid后面，即low=mid+1这个位置。\n\n### 希尔排序\n\n希尔排序与直接插入算法大致过程是一样的，希尔排序需要进行多趟排序，先进行**宏观**排序，再进行**微观**排序。宏观调整指跳跃式的插入排序\n\n大致过程：\n\n1. 将数组分为若干个子序列进行插入排序\n\n> 例如：将N个记录分成d个子序列\n> {R[1], R[1+d], R[1+2d] ....}\n> {R[2], R[2+d], R[2+2d] ....}\n> ....\n> {R[d], R[d+d], R[d+2d] ....}\n\n2. 其中d为增量，他的值在排序过程中从大到小逐渐减少，最后一次排序变为1\n\n#### 代码\n\n```python\ndef shell_insert_sort(lists, dlta):\n    # para dlta: 增量d的序列，保证最后一个为1\n    for k in dlta:\n        shell_insert(lists, k)\n\n\ndef shell_insert(lists, step):\n    for i in range(step):\n        for j in range(i+step, len(lists), step):\n            if lists[j] >= lists[j-step]:\n                continue\n            lists[j], lists[j-step] = lists[j-step], lists[j]\n            for j in range(j-step, i+step-1, -step):\n                if lists[j] >= lists[j-step]:\n                    break\n                lists[j], lists[j-step] = lists[j-step], lists[j]\n```\n\n#### 算法分析\n\n希尔排序是不稳定的排序方法，即元素的相对顺序会改变。但是希尔排序的平均时间复杂度要比直接插入排序快一些，在O(n^1.3)与O(n^1.5)之间(来自教材)。希尔排序的优势在于减少了元素交换的次数，因为他可以以相对快的速度将大的数转移到数组的后面部分，取决于增量d的序列，因此增量d的序列的选择是算法效率好坏的关键。\n\n## 归并排序\n\n**基本思想**：（1）将N个记录看成n个长度为1的有序子表（2）将两两相邻的有序子表进行归并，若子表个数为奇数，最后一个子表进入下一次归并（3）重复步骤（2），直到归并成一个长度为N的有序表\n\n#### 代码\n\n```python\ndef merge_sort(lists):\n    step, length = 1, len(lists)\n    extend = [0 for i in range(length)]\n    while step < length*2:\n        start = 0\n        while start < length:\n            low, mid = start, min(start+step, length)\n            high, temp = min(start+step+step, length), low\n            start1, end1 = low, mid\n            start2, end2 = mid, high\n            while start1 < end1 and start2 < end2:\n                if lists[start1] < lists[start2]:\n                    extend[temp] = lists[start1]\n                    temp += 1\n                    start1 += 1\n                else:\n                    extend[temp] = lists[start2]\n                    temp += 1\n                    start2 += 1\n            while start1 < end1:\n                extend[temp] = lists[start1]\n                temp += 1\n                start1 += 1\n            while start2 < end2:\n                extend[temp] = lists[start2]\n                temp += 1\n                start2 += 1\n            start += 2 * step\n        lists, extend = extend, lists\n        step += step\n```\n\n#### 算法分析\n\n归并排序有两种方式，一种自上而下，一种自下而上，我的示例代码为自下而上，也称为2路归并。归并排序是一个稳定的排序方法，每趟归并耗费O(n)的时间，归并趟数为logn，所以时间复杂度为O(nlogn)。但是也使用了额外的存储空间，空间复杂度为O(n)。\n\n## 堆排序\n\n堆排序属于选择排序，出发点是利用前一次比较的结果，减少比较次数。\n\n了解堆排序首先需要知道堆的定义，这里用到的堆是完全二叉树，分为小根堆和大根堆。其中最大堆满足如下条件\n\n1. 父结点的值大于等于儿子结点\n\n2. 左右子树都是一个二叉堆\n\n因为待排序的一般是序列，用序列表示如下：\n> A[i] >= A[2*i+1] \n> 且 A[i] > A[2*i+2]\n\n#### 堆排序需要解决两个问题\n\n1. 由一个无序序列建成一个最大(小)堆\n\n1. 弹出堆顶元素，调整剩余元素成为新的堆\n\n#### 算法步骤（大根堆）\n\n1. 建立大根堆\n\n1. 输出堆顶元素，即lists[0]与最后一个未排序的元素交换，第一次为最后一个，第二次为倒数第二个......\n\n1. 交换后，未排序的元素不再满足大根堆的特性，重新建堆\n\n1. 重复2.3两步，知道排序完成\n\n#### 代码\n\n```python\ndef heap_sort(lists):\n    length = len(lists)\n    for i in range(length//2-1, -1, -1):\n        max_heap_adjust(lists, i, length)\n    for i in range(length-1, 0, -1):\n        lists[0], lists[i] = lists[i], lists[0]\n        max_heap_adjust(lists, 0, i)\n\ndef max_heap_adjust(lists, start, end):\n    while True:\n        imax, ileft, iright = start, 2*start+1, 2*start+2\n        if ileft < end and lists[start] < lists[ileft]:\n            imax = ileft\n        if iright < end and lists[imax] < lists[iright]:\n            imax = iright\n        if imax == start:\n            break\n        lists[start], lists[imax] = lists[imax], lists[start]\n        start = imax\n```\n\n#### 算法分析\n\n堆排序是不稳定的排序，时间复杂度为O(nlogn)。且最慢情况下也为O(nlogn)。\n\n这个算法需要对二叉树的一些特性有了解，不然边界情况很容易糊涂了，我自己写代码的时候少了一次循环，改来改去没发现，总觉得是对的，浪费了挺久时间。\n\n## 总结\n\n有些排序代码一下子写出来还是比较难的，但是算法更重要的是理解吧，毕竟写的这些排序算法也不太用的到,而且同样的思想和步骤也能写出不一样的代码，也会影响排序的快慢，开头也提到过了，高级语言的库里一般都自带排序算法，且速度更快，所以理解透彻就行了。下面我简单的以我写的代码测一下三个O(nlogn)时间复杂度的算法和Python内置sort()的速度快慢。序列全部random产生，同一组测试为同一个序列。\n\n### 10000个元素\n\n> <function merge_sort at 0x00000245EC6AA9D8> costs :  0.03701162338256836\n> <function quick_sort at 0x00000245EC6AAC80> costs :  0.025029897689819336\n> <function heap_sort at 0x00000245EC6AAAE8> costs :  0.05319356918334961\n> <function python_sort at 0x00000245EC6AAE18> costs :  0.002984762191772461\n\n### 50000个元素\n\n> <function merge_sort at 0x000002523ECCA9D8> costs :  0.21823906898498535\n> <function quick_sort at 0x000002523ECCAC80> costs :  0.1542985439300537\n> <function heap_sort at 0x000002523ECCAAE8> costs :  0.3872966766357422\n> <function python_sort at 0x000002523ECCAE18> costs :  0.016024351119995117\n\n### 100000个元素\n\n> <function merge_sort at 0x0000023023FBA9D8> costs :  0.4917008876800537\n> <function quick_sort at 0x0000023023FBAC80> costs :  0.3395521640777588\n> <function heap_sort at 0x0000023023FBAAE8> costs :  0.7686326503753662\n> <function python_sort at 0x0000023023FBAE18> costs :  0.03353142738342285\n\n可以看出python自带的排序sort()方法是远远快于我写的排序算法的。。。。不过快排确实是NlogN级别算法中速度最快的。","slug":"常用排序算法总结","published":1,"updated":"2019-02-03T07:16:46.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkll9000kuetuagj0tsna","content":"<p>排序算法非常的多，在学习数据结构和算法时肯定都会学习到关于排序的算法，虽然现在高级语言都自带内置的排序函数，但是理解一些常见排序算法的思想和适用场合也是非常重要的，这也是面试时的经典题目，所以准备找工作的我打算将这些算法复习和整理一遍，所有算法代码采用Python编写。（数组下标从0开始）</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序应该是第一个学习的排序算法吧，在学习C语言时就会学到，虽然效率比较低，但是在某些不需要全部排序的情况下也是很有效的，比如只需找出前3大的元素时。<br><a id=\"more\"></a></p>\n<h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ol>\n<li><p>从第一个记录开始，相邻记录两两比较，若前一个记录大于后一个记录，则交换</p>\n</li>\n<li><p>第一趟将序列中最大的记录放到了最后一个位置</p>\n</li>\n<li><p>n个记录比较n-1趟</p>\n</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(lists)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(lists)-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt; lists[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                lists[j], lists[j+<span class=\"number\">1</span>] = lists[j+<span class=\"number\">1</span>], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"优化冒泡代码\"><a href=\"#优化冒泡代码\" class=\"headerlink\" title=\"优化冒泡代码\"></a>优化冒泡代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(lists)):</span><br><span class=\"line\">        flag = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(lists)-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt; lists[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                flag = <span class=\"keyword\">False</span></span><br><span class=\"line\">                lists[j], lists[j+<span class=\"number\">1</span>] = lists[j+<span class=\"number\">1</span>], lists[j]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>冒泡排序是稳定的，时间复杂度很容易就看出是O(n^2)，所以是一个比较慢的排序算法。优化的冒泡排序是设置一个标识符，当flag为真时说明没有发生交换，则后面都为有序的，可以直接跳出循环。</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p><strong>基本思想</strong>：序列大小为N,则共进行N-1趟排序，第一趟选出最小的与第一个元素交换，第二趟在剩余的无序序列中选出最小的与第二个元素交换，一直进行N-1趟。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    length, i = len(lists), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; length<span class=\"number\">-1</span>:</span><br><span class=\"line\">        min_temp = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &lt; lists[min_temp]:</span><br><span class=\"line\">                min_temp = j</span><br><span class=\"line\">        lists[i], lists[min_temp] = lists[min_temp], lists[i]</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>时间复杂度O(n^2),算法是稳定的。选择排序与冒泡排序有点相似，每一轮排序结束时最大的元素将被放置到序列的一端，区别在于选择排序只交换一次，冒泡排序可能交换很多次。</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序之所以叫快速排序，那当然是因为他快了~</p>\n<p><strong>基本思想</strong>：任取待排序对象序列中的某个对象v(枢轴，基准，支点)，按照该对象的关键字大小，将整个序列划分为左右两个子序列：</p>\n<ol>\n<li>左侧子序列中所有对象的关键字都小于或等于对象v的关键字；</li>\n<li>右侧子序列中所有对象的关键字都大于或等于对象v的关键字；</li>\n<li>对象v则排在这两个子序列中间(也是它最终的位置)</li>\n</ol>\n<p><strong>算法步骤</strong>：首先选取一个基准元素(pivot)，基准元素可以任意选择，将基准元素与第一个元素交换。令i指向第一个元素，j指向最后一个元素,首先从最后一个元素开始向前遍历序列，遇到比pivot小的元素时，将j指向的值赋值给i指向的位置；然后i加1，从i开始向后遍历，直到遇到比pivot大的元素，赋值给j指向的位置；然后开始移动j….算法一直重复直到i==j，将pivot的值赋值给j指向的位置。到这一步就将序列分成左右两部分，左边部分小于等于pivot，右边部分大于等于pivot，递归执行上述步骤直到左右序列长度都为1</p>\n<h3 id=\"讲解示例\"><a href=\"#讲解示例\" class=\"headerlink\" title=\"讲解示例\"></a>讲解示例</h3><p>有数组如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">87</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">49</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>令pivot = lists[0] = 30, i = 0, j = 7</p>\n</blockquote>\n<blockquote>\n<p>j=7时，lists[7]=12 &lt; pivot，lists[i]=lists[j]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组: [12, 2, 87, 25, 49, 50, 22, 12]</p>\n</blockquote>\n<blockquote>\n<p>i++, i=1时，lists[1]=2 &lt; pivot, i++</p>\n</blockquote>\n<blockquote>\n<p>i=2时, lists[2]=87 &gt; pivot, lists[j]=lists[i]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组：[12, 2, 87, 25, 49, 50, 22, 87]</p>\n</blockquote>\n<blockquote>\n<p>j–, j=6, lists[6]=22 &lt; pivot, lists[i]=lists[j]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组：[12, 2, 22, 25, 49, 50, 22, 87]</p>\n</blockquote>\n<blockquote>\n<p>i++, i=3时，lists[i]=25 &lt; pivot, i++</p>\n</blockquote>\n<blockquote>\n<p>i=4时, lists[i]=49 &gt; pivot, lists[j]=lists[i]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组: [12, 2, 22, 25, 49, 50, 49, 87]</p>\n</blockquote>\n<blockquote>\n<p>j–, j=5时，lists[j]=50 &gt; pivot, j–</p>\n</blockquote>\n<blockquote>\n<p>j=4时, j == i,lists[j]=pivot</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组：[12, 2, 22, 25, 30, 50, 49, 87]</p>\n</blockquote>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(lists, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; right:</span><br><span class=\"line\">        i, j, pivot = left, right, lists[left]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[j] &lt; pivot:</span><br><span class=\"line\">                    lists[i] = lists[j]</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[i] &gt; pivot:</span><br><span class=\"line\">                    lists[j] = lists[i]</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        lists[j] = pivot</span><br><span class=\"line\">        quick_sort(lists, left, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">        quick_sort(lists, j+<span class=\"number\">1</span>, right)</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#### 算法分析</span></span><br><span class=\"line\"></span><br><span class=\"line\">快速排序在实际应用中有最好的运行速度，平均时间复杂度为O(nlogn)，但是最坏的情况下位O(n^<span class=\"number\">2</span>)。至于为什么快速排序在时间复杂度为O(nlogn)的一些排序算法中速度最快，感兴趣的可以自己去查查资料。此外影响快速排序效率的关键就是Pivot的选择，常见的有取第一个，取最后一个，取前中后的中间数，pivot如果能正好将序列左右等分，那效率就是最高的。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 插入排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">插入排序有多种变形算法，我介绍一下直接插入排序、折半插入排序和希尔排序，前两种算法只在插入的时候有些区别，总体思想是一致的。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 插入排序的思想</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; <span class=\"number\">1.</span> 一个记录是有序的</span><br><span class=\"line\">&gt; <span class=\"number\">1.</span> 从第二个记录开始，将每个记录插入到已排好序的序列中</span><br><span class=\"line\">&gt; <span class=\"number\">1.</span> 一直进行到第n个记录</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 直接插入排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">直接插入排序第n次循环将下标为n的元素A插入合适的位置，将A依次与前一个元素B比较，若A&gt;=B,则A不动，进入下一次循环；若A&lt;B，则交换AB，重复上述操作。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#### 代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">```python</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">direct_insert_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(lists)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists[i] &gt;= lists[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        lists[i], lists[i<span class=\"number\">-1</span>] = lists[i<span class=\"number\">-1</span>], lists[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt;= lists[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            lists[j], lists[j<span class=\"number\">-1</span>] = lists[j<span class=\"number\">-1</span>], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ol>\n<li>直接插入排序是稳定排序算法</li>\n<li>时间复杂度：最好情况O(1),最坏O(n^2),平均O(n^2)</li>\n<li>空间复杂度O(1)</li>\n</ol>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><p>在插入排序中，第n次循环时，下标0到n-1的元素是有序的，可以用二分查找找到合适位置并插入第n个元素。</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_insert_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(lists)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists[i] &gt;= lists[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"comment\"># 折半查找</span></span><br><span class=\"line\">        low, high = <span class=\"number\">0</span>, i<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">            mid = (high + low) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[mid] &gt; lists[i]:</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, low, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            lists[j], lists[j<span class=\"number\">-1</span>] = lists[j<span class=\"number\">-1</span>], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>为什么用low下标作为最终位置呢？可以看while循环的条件是low&lt;=high，且是唯一跳出循环的条件，low与high只以1为增量，所以退出循环时low=high+1，但最后一次有效循环时，low与high与mid是相等的，如果lists[mid] &gt; lists[i],则这个元素应该在mid前面，也就是low前面，如果lists[mid] &lt;= lists[i]，则这个元素应该在mid后面，即low=mid+1这个位置。</p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>希尔排序与直接插入算法大致过程是一样的，希尔排序需要进行多趟排序，先进行<strong>宏观</strong>排序，再进行<strong>微观</strong>排序。宏观调整指跳跃式的插入排序</p>\n<p>大致过程：</p>\n<ol>\n<li>将数组分为若干个子序列进行插入排序</li>\n</ol>\n<blockquote>\n<p>例如：将N个记录分成d个子序列<br>{R[1], R[1+d], R[1+2d] ….}<br>{R[2], R[2+d], R[2+2d] ….}<br>….<br>{R[d], R[d+d], R[d+2d] ….}</p>\n</blockquote>\n<ol start=\"2\">\n<li>其中d为增量，他的值在排序过程中从大到小逐渐减少，最后一次排序变为1</li>\n</ol>\n<h4 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_insert_sort</span><span class=\"params\">(lists, dlta)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># para dlta: 增量d的序列，保证最后一个为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dlta:</span><br><span class=\"line\">        shell_insert(lists, k)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_insert</span><span class=\"params\">(lists, step)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(step):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+step, len(lists), step):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt;= lists[j-step]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            lists[j], lists[j-step] = lists[j-step], lists[j]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(j-step, i+step<span class=\"number\">-1</span>, -step):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[j] &gt;= lists[j-step]:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                lists[j], lists[j-step] = lists[j-step], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>希尔排序是不稳定的排序方法，即元素的相对顺序会改变。但是希尔排序的平均时间复杂度要比直接插入排序快一些，在O(n^1.3)与O(n^1.5)之间(来自教材)。希尔排序的优势在于减少了元素交换的次数，因为他可以以相对快的速度将大的数转移到数组的后面部分，取决于增量d的序列，因此增量d的序列的选择是算法效率好坏的关键。</p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p><strong>基本思想</strong>：（1）将N个记录看成n个长度为1的有序子表（2）将两两相邻的有序子表进行归并，若子表个数为奇数，最后一个子表进入下一次归并（3）重复步骤（2），直到归并成一个长度为N的有序表</p>\n<h4 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    step, length = <span class=\"number\">1</span>, len(lists)</span><br><span class=\"line\">    extend = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> step &lt; length*<span class=\"number\">2</span>:</span><br><span class=\"line\">        start = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> start &lt; length:</span><br><span class=\"line\">            low, mid = start, min(start+step, length)</span><br><span class=\"line\">            high, temp = min(start+step+step, length), low</span><br><span class=\"line\">            start1, end1 = low, mid</span><br><span class=\"line\">            start2, end2 = mid, high</span><br><span class=\"line\">            <span class=\"keyword\">while</span> start1 &lt; end1 <span class=\"keyword\">and</span> start2 &lt; end2:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[start1] &lt; lists[start2]:</span><br><span class=\"line\">                    extend[temp] = lists[start1]</span><br><span class=\"line\">                    temp += <span class=\"number\">1</span></span><br><span class=\"line\">                    start1 += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    extend[temp] = lists[start2]</span><br><span class=\"line\">                    temp += <span class=\"number\">1</span></span><br><span class=\"line\">                    start2 += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> start1 &lt; end1:</span><br><span class=\"line\">                extend[temp] = lists[start1]</span><br><span class=\"line\">                temp += <span class=\"number\">1</span></span><br><span class=\"line\">                start1 += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> start2 &lt; end2:</span><br><span class=\"line\">                extend[temp] = lists[start2]</span><br><span class=\"line\">                temp += <span class=\"number\">1</span></span><br><span class=\"line\">                start2 += <span class=\"number\">1</span></span><br><span class=\"line\">            start += <span class=\"number\">2</span> * step</span><br><span class=\"line\">        lists, extend = extend, lists</span><br><span class=\"line\">        step += step</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-5\"><a href=\"#算法分析-5\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>归并排序有两种方式，一种自上而下，一种自下而上，我的示例代码为自下而上，也称为2路归并。归并排序是一个稳定的排序方法，每趟归并耗费O(n)的时间，归并趟数为logn，所以时间复杂度为O(nlogn)。但是也使用了额外的存储空间，空间复杂度为O(n)。</p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>堆排序属于选择排序，出发点是利用前一次比较的结果，减少比较次数。</p>\n<p>了解堆排序首先需要知道堆的定义，这里用到的堆是完全二叉树，分为小根堆和大根堆。其中最大堆满足如下条件</p>\n<ol>\n<li><p>父结点的值大于等于儿子结点</p>\n</li>\n<li><p>左右子树都是一个二叉堆</p>\n</li>\n</ol>\n<p>因为待排序的一般是序列，用序列表示如下：</p>\n<blockquote>\n<p>A[i] &gt;= A[2<em>i+1]<br>且 A[i] &gt; A[2</em>i+2]</p>\n</blockquote>\n<h4 id=\"堆排序需要解决两个问题\"><a href=\"#堆排序需要解决两个问题\" class=\"headerlink\" title=\"堆排序需要解决两个问题\"></a>堆排序需要解决两个问题</h4><ol>\n<li><p>由一个无序序列建成一个最大(小)堆</p>\n</li>\n<li><p>弹出堆顶元素，调整剩余元素成为新的堆</p>\n</li>\n</ol>\n<h4 id=\"算法步骤（大根堆）\"><a href=\"#算法步骤（大根堆）\" class=\"headerlink\" title=\"算法步骤（大根堆）\"></a>算法步骤（大根堆）</h4><ol>\n<li><p>建立大根堆</p>\n</li>\n<li><p>输出堆顶元素，即lists[0]与最后一个未排序的元素交换，第一次为最后一个，第二次为倒数第二个……</p>\n</li>\n<li><p>交换后，未排序的元素不再满足大根堆的特性，重新建堆</p>\n</li>\n<li><p>重复2.3两步，知道排序完成</p>\n</li>\n</ol>\n<h4 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    length = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length//<span class=\"number\">2</span><span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        max_heap_adjust(lists, i, length)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        lists[<span class=\"number\">0</span>], lists[i] = lists[i], lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        max_heap_adjust(lists, <span class=\"number\">0</span>, i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heap_adjust</span><span class=\"params\">(lists, start, end)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        imax, ileft, iright = start, <span class=\"number\">2</span>*start+<span class=\"number\">1</span>, <span class=\"number\">2</span>*start+<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ileft &lt; end <span class=\"keyword\">and</span> lists[start] &lt; lists[ileft]:</span><br><span class=\"line\">            imax = ileft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> iright &lt; end <span class=\"keyword\">and</span> lists[imax] &lt; lists[iright]:</span><br><span class=\"line\">            imax = iright</span><br><span class=\"line\">        <span class=\"keyword\">if</span> imax == start:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        lists[start], lists[imax] = lists[imax], lists[start]</span><br><span class=\"line\">        start = imax</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-6\"><a href=\"#算法分析-6\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>堆排序是不稳定的排序，时间复杂度为O(nlogn)。且最慢情况下也为O(nlogn)。</p>\n<p>这个算法需要对二叉树的一些特性有了解，不然边界情况很容易糊涂了，我自己写代码的时候少了一次循环，改来改去没发现，总觉得是对的，浪费了挺久时间。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>有些排序代码一下子写出来还是比较难的，但是算法更重要的是理解吧，毕竟写的这些排序算法也不太用的到,而且同样的思想和步骤也能写出不一样的代码，也会影响排序的快慢，开头也提到过了，高级语言的库里一般都自带排序算法，且速度更快，所以理解透彻就行了。下面我简单的以我写的代码测一下三个O(nlogn)时间复杂度的算法和Python内置sort()的速度快慢。序列全部random产生，同一组测试为同一个序列。</p>\n<h3 id=\"10000个元素\"><a href=\"#10000个元素\" class=\"headerlink\" title=\"10000个元素\"></a>10000个元素</h3><blockquote>\n<p><function merge_sort=\"\" at=\"\" 0x00000245ec6aa9d8=\"\"> costs :  0.03701162338256836</function></p>\n<p><function quick_sort=\"\" at=\"\" 0x00000245ec6aac80=\"\"> costs :  0.025029897689819336</function></p>\n<p><function heap_sort=\"\" at=\"\" 0x00000245ec6aaae8=\"\"> costs :  0.05319356918334961</function></p>\n<p><function python_sort=\"\" at=\"\" 0x00000245ec6aae18=\"\"> costs :  0.002984762191772461</function></p>\n</blockquote>\n<h3 id=\"50000个元素\"><a href=\"#50000个元素\" class=\"headerlink\" title=\"50000个元素\"></a>50000个元素</h3><blockquote>\n<p><function merge_sort=\"\" at=\"\" 0x000002523ecca9d8=\"\"> costs :  0.21823906898498535</function></p>\n<p><function quick_sort=\"\" at=\"\" 0x000002523eccac80=\"\"> costs :  0.1542985439300537</function></p>\n<p><function heap_sort=\"\" at=\"\" 0x000002523eccaae8=\"\"> costs :  0.3872966766357422</function></p>\n<p><function python_sort=\"\" at=\"\" 0x000002523eccae18=\"\"> costs :  0.016024351119995117</function></p>\n</blockquote>\n<h3 id=\"100000个元素\"><a href=\"#100000个元素\" class=\"headerlink\" title=\"100000个元素\"></a>100000个元素</h3><blockquote>\n<p><function merge_sort=\"\" at=\"\" 0x0000023023fba9d8=\"\"> costs :  0.4917008876800537</function></p>\n<p><function quick_sort=\"\" at=\"\" 0x0000023023fbac80=\"\"> costs :  0.3395521640777588</function></p>\n<p><function heap_sort=\"\" at=\"\" 0x0000023023fbaae8=\"\"> costs :  0.7686326503753662</function></p>\n<p><function python_sort=\"\" at=\"\" 0x0000023023fbae18=\"\"> costs :  0.03353142738342285</function></p>\n</blockquote>\n<p>可以看出python自带的排序sort()方法是远远快于我写的排序算法的。。。。不过快排确实是NlogN级别算法中速度最快的。</p>\n","site":{"data":{}},"excerpt":"<p>排序算法非常的多，在学习数据结构和算法时肯定都会学习到关于排序的算法，虽然现在高级语言都自带内置的排序函数，但是理解一些常见排序算法的思想和适用场合也是非常重要的，这也是面试时的经典题目，所以准备找工作的我打算将这些算法复习和整理一遍，所有算法代码采用Python编写。（数组下标从0开始）</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序应该是第一个学习的排序算法吧，在学习C语言时就会学到，虽然效率比较低，但是在某些不需要全部排序的情况下也是很有效的，比如只需找出前3大的元素时。<br>","more":"</p>\n<h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ol>\n<li><p>从第一个记录开始，相邻记录两两比较，若前一个记录大于后一个记录，则交换</p>\n</li>\n<li><p>第一趟将序列中最大的记录放到了最后一个位置</p>\n</li>\n<li><p>n个记录比较n-1趟</p>\n</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(lists)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(lists)-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt; lists[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                lists[j], lists[j+<span class=\"number\">1</span>] = lists[j+<span class=\"number\">1</span>], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"优化冒泡代码\"><a href=\"#优化冒泡代码\" class=\"headerlink\" title=\"优化冒泡代码\"></a>优化冒泡代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(lists)):</span><br><span class=\"line\">        flag = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(lists)-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt; lists[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                flag = <span class=\"keyword\">False</span></span><br><span class=\"line\">                lists[j], lists[j+<span class=\"number\">1</span>] = lists[j+<span class=\"number\">1</span>], lists[j]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>冒泡排序是稳定的，时间复杂度很容易就看出是O(n^2)，所以是一个比较慢的排序算法。优化的冒泡排序是设置一个标识符，当flag为真时说明没有发生交换，则后面都为有序的，可以直接跳出循环。</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p><strong>基本思想</strong>：序列大小为N,则共进行N-1趟排序，第一趟选出最小的与第一个元素交换，第二趟在剩余的无序序列中选出最小的与第二个元素交换，一直进行N-1趟。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    length, i = len(lists), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; length<span class=\"number\">-1</span>:</span><br><span class=\"line\">        min_temp = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &lt; lists[min_temp]:</span><br><span class=\"line\">                min_temp = j</span><br><span class=\"line\">        lists[i], lists[min_temp] = lists[min_temp], lists[i]</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>时间复杂度O(n^2),算法是稳定的。选择排序与冒泡排序有点相似，每一轮排序结束时最大的元素将被放置到序列的一端，区别在于选择排序只交换一次，冒泡排序可能交换很多次。</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序之所以叫快速排序，那当然是因为他快了~</p>\n<p><strong>基本思想</strong>：任取待排序对象序列中的某个对象v(枢轴，基准，支点)，按照该对象的关键字大小，将整个序列划分为左右两个子序列：</p>\n<ol>\n<li>左侧子序列中所有对象的关键字都小于或等于对象v的关键字；</li>\n<li>右侧子序列中所有对象的关键字都大于或等于对象v的关键字；</li>\n<li>对象v则排在这两个子序列中间(也是它最终的位置)</li>\n</ol>\n<p><strong>算法步骤</strong>：首先选取一个基准元素(pivot)，基准元素可以任意选择，将基准元素与第一个元素交换。令i指向第一个元素，j指向最后一个元素,首先从最后一个元素开始向前遍历序列，遇到比pivot小的元素时，将j指向的值赋值给i指向的位置；然后i加1，从i开始向后遍历，直到遇到比pivot大的元素，赋值给j指向的位置；然后开始移动j….算法一直重复直到i==j，将pivot的值赋值给j指向的位置。到这一步就将序列分成左右两部分，左边部分小于等于pivot，右边部分大于等于pivot，递归执行上述步骤直到左右序列长度都为1</p>\n<h3 id=\"讲解示例\"><a href=\"#讲解示例\" class=\"headerlink\" title=\"讲解示例\"></a>讲解示例</h3><p>有数组如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">87</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">49</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>令pivot = lists[0] = 30, i = 0, j = 7</p>\n</blockquote>\n<blockquote>\n<p>j=7时，lists[7]=12 &lt; pivot，lists[i]=lists[j]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组: [12, 2, 87, 25, 49, 50, 22, 12]</p>\n</blockquote>\n<blockquote>\n<p>i++, i=1时，lists[1]=2 &lt; pivot, i++</p>\n</blockquote>\n<blockquote>\n<p>i=2时, lists[2]=87 &gt; pivot, lists[j]=lists[i]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组：[12, 2, 87, 25, 49, 50, 22, 87]</p>\n</blockquote>\n<blockquote>\n<p>j–, j=6, lists[6]=22 &lt; pivot, lists[i]=lists[j]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组：[12, 2, 22, 25, 49, 50, 22, 87]</p>\n</blockquote>\n<blockquote>\n<p>i++, i=3时，lists[i]=25 &lt; pivot, i++</p>\n</blockquote>\n<blockquote>\n<p>i=4时, lists[i]=49 &gt; pivot, lists[j]=lists[i]</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组: [12, 2, 22, 25, 49, 50, 49, 87]</p>\n</blockquote>\n<blockquote>\n<p>j–, j=5时，lists[j]=50 &gt; pivot, j–</p>\n</blockquote>\n<blockquote>\n<p>j=4时, j == i,lists[j]=pivot</p>\n</blockquote>\n<blockquote>\n<p>得到如下数组：[12, 2, 22, 25, 30, 50, 49, 87]</p>\n</blockquote>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(lists, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; right:</span><br><span class=\"line\">        i, j, pivot = left, right, lists[left]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[j] &lt; pivot:</span><br><span class=\"line\">                    lists[i] = lists[j]</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[i] &gt; pivot:</span><br><span class=\"line\">                    lists[j] = lists[i]</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        lists[j] = pivot</span><br><span class=\"line\">        quick_sort(lists, left, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">        quick_sort(lists, j+<span class=\"number\">1</span>, right)</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#### 算法分析</span></span><br><span class=\"line\"></span><br><span class=\"line\">快速排序在实际应用中有最好的运行速度，平均时间复杂度为O(nlogn)，但是最坏的情况下位O(n^<span class=\"number\">2</span>)。至于为什么快速排序在时间复杂度为O(nlogn)的一些排序算法中速度最快，感兴趣的可以自己去查查资料。此外影响快速排序效率的关键就是Pivot的选择，常见的有取第一个，取最后一个，取前中后的中间数，pivot如果能正好将序列左右等分，那效率就是最高的。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 插入排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">插入排序有多种变形算法，我介绍一下直接插入排序、折半插入排序和希尔排序，前两种算法只在插入的时候有些区别，总体思想是一致的。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 插入排序的思想</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; <span class=\"number\">1.</span> 一个记录是有序的</span><br><span class=\"line\">&gt; <span class=\"number\">1.</span> 从第二个记录开始，将每个记录插入到已排好序的序列中</span><br><span class=\"line\">&gt; <span class=\"number\">1.</span> 一直进行到第n个记录</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 直接插入排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">直接插入排序第n次循环将下标为n的元素A插入合适的位置，将A依次与前一个元素B比较，若A&gt;=B,则A不动，进入下一次循环；若A&lt;B，则交换AB，重复上述操作。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#### 代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">```python</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">direct_insert_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(lists)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists[i] &gt;= lists[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        lists[i], lists[i<span class=\"number\">-1</span>] = lists[i<span class=\"number\">-1</span>], lists[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt;= lists[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            lists[j], lists[j<span class=\"number\">-1</span>] = lists[j<span class=\"number\">-1</span>], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ol>\n<li>直接插入排序是稳定排序算法</li>\n<li>时间复杂度：最好情况O(1),最坏O(n^2),平均O(n^2)</li>\n<li>空间复杂度O(1)</li>\n</ol>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><p>在插入排序中，第n次循环时，下标0到n-1的元素是有序的，可以用二分查找找到合适位置并插入第n个元素。</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_insert_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(lists)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists[i] &gt;= lists[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"comment\"># 折半查找</span></span><br><span class=\"line\">        low, high = <span class=\"number\">0</span>, i<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">            mid = (high + low) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[mid] &gt; lists[i]:</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, low, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            lists[j], lists[j<span class=\"number\">-1</span>] = lists[j<span class=\"number\">-1</span>], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>为什么用low下标作为最终位置呢？可以看while循环的条件是low&lt;=high，且是唯一跳出循环的条件，low与high只以1为增量，所以退出循环时low=high+1，但最后一次有效循环时，low与high与mid是相等的，如果lists[mid] &gt; lists[i],则这个元素应该在mid前面，也就是low前面，如果lists[mid] &lt;= lists[i]，则这个元素应该在mid后面，即low=mid+1这个位置。</p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>希尔排序与直接插入算法大致过程是一样的，希尔排序需要进行多趟排序，先进行<strong>宏观</strong>排序，再进行<strong>微观</strong>排序。宏观调整指跳跃式的插入排序</p>\n<p>大致过程：</p>\n<ol>\n<li>将数组分为若干个子序列进行插入排序</li>\n</ol>\n<blockquote>\n<p>例如：将N个记录分成d个子序列<br>{R[1], R[1+d], R[1+2d] ….}<br>{R[2], R[2+d], R[2+2d] ….}<br>….<br>{R[d], R[d+d], R[d+2d] ….}</p>\n</blockquote>\n<ol start=\"2\">\n<li>其中d为增量，他的值在排序过程中从大到小逐渐减少，最后一次排序变为1</li>\n</ol>\n<h4 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_insert_sort</span><span class=\"params\">(lists, dlta)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># para dlta: 增量d的序列，保证最后一个为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dlta:</span><br><span class=\"line\">        shell_insert(lists, k)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_insert</span><span class=\"params\">(lists, step)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(step):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+step, len(lists), step):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[j] &gt;= lists[j-step]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            lists[j], lists[j-step] = lists[j-step], lists[j]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(j-step, i+step<span class=\"number\">-1</span>, -step):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[j] &gt;= lists[j-step]:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                lists[j], lists[j-step] = lists[j-step], lists[j]</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>希尔排序是不稳定的排序方法，即元素的相对顺序会改变。但是希尔排序的平均时间复杂度要比直接插入排序快一些，在O(n^1.3)与O(n^1.5)之间(来自教材)。希尔排序的优势在于减少了元素交换的次数，因为他可以以相对快的速度将大的数转移到数组的后面部分，取决于增量d的序列，因此增量d的序列的选择是算法效率好坏的关键。</p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p><strong>基本思想</strong>：（1）将N个记录看成n个长度为1的有序子表（2）将两两相邻的有序子表进行归并，若子表个数为奇数，最后一个子表进入下一次归并（3）重复步骤（2），直到归并成一个长度为N的有序表</p>\n<h4 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    step, length = <span class=\"number\">1</span>, len(lists)</span><br><span class=\"line\">    extend = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> step &lt; length*<span class=\"number\">2</span>:</span><br><span class=\"line\">        start = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> start &lt; length:</span><br><span class=\"line\">            low, mid = start, min(start+step, length)</span><br><span class=\"line\">            high, temp = min(start+step+step, length), low</span><br><span class=\"line\">            start1, end1 = low, mid</span><br><span class=\"line\">            start2, end2 = mid, high</span><br><span class=\"line\">            <span class=\"keyword\">while</span> start1 &lt; end1 <span class=\"keyword\">and</span> start2 &lt; end2:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> lists[start1] &lt; lists[start2]:</span><br><span class=\"line\">                    extend[temp] = lists[start1]</span><br><span class=\"line\">                    temp += <span class=\"number\">1</span></span><br><span class=\"line\">                    start1 += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    extend[temp] = lists[start2]</span><br><span class=\"line\">                    temp += <span class=\"number\">1</span></span><br><span class=\"line\">                    start2 += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> start1 &lt; end1:</span><br><span class=\"line\">                extend[temp] = lists[start1]</span><br><span class=\"line\">                temp += <span class=\"number\">1</span></span><br><span class=\"line\">                start1 += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> start2 &lt; end2:</span><br><span class=\"line\">                extend[temp] = lists[start2]</span><br><span class=\"line\">                temp += <span class=\"number\">1</span></span><br><span class=\"line\">                start2 += <span class=\"number\">1</span></span><br><span class=\"line\">            start += <span class=\"number\">2</span> * step</span><br><span class=\"line\">        lists, extend = extend, lists</span><br><span class=\"line\">        step += step</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-5\"><a href=\"#算法分析-5\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>归并排序有两种方式，一种自上而下，一种自下而上，我的示例代码为自下而上，也称为2路归并。归并排序是一个稳定的排序方法，每趟归并耗费O(n)的时间，归并趟数为logn，所以时间复杂度为O(nlogn)。但是也使用了额外的存储空间，空间复杂度为O(n)。</p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>堆排序属于选择排序，出发点是利用前一次比较的结果，减少比较次数。</p>\n<p>了解堆排序首先需要知道堆的定义，这里用到的堆是完全二叉树，分为小根堆和大根堆。其中最大堆满足如下条件</p>\n<ol>\n<li><p>父结点的值大于等于儿子结点</p>\n</li>\n<li><p>左右子树都是一个二叉堆</p>\n</li>\n</ol>\n<p>因为待排序的一般是序列，用序列表示如下：</p>\n<blockquote>\n<p>A[i] &gt;= A[2<em>i+1]<br>且 A[i] &gt; A[2</em>i+2]</p>\n</blockquote>\n<h4 id=\"堆排序需要解决两个问题\"><a href=\"#堆排序需要解决两个问题\" class=\"headerlink\" title=\"堆排序需要解决两个问题\"></a>堆排序需要解决两个问题</h4><ol>\n<li><p>由一个无序序列建成一个最大(小)堆</p>\n</li>\n<li><p>弹出堆顶元素，调整剩余元素成为新的堆</p>\n</li>\n</ol>\n<h4 id=\"算法步骤（大根堆）\"><a href=\"#算法步骤（大根堆）\" class=\"headerlink\" title=\"算法步骤（大根堆）\"></a>算法步骤（大根堆）</h4><ol>\n<li><p>建立大根堆</p>\n</li>\n<li><p>输出堆顶元素，即lists[0]与最后一个未排序的元素交换，第一次为最后一个，第二次为倒数第二个……</p>\n</li>\n<li><p>交换后，未排序的元素不再满足大根堆的特性，重新建堆</p>\n</li>\n<li><p>重复2.3两步，知道排序完成</p>\n</li>\n</ol>\n<h4 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_sort</span><span class=\"params\">(lists)</span>:</span></span><br><span class=\"line\">    length = len(lists)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length//<span class=\"number\">2</span><span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        max_heap_adjust(lists, i, length)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        lists[<span class=\"number\">0</span>], lists[i] = lists[i], lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        max_heap_adjust(lists, <span class=\"number\">0</span>, i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heap_adjust</span><span class=\"params\">(lists, start, end)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        imax, ileft, iright = start, <span class=\"number\">2</span>*start+<span class=\"number\">1</span>, <span class=\"number\">2</span>*start+<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ileft &lt; end <span class=\"keyword\">and</span> lists[start] &lt; lists[ileft]:</span><br><span class=\"line\">            imax = ileft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> iright &lt; end <span class=\"keyword\">and</span> lists[imax] &lt; lists[iright]:</span><br><span class=\"line\">            imax = iright</span><br><span class=\"line\">        <span class=\"keyword\">if</span> imax == start:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        lists[start], lists[imax] = lists[imax], lists[start]</span><br><span class=\"line\">        start = imax</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-6\"><a href=\"#算法分析-6\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><p>堆排序是不稳定的排序，时间复杂度为O(nlogn)。且最慢情况下也为O(nlogn)。</p>\n<p>这个算法需要对二叉树的一些特性有了解，不然边界情况很容易糊涂了，我自己写代码的时候少了一次循环，改来改去没发现，总觉得是对的，浪费了挺久时间。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>有些排序代码一下子写出来还是比较难的，但是算法更重要的是理解吧，毕竟写的这些排序算法也不太用的到,而且同样的思想和步骤也能写出不一样的代码，也会影响排序的快慢，开头也提到过了，高级语言的库里一般都自带排序算法，且速度更快，所以理解透彻就行了。下面我简单的以我写的代码测一下三个O(nlogn)时间复杂度的算法和Python内置sort()的速度快慢。序列全部random产生，同一组测试为同一个序列。</p>\n<h3 id=\"10000个元素\"><a href=\"#10000个元素\" class=\"headerlink\" title=\"10000个元素\"></a>10000个元素</h3><blockquote>\n<p><function merge_sort=\"\" at=\"\" 0x00000245ec6aa9d8=\"\"> costs :  0.03701162338256836</function></p>\n<p><function quick_sort=\"\" at=\"\" 0x00000245ec6aac80=\"\"> costs :  0.025029897689819336</function></p>\n<p><function heap_sort=\"\" at=\"\" 0x00000245ec6aaae8=\"\"> costs :  0.05319356918334961</function></p>\n<p><function python_sort=\"\" at=\"\" 0x00000245ec6aae18=\"\"> costs :  0.002984762191772461</function></p>\n</blockquote>\n<h3 id=\"50000个元素\"><a href=\"#50000个元素\" class=\"headerlink\" title=\"50000个元素\"></a>50000个元素</h3><blockquote>\n<p><function merge_sort=\"\" at=\"\" 0x000002523ecca9d8=\"\"> costs :  0.21823906898498535</function></p>\n<p><function quick_sort=\"\" at=\"\" 0x000002523eccac80=\"\"> costs :  0.1542985439300537</function></p>\n<p><function heap_sort=\"\" at=\"\" 0x000002523eccaae8=\"\"> costs :  0.3872966766357422</function></p>\n<p><function python_sort=\"\" at=\"\" 0x000002523eccae18=\"\"> costs :  0.016024351119995117</function></p>\n</blockquote>\n<h3 id=\"100000个元素\"><a href=\"#100000个元素\" class=\"headerlink\" title=\"100000个元素\"></a>100000个元素</h3><blockquote>\n<p><function merge_sort=\"\" at=\"\" 0x0000023023fba9d8=\"\"> costs :  0.4917008876800537</function></p>\n<p><function quick_sort=\"\" at=\"\" 0x0000023023fbac80=\"\"> costs :  0.3395521640777588</function></p>\n<p><function heap_sort=\"\" at=\"\" 0x0000023023fbaae8=\"\"> costs :  0.7686326503753662</function></p>\n<p><function python_sort=\"\" at=\"\" 0x0000023023fbae18=\"\"> costs :  0.03353142738342285</function></p>\n</blockquote>\n<p>可以看出python自带的排序sort()方法是远远快于我写的排序算法的。。。。不过快排确实是NlogN级别算法中速度最快的。</p>"},{"title":"Java集合源码系列-HashMap","date":"2019-01-12T03:05:57.000Z","_content":"\n### 前言\n\nJava基础是面试中的重中之重，尤其是对集合类，并发包等源码的相关的问题是面试中常考察的点。但是其实这些点并不难，对于计算机专业的学生来说，如果上过数据结构这门课，对数组，字符串，链表以及字典的大致实现都有一定了解，在阅读JDK源码时也会发现，整体的思路是和所学的数据结构一样的，所以理解源码的整体框架不难，但是不能总是浮于表面，需要理解JDK在一些细节处理上的针对性\b优化措施。\n<!--more-->\n网上关于源码解析的博客有很多，也给我提供了很大的帮助。阅读源码时不懂是很正常的情况，可以借助google或baidu来解决遇到的问题。看了那么多博客，自己也想总结出一个源码系列，一是因为基础知识很重要，但是容易遗忘，做一个定期的总结可以让自己将来有机会温习，同时加深自己的理解。二是做一个分享，希望可以收获更多的读者_(:3」∠)_\n\n作为系列的第一篇文章，说一下文章的整体思路。因为是介绍集合类的源码，所以以使用集合的整个生命周期来作为行文路线，即创建对象-->添加元素-->获取元素-->删除元素。\b 整个系列，如果没有\b特殊说明，则都是JDK8版源码.\n\n### 概览\n\nMap的底层存储一般都是数组，\b因为数组可以满足常数时间内进行**get**和**put**操作。而数组的下标一般是由一个哈希函数来获得，在常见的数据结构教材中，一般为对数组长度取模，\b可以保证\b哈希函数得到的index范围在[0，len-1]之间，不会数组越界，并且可以利用到数组的所有位置。\b除了取模这种hash算法，还有很多其他的算法，各有优劣。\n\n除了hash算法，一个Map实现还需要解决index重复的问题，常见的有再hash法，开放地址法\b，拉链法等；而HashMap可以看做是一个优化过的拉链法。\n\n解决了如何计算hash和解决冲突后，还需要面临的一个问题是，数组的大小都是固定的，那么随着Map存的数据越来越多，同一个下标存储的数据越来越多，存取的性能退化为O(n),数组如何动态的调整其大小来改善性能呢;HashMap通过一个叫做负载因子的变量来控制调整的时机。\n\n带着这几个问题，下面一起来阅读一下HashMap的源码吧～\n\n### 构造函数\n\n使用集合类的第一步就是通过构造函数，HashMap的构造函数有多个，但其实类似，将从最常见的展开，顺带着其余的构造函数。\n\n```java\n/**\n * loadFactor即为前面提到的负载因子，默认值为0.75，这是最普通的、最常用的构造函数，所有内部参数都使用默认值，关于一些参数，\b后面用到时再详细介绍\n */\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; //\b 负载因子默认值\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n}\n/**\n * 指定\b构建对象的底层数组大小和负载因子。默认值分别为16和0.75.对传入的参数有一点限制，底层数组必须大于0小于最大容量(2的30次方)，并且会被调整为2的整数幂，原因后续介绍。通过tableSizeFor函数调整。\n */\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" + \n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n//通过巧妙的位运算，将指定的cap变为大于等于cap的第一个2的幂次方整数，源码中多次利用位运算来进行速度优化\n// n =       000..1XXXXXX假设n的二进制格式，1代表第一个1出现的位置，x为任意的0或1\n// n >>> 1 = 000..01xxxxx\n// 新n     = 000..11xxxxx \n// n >>> 2 = 000..0011xxx\n// 新n或运算 = 000..1111xxx\n// 因为cap传进来时最大为2的30次方，所以最多只要16的时候，就可以保证第一次出现1的位置后面全变为1，即n = 000..00111111，那么在返回时通过n+1的操作，\b使n=000.01000000的形式，保证返回值是2的n次方\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n// 用一个已经存在的map初始化，用的不多，就在代码中稍微写点注释\npublic HashMap(Map<? extends K, ? extends V> m) {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, false);\n}\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        if (table == null) { // 如果数组还没分配，根据m的大小\b建立合适大小的数组\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                (int)ft : MAXIMUM_CAPACITY);\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        else if (s > threshold) // 如果m的大小超过table大小，则扩容，resize()后面介绍\n            resize();\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n\n### 添加元素\n\n介绍完构造函数后现在介绍下如何添加元素，那么在这之前，需要先了解一下HashMap用了什么结构来保存数据\n\n```java\ntransient Node<K,V>[] table; // HashMap中的table属性用来保存数组，数组元素本身的结构为Node,是一个静态内部类\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; // 存储hash值，空间换时间，减少重复计算\n    final K key;    // 字典的key\n    V value;        // 字典的value\n    Node<K,V> next; // 前面提到,HashMap使用优化过的拉链法解决Hash冲突，即所有Hash值相同的key通过链表连接，可以看出极端情况get性能会退回为O(N)，所以后面会介绍如何优化，暂时理解为一个简单的链表\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    // 省略get, set, equal, toString....\n}\n```\n\n接下来看下put方法的逻辑：\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true); // hash方法求key的index\n}\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); // 充分利用高16位以及低16位求hash，避免连续的key产生的hash值具有规律性\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0) // table懒加载，第一次存值时才初始化数组\n        n = (tab = resize()).length; // 初始化数组，分配给tab变量，resize()后面介绍，返回值为新分配的数组，n为新数组长度\n    if ((p = tab[i = (n - 1) & hash]) == null) // i = (n-1) & hash求出元素下标，前面介绍了字典一般是通过对数组的大小去\b取模求得数组的下标，但是cpu更擅长的是位运算，而前面提到了数组的大小肯定是2的整数次方，即n的二进制格式为00.100..000，那么n-1即为00.011..111的,对这样的一个数进行与运算的结果集就是0到n-1，效果与除法取模一样，但是速度大幅度提升\n        tab[i] = newNode(hash, key, value, null); // 如果指定下标不存在元素，在下标为i的地方插入新值, newNode方法生成一个Node对象并返回\n    else { // 如果指定下标已经存在元素，进入该分支\n        Node<K,V> e; K k;\n        // p为指定下标i位置上的Node元素\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k)))) // 如果p指向的节点的key与新put进来的key一样\n            e = p;\n        else if (p instanceof TreeNode) // 如果p指向的节点的key与新Put进来的key不一样，且是TreeNode实例\n            // 前面介绍过，HashMap的拉链法是优化过的，就体现在这。如果同一个数组跟着的链表长度大于8，会转化为红黑树，红黑树是一种平衡树，平均复杂度为O(logn),优于链表的O(n)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // TreeNode版的putVal方法\n        else { // key应该在链表中的情况\n            for (int binCount = 0; ; ++binCount) { // 遍历链表\n                if ((e = p.next) == null) { // 如果遍历完链表还没找到相同的key，则key为新的值，添加到链表尾端\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // 如果节点数大于8，则转换为红黑树结构 TREEIFY_THRESHOLD=8\n                        treeifyBin(tab, hash); // 将链表转换为红黑树\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k)))) // put进来的key已经存在，指向Node e\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // put 进来的key已经存在，将value替换\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null) // @param onlyIfAbsent if true, don't change existing value\n                e.value = value;\n            afterNodeAccess(e); // 方法为空，无操作\n            return oldValue;\n        }\n    }\n    // 如果key是新的值，则进入这里，否则直接返回\n    ++modCount; // 改变量记录了对map添加和删除的次数\n    if (++size > threshold) // threshold为扩容门槛，如果没有指定，在第一次进行resize()时被置为capacity * load factor，即16*0.75\n        resize(); // size记录了table包含的key,value对的数量\n    afterNodeInsertion(evict); // 改方法为空，无操作\n    return null;\n}\n```\n\n上面就是关于添加元素的部分了，但是对于优化为红黑树的部分没有进行深入介绍。因为红黑树本身的数据结构就比较复杂，不易理解，对红黑树进行插入，平衡，查找的相关操作跟map的关系已经不大，如果有兴趣，可以另外找时间网上搜索一下。需要知道的就是红黑树主要解决的问题是当哈希冲突太多时，链表的查询性能变为O(n),用红黑树替代后可以降低到O(logn)的复杂度，且当链表长度8时才进行这个转变；后面会提到resize()时如果节点数量小于6时，红黑树也会退化为链表。接下来介绍一下前面省略掉的`resize()`方法：\n\n#### resize()方法\n\n```java\nfinal Node<K,V>[] resize() { // size超过capacity * load_factory时进行扩容\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) { // 如果已经达到最大的size：2的30次方，不再扩容，直接返回旧table\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY) // 如果旧的容量*2小于2的30次方且旧的容量大于16时将数组大小翻倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // table数组还没创建且threshold>0时，将capacity设为threshold\n        newCap = oldThr;\n    else {               // table数组还没创建，将capacity设为16，扩容阈值设为16*0.75\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) { // 设置新的扩容阈值\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr; // threshold重新赋值\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; // 申请一个新的数组，大小为原来数组的两倍\n    table = newTab;  // table变量指向新数组\n    if (oldTab != null) { \n        for (int j = 0; j < oldCap; ++j) { // 遍历旧的数组\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) { // 旧数组对应的下标j不为空时，将该下标的元素转移到新数组中\n                oldTab[j] = null; // 加速GC？猜测\n                if (e.next == null) // 如果对应的下标j只有一个元素，将该元素放到新数组 e.hash & (newCap - 1)处\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode) // 如果下标j对应的Node是红黑树节点\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); // 在split函数中，如果节点数量小于static final int UNTREEIFY_THRESHOLD = 6；退化为链表\n                else { // 链表Node\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do { // do-while循环，将链表根据重新e.hash & oldCap是否等于0，分成两个子链表\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) { // oldCap二进制为00.100.00的格式，是2的整数次方，只有1个1\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 按照新的table大小来计算数组下标时，算式应该是这样的：e.hash & (oldCap*2-1),假设oldCap为16， 则二进制表示为10,000，oldCap*2=32的\b二进制为100,000\n                    // 那么上面do-while循环中(e.hash & oldCap) == 0的分支，hash值格式为xx..xx0x,xxx(从右往左第5个数是0，其他任意),与（32-1）做&运算的以及与（15-1）做&运算的结果分别是：\n                    // （32-1）xx.xx0x,xxx ---- (16-1)xx.xx0x,xxx\n                    // （32-1）0000011,111 ---- (16-1)0000001,111\n                    // 结果:-- 000000x,xxx ---- (16-1)000000x,xxx;\b可以看出扩容前后下标的计算值是一样的，所以在新数组同样的\b下标处插入这个链表\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    } \n                    // 上面do-while循环中(e.hash & oldCap) != 0的分支，hash值格式为xx..xx1x,xxx(oldCap还是16，从右往左第5个数是1，其他任意)，与（32-1）以及（15-1）做&运算的结果分别是：\n                    // （32-1）xx.xx1x,xxx ---- (16-1)xx.xx1x,xxx\n                    // （32-1）0000011,111 ---- (16-1)0000001,111\n                    // 结果:-- 000001x,xxx ---- (16-1)000000x,xxx;可以看出扩容后新的下标值比就的下标值大了16，也就是大了oldCap的值，所以另外一个子链表被放置到新数组j+oldCap下标处，\b这种巧妙的计算下标方式，可以减少重新计算下标的花销，加快扩容的速度\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n#### TreeNode\n`TreeNode`的类大概就是这样，很清楚的表明了是个红黑树结构，它的插入，删除，查找等方法被省略了，关于它如果左旋右旋进行rebalance可以去网上搜索相关资料\n```java\n static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // red-black tree links\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\n    boolean red;\n    TreeNode(int hash, K key, V val, Node<K,V> next) {\n        super(hash, key, val, next);\n    }\n```\n\n### 获取元素\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) { // table数组中已经存在元素且hash对应的下标处有元素\n        if (first.hash == hash && // \b\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first; // table数组中hash对应下标的第一个元素，就是要找的元素时返回first\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 如果hash\b对应的node是一个红黑树结构，从红黑树中查找key\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e; // 在链表中查找key相等的Node\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### 删除元素\n\n```java\npublic V remove(Object key) {\n    Node<K,V> e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    Node<K,V>[] tab; Node<K,V> p; int n, index;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (p = tab[index = (n - 1) & hash]) != null) { // tab = table; p指向key对应的下标所在的Node，如果tab,p为空，return null\n        Node<K,V> node = null, e; K k; V v;\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            node = p; // key指向的\bNode的第一个元素就是要remove的key时，node=p\n        else if ((e = p.next) != null) { // 第一个元素存在，但不是所要找的key时，如果p.next存在，进入\n            if (p instanceof TreeNode) // 该下标的Node为红黑树结构\n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n            else { // 该下标的Node为链表，找到对应的key时，node指向key对应的节点，否则node=null\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key ||\n                         (key != null && key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        if (node != null && (!matchValue || (v = node.value) == value ||\n                             (value != null && value.equals(v)))) { // matchValue可选，删除时比较value是否相等，默认不比较\n            if (node instanceof TreeNode)\n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n            else if (node == p) // key对应链表第一个节点\n                tab[index] = node.next;\n            else // key对应链表非第一个节点\n                p.next = node.next;\n            ++modCount; // modCount记录添加和删除等操作的次数，不记录修改value的次数\n            --size; // size大小减1\n            afterNodeRemoval(node); // 方法为空\n            return node;\n        }\n    }\n    return null;\n}\n// 清空map\npublic void clear() {\n    Node<K,V>[] tab;\n    modCount++;\n    if ((tab = table) != null && size > 0) {\n        size = 0;\n        for (int i = 0; i < tab.length; ++i)\n            tab[i] = null;\n    }\n}\n```\n\n### for-each遍历\n\n```java\n@Override\npublic void forEach(BiConsumer<? super K, ? super V> action) {\n    Node<K,V>[] tab;\n    if (action == null)\n        throw new NullPointerException();\n    if (size > 0 && (tab = table) != null) {\n        int mc = modCount;\n        for (int i = 0; i < tab.length; ++i) { // 按照数组下标从小到大遍历\n            for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                action.accept(e.key, e.value);\n        }\n        if (modCount != mc) // 遍历的时候不允许修改数组结构，修改value除外，如果出现，抛出异常\n            throw new ConcurrentModificationException();\n    }\n}\n// example\nmaps.forEach((k, v) -> {\n    System.out.println(\"key: \" + k + \", value: \" + v); \n})\n```\n\n### 总结\n\n上面差不多把HashMap常用的方法的源码都介绍了一下，其实还不到源码的一半的内容\b，源码中还有很多关于TreeNode的操作，红黑树相关的操作占了将近一半的篇幅，除此之外还有很多Iterator的类和方法，对于这些Iterator的源码和作用，还没有去研究过，准备把大部分集合代码分析完后，专门写一篇关于迭代器的分析博客。\b(水平有限，如有错误，欢迎提出，可以发邮件或者关注文章底部的微信公众号，谢谢！)\n\n## Technique and Life\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![Technique and Life](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","source":"_posts/Java集合源码系列-HashMap.md","raw":"---\ntitle: Java集合源码系列-HashMap\ndate: 2019-01-12 11:05:57\ntags:\n    - Java\n    - Java源码\n---\n\n### 前言\n\nJava基础是面试中的重中之重，尤其是对集合类，并发包等源码的相关的问题是面试中常考察的点。但是其实这些点并不难，对于计算机专业的学生来说，如果上过数据结构这门课，对数组，字符串，链表以及字典的大致实现都有一定了解，在阅读JDK源码时也会发现，整体的思路是和所学的数据结构一样的，所以理解源码的整体框架不难，但是不能总是浮于表面，需要理解JDK在一些细节处理上的针对性\b优化措施。\n<!--more-->\n网上关于源码解析的博客有很多，也给我提供了很大的帮助。阅读源码时不懂是很正常的情况，可以借助google或baidu来解决遇到的问题。看了那么多博客，自己也想总结出一个源码系列，一是因为基础知识很重要，但是容易遗忘，做一个定期的总结可以让自己将来有机会温习，同时加深自己的理解。二是做一个分享，希望可以收获更多的读者_(:3」∠)_\n\n作为系列的第一篇文章，说一下文章的整体思路。因为是介绍集合类的源码，所以以使用集合的整个生命周期来作为行文路线，即创建对象-->添加元素-->获取元素-->删除元素。\b 整个系列，如果没有\b特殊说明，则都是JDK8版源码.\n\n### 概览\n\nMap的底层存储一般都是数组，\b因为数组可以满足常数时间内进行**get**和**put**操作。而数组的下标一般是由一个哈希函数来获得，在常见的数据结构教材中，一般为对数组长度取模，\b可以保证\b哈希函数得到的index范围在[0，len-1]之间，不会数组越界，并且可以利用到数组的所有位置。\b除了取模这种hash算法，还有很多其他的算法，各有优劣。\n\n除了hash算法，一个Map实现还需要解决index重复的问题，常见的有再hash法，开放地址法\b，拉链法等；而HashMap可以看做是一个优化过的拉链法。\n\n解决了如何计算hash和解决冲突后，还需要面临的一个问题是，数组的大小都是固定的，那么随着Map存的数据越来越多，同一个下标存储的数据越来越多，存取的性能退化为O(n),数组如何动态的调整其大小来改善性能呢;HashMap通过一个叫做负载因子的变量来控制调整的时机。\n\n带着这几个问题，下面一起来阅读一下HashMap的源码吧～\n\n### 构造函数\n\n使用集合类的第一步就是通过构造函数，HashMap的构造函数有多个，但其实类似，将从最常见的展开，顺带着其余的构造函数。\n\n```java\n/**\n * loadFactor即为前面提到的负载因子，默认值为0.75，这是最普通的、最常用的构造函数，所有内部参数都使用默认值，关于一些参数，\b后面用到时再详细介绍\n */\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; //\b 负载因子默认值\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n}\n/**\n * 指定\b构建对象的底层数组大小和负载因子。默认值分别为16和0.75.对传入的参数有一点限制，底层数组必须大于0小于最大容量(2的30次方)，并且会被调整为2的整数幂，原因后续介绍。通过tableSizeFor函数调整。\n */\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" + \n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n//通过巧妙的位运算，将指定的cap变为大于等于cap的第一个2的幂次方整数，源码中多次利用位运算来进行速度优化\n// n =       000..1XXXXXX假设n的二进制格式，1代表第一个1出现的位置，x为任意的0或1\n// n >>> 1 = 000..01xxxxx\n// 新n     = 000..11xxxxx \n// n >>> 2 = 000..0011xxx\n// 新n或运算 = 000..1111xxx\n// 因为cap传进来时最大为2的30次方，所以最多只要16的时候，就可以保证第一次出现1的位置后面全变为1，即n = 000..00111111，那么在返回时通过n+1的操作，\b使n=000.01000000的形式，保证返回值是2的n次方\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n// 用一个已经存在的map初始化，用的不多，就在代码中稍微写点注释\npublic HashMap(Map<? extends K, ? extends V> m) {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, false);\n}\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        if (table == null) { // 如果数组还没分配，根据m的大小\b建立合适大小的数组\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                (int)ft : MAXIMUM_CAPACITY);\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        else if (s > threshold) // 如果m的大小超过table大小，则扩容，resize()后面介绍\n            resize();\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n\n### 添加元素\n\n介绍完构造函数后现在介绍下如何添加元素，那么在这之前，需要先了解一下HashMap用了什么结构来保存数据\n\n```java\ntransient Node<K,V>[] table; // HashMap中的table属性用来保存数组，数组元素本身的结构为Node,是一个静态内部类\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; // 存储hash值，空间换时间，减少重复计算\n    final K key;    // 字典的key\n    V value;        // 字典的value\n    Node<K,V> next; // 前面提到,HashMap使用优化过的拉链法解决Hash冲突，即所有Hash值相同的key通过链表连接，可以看出极端情况get性能会退回为O(N)，所以后面会介绍如何优化，暂时理解为一个简单的链表\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    // 省略get, set, equal, toString....\n}\n```\n\n接下来看下put方法的逻辑：\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true); // hash方法求key的index\n}\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); // 充分利用高16位以及低16位求hash，避免连续的key产生的hash值具有规律性\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0) // table懒加载，第一次存值时才初始化数组\n        n = (tab = resize()).length; // 初始化数组，分配给tab变量，resize()后面介绍，返回值为新分配的数组，n为新数组长度\n    if ((p = tab[i = (n - 1) & hash]) == null) // i = (n-1) & hash求出元素下标，前面介绍了字典一般是通过对数组的大小去\b取模求得数组的下标，但是cpu更擅长的是位运算，而前面提到了数组的大小肯定是2的整数次方，即n的二进制格式为00.100..000，那么n-1即为00.011..111的,对这样的一个数进行与运算的结果集就是0到n-1，效果与除法取模一样，但是速度大幅度提升\n        tab[i] = newNode(hash, key, value, null); // 如果指定下标不存在元素，在下标为i的地方插入新值, newNode方法生成一个Node对象并返回\n    else { // 如果指定下标已经存在元素，进入该分支\n        Node<K,V> e; K k;\n        // p为指定下标i位置上的Node元素\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k)))) // 如果p指向的节点的key与新put进来的key一样\n            e = p;\n        else if (p instanceof TreeNode) // 如果p指向的节点的key与新Put进来的key不一样，且是TreeNode实例\n            // 前面介绍过，HashMap的拉链法是优化过的，就体现在这。如果同一个数组跟着的链表长度大于8，会转化为红黑树，红黑树是一种平衡树，平均复杂度为O(logn),优于链表的O(n)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // TreeNode版的putVal方法\n        else { // key应该在链表中的情况\n            for (int binCount = 0; ; ++binCount) { // 遍历链表\n                if ((e = p.next) == null) { // 如果遍历完链表还没找到相同的key，则key为新的值，添加到链表尾端\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // 如果节点数大于8，则转换为红黑树结构 TREEIFY_THRESHOLD=8\n                        treeifyBin(tab, hash); // 将链表转换为红黑树\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k)))) // put进来的key已经存在，指向Node e\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // put 进来的key已经存在，将value替换\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null) // @param onlyIfAbsent if true, don't change existing value\n                e.value = value;\n            afterNodeAccess(e); // 方法为空，无操作\n            return oldValue;\n        }\n    }\n    // 如果key是新的值，则进入这里，否则直接返回\n    ++modCount; // 改变量记录了对map添加和删除的次数\n    if (++size > threshold) // threshold为扩容门槛，如果没有指定，在第一次进行resize()时被置为capacity * load factor，即16*0.75\n        resize(); // size记录了table包含的key,value对的数量\n    afterNodeInsertion(evict); // 改方法为空，无操作\n    return null;\n}\n```\n\n上面就是关于添加元素的部分了，但是对于优化为红黑树的部分没有进行深入介绍。因为红黑树本身的数据结构就比较复杂，不易理解，对红黑树进行插入，平衡，查找的相关操作跟map的关系已经不大，如果有兴趣，可以另外找时间网上搜索一下。需要知道的就是红黑树主要解决的问题是当哈希冲突太多时，链表的查询性能变为O(n),用红黑树替代后可以降低到O(logn)的复杂度，且当链表长度8时才进行这个转变；后面会提到resize()时如果节点数量小于6时，红黑树也会退化为链表。接下来介绍一下前面省略掉的`resize()`方法：\n\n#### resize()方法\n\n```java\nfinal Node<K,V>[] resize() { // size超过capacity * load_factory时进行扩容\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) { // 如果已经达到最大的size：2的30次方，不再扩容，直接返回旧table\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY) // 如果旧的容量*2小于2的30次方且旧的容量大于16时将数组大小翻倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // table数组还没创建且threshold>0时，将capacity设为threshold\n        newCap = oldThr;\n    else {               // table数组还没创建，将capacity设为16，扩容阈值设为16*0.75\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) { // 设置新的扩容阈值\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr; // threshold重新赋值\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; // 申请一个新的数组，大小为原来数组的两倍\n    table = newTab;  // table变量指向新数组\n    if (oldTab != null) { \n        for (int j = 0; j < oldCap; ++j) { // 遍历旧的数组\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) { // 旧数组对应的下标j不为空时，将该下标的元素转移到新数组中\n                oldTab[j] = null; // 加速GC？猜测\n                if (e.next == null) // 如果对应的下标j只有一个元素，将该元素放到新数组 e.hash & (newCap - 1)处\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode) // 如果下标j对应的Node是红黑树节点\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); // 在split函数中，如果节点数量小于static final int UNTREEIFY_THRESHOLD = 6；退化为链表\n                else { // 链表Node\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do { // do-while循环，将链表根据重新e.hash & oldCap是否等于0，分成两个子链表\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) { // oldCap二进制为00.100.00的格式，是2的整数次方，只有1个1\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 按照新的table大小来计算数组下标时，算式应该是这样的：e.hash & (oldCap*2-1),假设oldCap为16， 则二进制表示为10,000，oldCap*2=32的\b二进制为100,000\n                    // 那么上面do-while循环中(e.hash & oldCap) == 0的分支，hash值格式为xx..xx0x,xxx(从右往左第5个数是0，其他任意),与（32-1）做&运算的以及与（15-1）做&运算的结果分别是：\n                    // （32-1）xx.xx0x,xxx ---- (16-1)xx.xx0x,xxx\n                    // （32-1）0000011,111 ---- (16-1)0000001,111\n                    // 结果:-- 000000x,xxx ---- (16-1)000000x,xxx;\b可以看出扩容前后下标的计算值是一样的，所以在新数组同样的\b下标处插入这个链表\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    } \n                    // 上面do-while循环中(e.hash & oldCap) != 0的分支，hash值格式为xx..xx1x,xxx(oldCap还是16，从右往左第5个数是1，其他任意)，与（32-1）以及（15-1）做&运算的结果分别是：\n                    // （32-1）xx.xx1x,xxx ---- (16-1)xx.xx1x,xxx\n                    // （32-1）0000011,111 ---- (16-1)0000001,111\n                    // 结果:-- 000001x,xxx ---- (16-1)000000x,xxx;可以看出扩容后新的下标值比就的下标值大了16，也就是大了oldCap的值，所以另外一个子链表被放置到新数组j+oldCap下标处，\b这种巧妙的计算下标方式，可以减少重新计算下标的花销，加快扩容的速度\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n#### TreeNode\n`TreeNode`的类大概就是这样，很清楚的表明了是个红黑树结构，它的插入，删除，查找等方法被省略了，关于它如果左旋右旋进行rebalance可以去网上搜索相关资料\n```java\n static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // red-black tree links\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\n    boolean red;\n    TreeNode(int hash, K key, V val, Node<K,V> next) {\n        super(hash, key, val, next);\n    }\n```\n\n### 获取元素\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) { // table数组中已经存在元素且hash对应的下标处有元素\n        if (first.hash == hash && // \b\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first; // table数组中hash对应下标的第一个元素，就是要找的元素时返回first\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 如果hash\b对应的node是一个红黑树结构，从红黑树中查找key\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e; // 在链表中查找key相等的Node\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### 删除元素\n\n```java\npublic V remove(Object key) {\n    Node<K,V> e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    Node<K,V>[] tab; Node<K,V> p; int n, index;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (p = tab[index = (n - 1) & hash]) != null) { // tab = table; p指向key对应的下标所在的Node，如果tab,p为空，return null\n        Node<K,V> node = null, e; K k; V v;\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            node = p; // key指向的\bNode的第一个元素就是要remove的key时，node=p\n        else if ((e = p.next) != null) { // 第一个元素存在，但不是所要找的key时，如果p.next存在，进入\n            if (p instanceof TreeNode) // 该下标的Node为红黑树结构\n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n            else { // 该下标的Node为链表，找到对应的key时，node指向key对应的节点，否则node=null\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key ||\n                         (key != null && key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        if (node != null && (!matchValue || (v = node.value) == value ||\n                             (value != null && value.equals(v)))) { // matchValue可选，删除时比较value是否相等，默认不比较\n            if (node instanceof TreeNode)\n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n            else if (node == p) // key对应链表第一个节点\n                tab[index] = node.next;\n            else // key对应链表非第一个节点\n                p.next = node.next;\n            ++modCount; // modCount记录添加和删除等操作的次数，不记录修改value的次数\n            --size; // size大小减1\n            afterNodeRemoval(node); // 方法为空\n            return node;\n        }\n    }\n    return null;\n}\n// 清空map\npublic void clear() {\n    Node<K,V>[] tab;\n    modCount++;\n    if ((tab = table) != null && size > 0) {\n        size = 0;\n        for (int i = 0; i < tab.length; ++i)\n            tab[i] = null;\n    }\n}\n```\n\n### for-each遍历\n\n```java\n@Override\npublic void forEach(BiConsumer<? super K, ? super V> action) {\n    Node<K,V>[] tab;\n    if (action == null)\n        throw new NullPointerException();\n    if (size > 0 && (tab = table) != null) {\n        int mc = modCount;\n        for (int i = 0; i < tab.length; ++i) { // 按照数组下标从小到大遍历\n            for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                action.accept(e.key, e.value);\n        }\n        if (modCount != mc) // 遍历的时候不允许修改数组结构，修改value除外，如果出现，抛出异常\n            throw new ConcurrentModificationException();\n    }\n}\n// example\nmaps.forEach((k, v) -> {\n    System.out.println(\"key: \" + k + \", value: \" + v); \n})\n```\n\n### 总结\n\n上面差不多把HashMap常用的方法的源码都介绍了一下，其实还不到源码的一半的内容\b，源码中还有很多关于TreeNode的操作，红黑树相关的操作占了将近一半的篇幅，除此之外还有很多Iterator的类和方法，对于这些Iterator的源码和作用，还没有去研究过，准备把大部分集合代码分析完后，专门写一篇关于迭代器的分析博客。\b(水平有限，如有错误，欢迎提出，可以发邮件或者关注文章底部的微信公众号，谢谢！)\n\n## Technique and Life\n\n欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～\n\n![Technique and Life](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)\n","slug":"Java集合源码系列-HashMap","published":1,"updated":"2019-02-03T07:16:46.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqklle000wuetugua0s3vc","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Java基础是面试中的重中之重，尤其是对集合类，并发包等源码的相关的问题是面试中常考察的点。但是其实这些点并不难，对于计算机专业的学生来说，如果上过数据结构这门课，对数组，字符串，链表以及字典的大致实现都有一定了解，在阅读JDK源码时也会发现，整体的思路是和所学的数据结构一样的，所以理解源码的整体框架不难，但是不能总是浮于表面，需要理解JDK在一些细节处理上的针对性\b优化措施。<br><a id=\"more\"></a><br>网上关于源码解析的博客有很多，也给我提供了很大的帮助。阅读源码时不懂是很正常的情况，可以借助google或baidu来解决遇到的问题。看了那么多博客，自己也想总结出一个源码系列，一是因为基础知识很重要，但是容易遗忘，做一个定期的总结可以让自己将来有机会温习，同时加深自己的理解。二是做一个分享，希望可以收获更多的读者<em>(:3」∠)</em></p>\n<p>作为系列的第一篇文章，说一下文章的整体思路。因为是介绍集合类的源码，所以以使用集合的整个生命周期来作为行文路线，即创建对象–&gt;添加元素–&gt;获取元素–&gt;删除元素。\b 整个系列，如果没有\b特殊说明，则都是JDK8版源码.</p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>Map的底层存储一般都是数组，\b因为数组可以满足常数时间内进行<strong>get</strong>和<strong>put</strong>操作。而数组的下标一般是由一个哈希函数来获得，在常见的数据结构教材中，一般为对数组长度取模，\b可以保证\b哈希函数得到的index范围在[0，len-1]之间，不会数组越界，并且可以利用到数组的所有位置。\b除了取模这种hash算法，还有很多其他的算法，各有优劣。</p>\n<p>除了hash算法，一个Map实现还需要解决index重复的问题，常见的有再hash法，开放地址法\b，拉链法等；而HashMap可以看做是一个优化过的拉链法。</p>\n<p>解决了如何计算hash和解决冲突后，还需要面临的一个问题是，数组的大小都是固定的，那么随着Map存的数据越来越多，同一个下标存储的数据越来越多，存取的性能退化为O(n),数组如何动态的调整其大小来改善性能呢;HashMap通过一个叫做负载因子的变量来控制调整的时机。</p>\n<p>带着这几个问题，下面一起来阅读一下HashMap的源码吧～</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>使用集合类的第一步就是通过构造函数，HashMap的构造函数有多个，但其实类似，将从最常见的展开，顺带着其余的构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * loadFactor即为前面提到的负载因子，默认值为0.75，这是最普通的、最常用的构造函数，所有内部参数都使用默认值，关于一些参数，\b后面用到时再详细介绍</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>; <span class=\"comment\">//\b 负载因子默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 指定\b构建对象的底层数组大小和负载因子。默认值分别为16和0.75.对传入的参数有一点限制，底层数组必须大于0小于最大容量(2的30次方)，并且会被调整为2的整数幂，原因后续介绍。通过tableSizeFor函数调整。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> + </span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//通过巧妙的位运算，将指定的cap变为大于等于cap的第一个2的幂次方整数，源码中多次利用位运算来进行速度优化</span></span><br><span class=\"line\"><span class=\"comment\">// n =       000..1XXXXXX假设n的二进制格式，1代表第一个1出现的位置，x为任意的0或1</span></span><br><span class=\"line\"><span class=\"comment\">// n &gt;&gt;&gt; 1 = 000..01xxxxx</span></span><br><span class=\"line\"><span class=\"comment\">// 新n     = 000..11xxxxx </span></span><br><span class=\"line\"><span class=\"comment\">// n &gt;&gt;&gt; 2 = 000..0011xxx</span></span><br><span class=\"line\"><span class=\"comment\">// 新n或运算 = 000..1111xxx</span></span><br><span class=\"line\"><span class=\"comment\">// 因为cap传进来时最大为2的30次方，所以最多只要16的时候，就可以保证第一次出现1的位置后面全变为1，即n = 000..00111111，那么在返回时通过n+1的操作，\b使n=000.01000000的形式，保证返回值是2的n次方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用一个已经存在的map初始化，用的不多，就在代码中稍微写点注释</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">putMapEntries</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = m.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 如果数组还没分配，根据m的大小\b建立合适大小的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = ((<span class=\"keyword\">float</span>)s / loadFactor) + <span class=\"number\">1.0F</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = ((ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">                (<span class=\"keyword\">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; threshold)</span><br><span class=\"line\">                threshold = tableSizeFor(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; threshold) <span class=\"comment\">// 如果m的大小超过table大小，则扩容，resize()后面介绍</span></span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            putVal(hash(key), key, value, <span class=\"keyword\">false</span>, evict);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>介绍完构造函数后现在介绍下如何添加元素，那么在这之前，需要先了解一下HashMap用了什么结构来保存数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table; <span class=\"comment\">// HashMap中的table属性用来保存数组，数组元素本身的结构为Node,是一个静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 存储hash值，空间换时间，减少重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;    <span class=\"comment\">// 字典的key</span></span><br><span class=\"line\">    V value;        <span class=\"comment\">// 字典的value</span></span><br><span class=\"line\">    Node&lt;K,V&gt; next; <span class=\"comment\">// 前面提到,HashMap使用优化过的拉链法解决Hash冲突，即所有Hash值相同的key通过链表连接，可以看出极端情况get性能会退回为O(N)，所以后面会介绍如何优化，暂时理解为一个简单的链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略get, set, equal, toString....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来看下put方法的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>); <span class=\"comment\">// hash方法求key的index</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>); <span class=\"comment\">// 充分利用高16位以及低16位求hash，避免连续的key产生的hash值具有规律性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) <span class=\"comment\">// table懒加载，第一次存值时才初始化数组</span></span><br><span class=\"line\">        n = (tab = resize()).length; <span class=\"comment\">// 初始化数组，分配给tab变量，resize()后面介绍，返回值为新分配的数组，n为新数组长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>) <span class=\"comment\">// i = (n-1) &amp; hash求出元素下标，前面介绍了字典一般是通过对数组的大小去\b取模求得数组的下标，但是cpu更擅长的是位运算，而前面提到了数组的大小肯定是2的整数次方，即n的二进制格式为00.100..000，那么n-1即为00.011..111的,对这样的一个数进行与运算的结果集就是0到n-1，效果与除法取模一样，但是速度大幅度提升</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>); <span class=\"comment\">// 如果指定下标不存在元素，在下标为i的地方插入新值, newNode方法生成一个Node对象并返回</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果指定下标已经存在元素，进入该分支</span></span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// p为指定下标i位置上的Node元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">// 如果p指向的节点的key与新put进来的key一样</span></span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 如果p指向的节点的key与新Put进来的key不一样，且是TreeNode实例</span></span><br><span class=\"line\">            <span class=\"comment\">// 前面介绍过，HashMap的拉链法是优化过的，就体现在这。如果同一个数组跟着的链表长度大于8，会转化为红黑树，红黑树是一种平衡树，平均复杂度为O(logn),优于链表的O(n)</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value); <span class=\"comment\">// TreeNode版的putVal方法</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// key应该在链表中的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123; <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 如果遍历完链表还没找到相同的key，则key为新的值，添加到链表尾端</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// 如果节点数大于8，则转换为红黑树结构 TREEIFY_THRESHOLD=8</span></span><br><span class=\"line\">                        treeifyBin(tab, hash); <span class=\"comment\">// 将链表转换为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">// put进来的key已经存在，指向Node e</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// put 进来的key已经存在，将value替换</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>) <span class=\"comment\">// @param onlyIfAbsent if true, don't change existing value</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e); <span class=\"comment\">// 方法为空，无操作</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果key是新的值，则进入这里，否则直接返回</span></span><br><span class=\"line\">    ++modCount; <span class=\"comment\">// 改变量记录了对map添加和删除的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold) <span class=\"comment\">// threshold为扩容门槛，如果没有指定，在第一次进行resize()时被置为capacity * load factor，即16*0.75</span></span><br><span class=\"line\">        resize(); <span class=\"comment\">// size记录了table包含的key,value对的数量</span></span><br><span class=\"line\">    afterNodeInsertion(evict); <span class=\"comment\">// 改方法为空，无操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是关于添加元素的部分了，但是对于优化为红黑树的部分没有进行深入介绍。因为红黑树本身的数据结构就比较复杂，不易理解，对红黑树进行插入，平衡，查找的相关操作跟map的关系已经不大，如果有兴趣，可以另外找时间网上搜索一下。需要知道的就是红黑树主要解决的问题是当哈希冲突太多时，链表的查询性能变为O(n),用红黑树替代后可以降低到O(logn)的复杂度，且当链表长度8时才进行这个转变；后面会提到resize()时如果节点数量小于6时，红黑树也会退化为链表。接下来介绍一下前面省略掉的<code>resize()</code>方法：</p>\n<h4 id=\"resize-方法\"><a href=\"#resize-方法\" class=\"headerlink\" title=\"resize()方法\"></a>resize()方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123; <span class=\"comment\">// size超过capacity * load_factory时进行扩容</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class=\"comment\">// 如果已经达到最大的size：2的30次方，不再扩容，直接返回旧table</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class=\"comment\">// 如果旧的容量*2小于2的30次方且旧的容量大于16时将数组大小翻倍</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// table数组还没创建且threshold&gt;0时，将capacity设为threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// table数组还没创建，将capacity设为16，扩容阈值设为16*0.75</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 设置新的扩容阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr; <span class=\"comment\">// threshold重新赋值</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap]; <span class=\"comment\">// 申请一个新的数组，大小为原来数组的两倍</span></span><br><span class=\"line\">    table = newTab;  <span class=\"comment\">// table变量指向新数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123; <span class=\"comment\">// 遍历旧的数组</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 旧数组对应的下标j不为空时，将该下标的元素转移到新数组中</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>; <span class=\"comment\">// 加速GC？猜测</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果对应的下标j只有一个元素，将该元素放到新数组 e.hash &amp; (newCap - 1)处</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 如果下标j对应的Node是红黑树节点</span></span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap); <span class=\"comment\">// 在split函数中，如果节点数量小于static final int UNTREEIFY_THRESHOLD = 6；退化为链表</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 链表Node</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// do-while循环，将链表根据重新e.hash &amp; oldCap是否等于0，分成两个子链表</span></span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// oldCap二进制为00.100.00的格式，是2的整数次方，只有1个1</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 按照新的table大小来计算数组下标时，算式应该是这样的：e.hash &amp; (oldCap*2-1),假设oldCap为16， 则二进制表示为10,000，oldCap*2=32的\b二进制为100,000</span></span><br><span class=\"line\">                    <span class=\"comment\">// 那么上面do-while循环中(e.hash &amp; oldCap) == 0的分支，hash值格式为xx..xx0x,xxx(从右往左第5个数是0，其他任意),与（32-1）做&amp;运算的以及与（15-1）做&amp;运算的结果分别是：</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）xx.xx0x,xxx ---- (16-1)xx.xx0x,xxx</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）0000011,111 ---- (16-1)0000001,111</span></span><br><span class=\"line\">                    <span class=\"comment\">// 结果:-- 000000x,xxx ---- (16-1)000000x,xxx;\b可以看出扩容前后下标的计算值是一样的，所以在新数组同样的\b下标处插入这个链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125; </span><br><span class=\"line\">                    <span class=\"comment\">// 上面do-while循环中(e.hash &amp; oldCap) != 0的分支，hash值格式为xx..xx1x,xxx(oldCap还是16，从右往左第5个数是1，其他任意)，与（32-1）以及（15-1）做&amp;运算的结果分别是：</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）xx.xx1x,xxx ---- (16-1)xx.xx1x,xxx</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）0000011,111 ---- (16-1)0000001,111</span></span><br><span class=\"line\">                    <span class=\"comment\">// 结果:-- 000001x,xxx ---- (16-1)000000x,xxx;可以看出扩容后新的下标值比就的下标值大了16，也就是大了oldCap的值，所以另外一个子链表被放置到新数组j+oldCap下标处，\b这种巧妙的计算下标方式，可以减少重新计算下标的花销，加快扩容的速度</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"TreeNode\"><a href=\"#TreeNode\" class=\"headerlink\" title=\"TreeNode\"></a>TreeNode</h4><p><code>TreeNode</code>的类大概就是这样，很清楚的表明了是个红黑树结构，它的插入，删除，查找等方法被省略了，关于它如果左旋右旋进行rebalance可以去网上搜索相关资料<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">   TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">   TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">   TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">   TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">   <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">   TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// table数组中已经存在元素且hash对应的下标处有元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// \b</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first; <span class=\"comment\">// table数组中hash对应下标的第一个元素，就是要找的元素时返回first</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); <span class=\"comment\">// 如果hash\b对应的node是一个红黑树结构，从红黑树中查找key</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e; <span class=\"comment\">// 在链表中查找key相等的Node</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">        <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// tab = table; p指向key对应的下标所在的Node，如果tab,p为空，return null</span></span><br><span class=\"line\">        Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            node = p; <span class=\"comment\">// key指向的\bNode的第一个元素就是要remove的key时，node=p</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 第一个元素存在，但不是所要找的key时，如果p.next存在，进入</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 该下标的Node为红黑树结构</span></span><br><span class=\"line\">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 该下标的Node为链表，找到对应的key时，node指向key对应的节点，否则node=null</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key ||</span><br><span class=\"line\">                         (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                        node = e;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                             (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123; <span class=\"comment\">// matchValue可选，删除时比较value是否相等，默认不比较</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p) <span class=\"comment\">// key对应链表第一个节点</span></span><br><span class=\"line\">                tab[index] = node.next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">// key对应链表非第一个节点</span></span><br><span class=\"line\">                p.next = node.next;</span><br><span class=\"line\">            ++modCount; <span class=\"comment\">// modCount记录添加和删除等操作的次数，不记录修改value的次数</span></span><br><span class=\"line\">            --size; <span class=\"comment\">// size大小减1</span></span><br><span class=\"line\">            afterNodeRemoval(node); <span class=\"comment\">// 方法为空</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 清空map</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i)</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"for-each遍历\"><a href=\"#for-each遍历\" class=\"headerlink\" title=\"for-each遍历\"></a>for-each遍历</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(BiConsumer&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span> &amp;&amp; (tab = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mc = modCount;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123; <span class=\"comment\">// 按照数组下标从小到大遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next)</span><br><span class=\"line\">                action.accept(e.key, e.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modCount != mc) <span class=\"comment\">// 遍历的时候不允许修改数组结构，修改value除外，如果出现，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// example</span></span><br><span class=\"line\">maps.forEach((k, v) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"key: \"</span> + k + <span class=\"string\">\", value: \"</span> + v); </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面差不多把HashMap常用的方法的源码都介绍了一下，其实还不到源码的一半的内容\b，源码中还有很多关于TreeNode的操作，红黑树相关的操作占了将近一半的篇幅，除此之外还有很多Iterator的类和方法，对于这些Iterator的源码和作用，还没有去研究过，准备把大部分集合代码分析完后，专门写一篇关于迭代器的分析博客。\b(水平有限，如有错误，欢迎提出，可以发邮件或者关注文章底部的微信公众号，谢谢！)</p>\n<h2 id=\"Technique-and-Life\"><a href=\"#Technique-and-Life\" class=\"headerlink\" title=\"Technique and Life\"></a>Technique and Life</h2><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"Technique and Life\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Java基础是面试中的重中之重，尤其是对集合类，并发包等源码的相关的问题是面试中常考察的点。但是其实这些点并不难，对于计算机专业的学生来说，如果上过数据结构这门课，对数组，字符串，链表以及字典的大致实现都有一定了解，在阅读JDK源码时也会发现，整体的思路是和所学的数据结构一样的，所以理解源码的整体框架不难，但是不能总是浮于表面，需要理解JDK在一些细节处理上的针对性\b优化措施。<br>","more":"<br>网上关于源码解析的博客有很多，也给我提供了很大的帮助。阅读源码时不懂是很正常的情况，可以借助google或baidu来解决遇到的问题。看了那么多博客，自己也想总结出一个源码系列，一是因为基础知识很重要，但是容易遗忘，做一个定期的总结可以让自己将来有机会温习，同时加深自己的理解。二是做一个分享，希望可以收获更多的读者<em>(:3」∠)</em></p>\n<p>作为系列的第一篇文章，说一下文章的整体思路。因为是介绍集合类的源码，所以以使用集合的整个生命周期来作为行文路线，即创建对象–&gt;添加元素–&gt;获取元素–&gt;删除元素。\b 整个系列，如果没有\b特殊说明，则都是JDK8版源码.</p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>Map的底层存储一般都是数组，\b因为数组可以满足常数时间内进行<strong>get</strong>和<strong>put</strong>操作。而数组的下标一般是由一个哈希函数来获得，在常见的数据结构教材中，一般为对数组长度取模，\b可以保证\b哈希函数得到的index范围在[0，len-1]之间，不会数组越界，并且可以利用到数组的所有位置。\b除了取模这种hash算法，还有很多其他的算法，各有优劣。</p>\n<p>除了hash算法，一个Map实现还需要解决index重复的问题，常见的有再hash法，开放地址法\b，拉链法等；而HashMap可以看做是一个优化过的拉链法。</p>\n<p>解决了如何计算hash和解决冲突后，还需要面临的一个问题是，数组的大小都是固定的，那么随着Map存的数据越来越多，同一个下标存储的数据越来越多，存取的性能退化为O(n),数组如何动态的调整其大小来改善性能呢;HashMap通过一个叫做负载因子的变量来控制调整的时机。</p>\n<p>带着这几个问题，下面一起来阅读一下HashMap的源码吧～</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>使用集合类的第一步就是通过构造函数，HashMap的构造函数有多个，但其实类似，将从最常见的展开，顺带着其余的构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * loadFactor即为前面提到的负载因子，默认值为0.75，这是最普通的、最常用的构造函数，所有内部参数都使用默认值，关于一些参数，\b后面用到时再详细介绍</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>; <span class=\"comment\">//\b 负载因子默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 指定\b构建对象的底层数组大小和负载因子。默认值分别为16和0.75.对传入的参数有一点限制，底层数组必须大于0小于最大容量(2的30次方)，并且会被调整为2的整数幂，原因后续介绍。通过tableSizeFor函数调整。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> + </span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//通过巧妙的位运算，将指定的cap变为大于等于cap的第一个2的幂次方整数，源码中多次利用位运算来进行速度优化</span></span><br><span class=\"line\"><span class=\"comment\">// n =       000..1XXXXXX假设n的二进制格式，1代表第一个1出现的位置，x为任意的0或1</span></span><br><span class=\"line\"><span class=\"comment\">// n &gt;&gt;&gt; 1 = 000..01xxxxx</span></span><br><span class=\"line\"><span class=\"comment\">// 新n     = 000..11xxxxx </span></span><br><span class=\"line\"><span class=\"comment\">// n &gt;&gt;&gt; 2 = 000..0011xxx</span></span><br><span class=\"line\"><span class=\"comment\">// 新n或运算 = 000..1111xxx</span></span><br><span class=\"line\"><span class=\"comment\">// 因为cap传进来时最大为2的30次方，所以最多只要16的时候，就可以保证第一次出现1的位置后面全变为1，即n = 000..00111111，那么在返回时通过n+1的操作，\b使n=000.01000000的形式，保证返回值是2的n次方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用一个已经存在的map初始化，用的不多，就在代码中稍微写点注释</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">putMapEntries</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = m.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 如果数组还没分配，根据m的大小\b建立合适大小的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = ((<span class=\"keyword\">float</span>)s / loadFactor) + <span class=\"number\">1.0F</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = ((ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">                (<span class=\"keyword\">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; threshold)</span><br><span class=\"line\">                threshold = tableSizeFor(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; threshold) <span class=\"comment\">// 如果m的大小超过table大小，则扩容，resize()后面介绍</span></span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            putVal(hash(key), key, value, <span class=\"keyword\">false</span>, evict);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>介绍完构造函数后现在介绍下如何添加元素，那么在这之前，需要先了解一下HashMap用了什么结构来保存数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table; <span class=\"comment\">// HashMap中的table属性用来保存数组，数组元素本身的结构为Node,是一个静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 存储hash值，空间换时间，减少重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;    <span class=\"comment\">// 字典的key</span></span><br><span class=\"line\">    V value;        <span class=\"comment\">// 字典的value</span></span><br><span class=\"line\">    Node&lt;K,V&gt; next; <span class=\"comment\">// 前面提到,HashMap使用优化过的拉链法解决Hash冲突，即所有Hash值相同的key通过链表连接，可以看出极端情况get性能会退回为O(N)，所以后面会介绍如何优化，暂时理解为一个简单的链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略get, set, equal, toString....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来看下put方法的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>); <span class=\"comment\">// hash方法求key的index</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>); <span class=\"comment\">// 充分利用高16位以及低16位求hash，避免连续的key产生的hash值具有规律性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) <span class=\"comment\">// table懒加载，第一次存值时才初始化数组</span></span><br><span class=\"line\">        n = (tab = resize()).length; <span class=\"comment\">// 初始化数组，分配给tab变量，resize()后面介绍，返回值为新分配的数组，n为新数组长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>) <span class=\"comment\">// i = (n-1) &amp; hash求出元素下标，前面介绍了字典一般是通过对数组的大小去\b取模求得数组的下标，但是cpu更擅长的是位运算，而前面提到了数组的大小肯定是2的整数次方，即n的二进制格式为00.100..000，那么n-1即为00.011..111的,对这样的一个数进行与运算的结果集就是0到n-1，效果与除法取模一样，但是速度大幅度提升</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>); <span class=\"comment\">// 如果指定下标不存在元素，在下标为i的地方插入新值, newNode方法生成一个Node对象并返回</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果指定下标已经存在元素，进入该分支</span></span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// p为指定下标i位置上的Node元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">// 如果p指向的节点的key与新put进来的key一样</span></span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 如果p指向的节点的key与新Put进来的key不一样，且是TreeNode实例</span></span><br><span class=\"line\">            <span class=\"comment\">// 前面介绍过，HashMap的拉链法是优化过的，就体现在这。如果同一个数组跟着的链表长度大于8，会转化为红黑树，红黑树是一种平衡树，平均复杂度为O(logn),优于链表的O(n)</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value); <span class=\"comment\">// TreeNode版的putVal方法</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// key应该在链表中的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123; <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 如果遍历完链表还没找到相同的key，则key为新的值，添加到链表尾端</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// 如果节点数大于8，则转换为红黑树结构 TREEIFY_THRESHOLD=8</span></span><br><span class=\"line\">                        treeifyBin(tab, hash); <span class=\"comment\">// 将链表转换为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">// put进来的key已经存在，指向Node e</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// put 进来的key已经存在，将value替换</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>) <span class=\"comment\">// @param onlyIfAbsent if true, don't change existing value</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e); <span class=\"comment\">// 方法为空，无操作</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果key是新的值，则进入这里，否则直接返回</span></span><br><span class=\"line\">    ++modCount; <span class=\"comment\">// 改变量记录了对map添加和删除的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold) <span class=\"comment\">// threshold为扩容门槛，如果没有指定，在第一次进行resize()时被置为capacity * load factor，即16*0.75</span></span><br><span class=\"line\">        resize(); <span class=\"comment\">// size记录了table包含的key,value对的数量</span></span><br><span class=\"line\">    afterNodeInsertion(evict); <span class=\"comment\">// 改方法为空，无操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是关于添加元素的部分了，但是对于优化为红黑树的部分没有进行深入介绍。因为红黑树本身的数据结构就比较复杂，不易理解，对红黑树进行插入，平衡，查找的相关操作跟map的关系已经不大，如果有兴趣，可以另外找时间网上搜索一下。需要知道的就是红黑树主要解决的问题是当哈希冲突太多时，链表的查询性能变为O(n),用红黑树替代后可以降低到O(logn)的复杂度，且当链表长度8时才进行这个转变；后面会提到resize()时如果节点数量小于6时，红黑树也会退化为链表。接下来介绍一下前面省略掉的<code>resize()</code>方法：</p>\n<h4 id=\"resize-方法\"><a href=\"#resize-方法\" class=\"headerlink\" title=\"resize()方法\"></a>resize()方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123; <span class=\"comment\">// size超过capacity * load_factory时进行扩容</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class=\"comment\">// 如果已经达到最大的size：2的30次方，不再扩容，直接返回旧table</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class=\"comment\">// 如果旧的容量*2小于2的30次方且旧的容量大于16时将数组大小翻倍</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// table数组还没创建且threshold&gt;0时，将capacity设为threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// table数组还没创建，将capacity设为16，扩容阈值设为16*0.75</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 设置新的扩容阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr; <span class=\"comment\">// threshold重新赋值</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap]; <span class=\"comment\">// 申请一个新的数组，大小为原来数组的两倍</span></span><br><span class=\"line\">    table = newTab;  <span class=\"comment\">// table变量指向新数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123; <span class=\"comment\">// 遍历旧的数组</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 旧数组对应的下标j不为空时，将该下标的元素转移到新数组中</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>; <span class=\"comment\">// 加速GC？猜测</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果对应的下标j只有一个元素，将该元素放到新数组 e.hash &amp; (newCap - 1)处</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 如果下标j对应的Node是红黑树节点</span></span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap); <span class=\"comment\">// 在split函数中，如果节点数量小于static final int UNTREEIFY_THRESHOLD = 6；退化为链表</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 链表Node</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// do-while循环，将链表根据重新e.hash &amp; oldCap是否等于0，分成两个子链表</span></span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// oldCap二进制为00.100.00的格式，是2的整数次方，只有1个1</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 按照新的table大小来计算数组下标时，算式应该是这样的：e.hash &amp; (oldCap*2-1),假设oldCap为16， 则二进制表示为10,000，oldCap*2=32的\b二进制为100,000</span></span><br><span class=\"line\">                    <span class=\"comment\">// 那么上面do-while循环中(e.hash &amp; oldCap) == 0的分支，hash值格式为xx..xx0x,xxx(从右往左第5个数是0，其他任意),与（32-1）做&amp;运算的以及与（15-1）做&amp;运算的结果分别是：</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）xx.xx0x,xxx ---- (16-1)xx.xx0x,xxx</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）0000011,111 ---- (16-1)0000001,111</span></span><br><span class=\"line\">                    <span class=\"comment\">// 结果:-- 000000x,xxx ---- (16-1)000000x,xxx;\b可以看出扩容前后下标的计算值是一样的，所以在新数组同样的\b下标处插入这个链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125; </span><br><span class=\"line\">                    <span class=\"comment\">// 上面do-while循环中(e.hash &amp; oldCap) != 0的分支，hash值格式为xx..xx1x,xxx(oldCap还是16，从右往左第5个数是1，其他任意)，与（32-1）以及（15-1）做&amp;运算的结果分别是：</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）xx.xx1x,xxx ---- (16-1)xx.xx1x,xxx</span></span><br><span class=\"line\">                    <span class=\"comment\">// （32-1）0000011,111 ---- (16-1)0000001,111</span></span><br><span class=\"line\">                    <span class=\"comment\">// 结果:-- 000001x,xxx ---- (16-1)000000x,xxx;可以看出扩容后新的下标值比就的下标值大了16，也就是大了oldCap的值，所以另外一个子链表被放置到新数组j+oldCap下标处，\b这种巧妙的计算下标方式，可以减少重新计算下标的花销，加快扩容的速度</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"TreeNode\"><a href=\"#TreeNode\" class=\"headerlink\" title=\"TreeNode\"></a>TreeNode</h4><p><code>TreeNode</code>的类大概就是这样，很清楚的表明了是个红黑树结构，它的插入，删除，查找等方法被省略了，关于它如果左旋右旋进行rebalance可以去网上搜索相关资料<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">   TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">   TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">   TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">   TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">   <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">   TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// table数组中已经存在元素且hash对应的下标处有元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// \b</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first; <span class=\"comment\">// table数组中hash对应下标的第一个元素，就是要找的元素时返回first</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); <span class=\"comment\">// 如果hash\b对应的node是一个红黑树结构，从红黑树中查找key</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e; <span class=\"comment\">// 在链表中查找key相等的Node</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">        <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// tab = table; p指向key对应的下标所在的Node，如果tab,p为空，return null</span></span><br><span class=\"line\">        Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            node = p; <span class=\"comment\">// key指向的\bNode的第一个元素就是要remove的key时，node=p</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 第一个元素存在，但不是所要找的key时，如果p.next存在，进入</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 该下标的Node为红黑树结构</span></span><br><span class=\"line\">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 该下标的Node为链表，找到对应的key时，node指向key对应的节点，否则node=null</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key ||</span><br><span class=\"line\">                         (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                        node = e;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                             (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123; <span class=\"comment\">// matchValue可选，删除时比较value是否相等，默认不比较</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p) <span class=\"comment\">// key对应链表第一个节点</span></span><br><span class=\"line\">                tab[index] = node.next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">// key对应链表非第一个节点</span></span><br><span class=\"line\">                p.next = node.next;</span><br><span class=\"line\">            ++modCount; <span class=\"comment\">// modCount记录添加和删除等操作的次数，不记录修改value的次数</span></span><br><span class=\"line\">            --size; <span class=\"comment\">// size大小减1</span></span><br><span class=\"line\">            afterNodeRemoval(node); <span class=\"comment\">// 方法为空</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 清空map</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i)</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"for-each遍历\"><a href=\"#for-each遍历\" class=\"headerlink\" title=\"for-each遍历\"></a>for-each遍历</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(BiConsumer&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span> &amp;&amp; (tab = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mc = modCount;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123; <span class=\"comment\">// 按照数组下标从小到大遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next)</span><br><span class=\"line\">                action.accept(e.key, e.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modCount != mc) <span class=\"comment\">// 遍历的时候不允许修改数组结构，修改value除外，如果出现，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// example</span></span><br><span class=\"line\">maps.forEach((k, v) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"key: \"</span> + k + <span class=\"string\">\", value: \"</span> + v); </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面差不多把HashMap常用的方法的源码都介绍了一下，其实还不到源码的一半的内容\b，源码中还有很多关于TreeNode的操作，红黑树相关的操作占了将近一半的篇幅，除此之外还有很多Iterator的类和方法，对于这些Iterator的源码和作用，还没有去研究过，准备把大部分集合代码分析完后，专门写一篇关于迭代器的分析博客。\b(水平有限，如有错误，欢迎提出，可以发邮件或者关注文章底部的微信公众号，谢谢！)</p>\n<h2 id=\"Technique-and-Life\"><a href=\"#Technique-and-Life\" class=\"headerlink\" title=\"Technique and Life\"></a>Technique and Life</h2><p>欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～</p>\n<p><img src=\"https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg\" alt=\"Technique and Life\"></p>"},{"title":"gunicorn源码阅读","date":"2018-08-13T09:03:59.000Z","_content":"## 入口\n\n首先程序的入口为`gunicorn/app/wsgiapp`这个模块。\n\n```python\ndef run():\n    \"\"\"\\\n    The ``gunicorn`` command line runner for launching Gunicorn with\n    generic WSGI applications.\n    \"\"\"\n    from gunicorn.app.wsgiapp import WSGIApplication\n    WSGIApplication(\"%(prog)s [OPTIONS] [APP_MODULE]\").run()\n\n\nif __name__ == '__main__':\n    run()\n```\n\n`WSGIApplication`这个类继承于`Application`,然后继承于`BaseApplication`.而且这三个类只有`BaseApplication`是有构造函数的。\n\n```python\ndef __init__(self, usage=None, prog=None):\n    self.usage = usage\n    self.cfg = None\n    self.callable = None\n    self.prog = prog\n    self.logger = None\n    self.do_load_config()\n```\n\n这里面`useage, prog`就是两个字符串，忽略，其他的下面分析。赋值完后进入`do_load_config`方法。这个方法做了两件事，第一件是将一个Config对象赋值`给self.cfg`参数。这个对象可以从命令行中解析参数，将一些配置绑定。第二件是调用一个在`Application`中才实现的方法`load_config`。这个方法通过各种途径将参数绑定到cfg对象中,其中包括调用一次`WSGIApplicagion`的init方法，同样也是绑定相关参数。\n\n<!--more-->\n但这里有个比较神奇的技巧，关于cfg的，一开始没看懂，看到后来发现cfg中包含了很多可以使用的方法，却不知道是什么时候偷偷绑定上来的。现在来仔细看一下，之前说过了，cfg就是一个`Config`对象。\n\n```python\nKNOWN_SETTINGS = []\n\ndef make_settings(ignore=None):\n    settings = {}\n    ignore = ignore or ()\n    for s in KNOWN_SETTINGS:\n        setting = s()\n        if setting.name in ignore:\n            continue\n        settings[setting.name] = setting.copy()\n    return settings\n\nclass Config(object):\n\n    def __init__(self, usage=None, prog=None):\n        self.settings = make_settings()\n        ...\n```\n目前来看，`KNOWN_SETTINGS`是一个空列表，所以`self.settings`也应该是一个空字典。但其实不然。\n\n```python\nclass SettingMeta(type):\n    def __new__(cls, name, bases, attrs):\n        super_new = super(SettingMeta, cls).__new__\n        parents = [b for b in bases if isinstance(b, SettingMeta)]\n        if not parents:\n            return super_new(cls, name, bases, attrs)\n\n        attrs[\"order\"] = len(KNOWN_SETTINGS)\n        attrs[\"validator\"] = staticmethod(attrs[\"validator\"])\n\n        new_class = super_new(cls, name, bases, attrs)\n        new_class.fmt_desc(attrs.get(\"desc\", \"\"))\n        KNOWN_SETTINGS.append(new_class)\n        return new_class\n\nclass Setting(object):\n    pass\n\nSetting = SettingMeta('Setting', (Setting,), {})\n\nclass Workers(Setting):\n    name = 'xxx'\n    ...\n    validator = xxx\n    pass\n```\n\nconfig.py这个模块中还有很多个类似`Workers`一样的类，结构都是差不多的，首先都是继承`Setting`类，而`Setting`类是一个由`SettingMeta`创造出来的类，\b大家应该都知道创造类是__new__这个方法来完成的，这里也不例外，在__new__方法中，通过type这个元类来生成一个新的类，并通过`attrs[\"validator\"] = staticmethod(attrs[\"validator\"])`来给类绑定一个方法。同时将新的`Setting`类加入`KNOWN_SETTINGS`中，这样后续定义的类似`Workers`的类都会被加入列表中，从而绑定到cfg这个对象上。\n\n简单的说，在调用run方法之前，初始化了一些参数，主要是给cfg这个对象绑定了很多熟悉和方法。\n\n## run方法\n\n`run`方法最终调用的是`Arbiter`对象的run方法，创建`Arbiter`对象时传入`Application`对象作为参数。根据类注释，可以很清楚的了解这个类的主要作用。\n\n```python\nclass Arbiter(object):\n    \"\"\"\n    Arbiter maintain the workers processes alive. It launches or\n    kills them if needed. It also manages application reloading\n    via SIGHUP/USR2.\n    \"\"\"\n    ...\n        def run(self):\n        \"Main master loop.\"\n        self.start()\n        ...\n        try:\n            self.manage_workers()\n\n            while True:\n                self.maybe_promote_master()\n\n                ...\n        ...\n        except Exception:\n            ...\n            sys.exit(-1)\n```\n在`Arbiter`的run方法中，先调用start()来创建socket监听,然后通过manage_workers()来控制worker的数量，现在来看下`manage_workers`的代码。\n\n```python\n    def manage_workers(self):\n        \"\"\"\\\n        Maintain the number of workers by spawning or killing\n        as required.\n        \"\"\"\n        if len(self.WORKERS.keys()) < self.num_workers:\n            self.spawn_workers()\n        workers = self.WORKERS.items()\n        workers = sorted(workers, key=lambda w: w[1].age)\n        while len(workers) > self.num_workers:\n            (pid, _) = workers.pop(0)\n            self.kill_worker(pid, signal.SIGTERM)\n        ...\n\n    def spawn_workers(self):\n        \"\"\"\\\n        Spawn new workers as needed.\n\n        This is where a worker process leaves the main loop\n        of the master process.\n        \"\"\"\n\n        for _ in range(self.num_workers - len(self.WORKERS.keys())):\n            self.spawn_worker()\n            time.sleep(0.1 * random.random())\n\n    def spawn_worker(self):\n        self.worker_age += 1\n        worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,\n                                   self.app, self.timeout / 2.0,\n                                   self.cfg, self.log)\n        self.cfg.pre_fork(self, worker)\n        pid = os.fork()\n        if pid != 0:\n            worker.pid = pid\n            self.WORKERS[pid] = worker\n            return pid\n\n        # Do not inherit the temporary files of other workers\n        for sibling in self.WORKERS.values():\n            sibling.tmp.close()\n\n        # Process Child\n        worker.pid = os.getpid()\n        try:\n            util._setproctitle(\"worker [%s]\" % self.proc_name)\n            self.log.info(\"Booting worker with pid: %s\", worker.pid)\n            self.cfg.post_fork(self, worker)\n            worker.init_process()\n            sys.exit(0)\n        except SystemExit:\n            raise\n        ...\n```\n\n如果worker少于cfg.num_workers，调用spawn_workers方法增加worker数量，增加的方法就是os.fork()。\n如果数量大于cfg.num_workers，根据worker.age的属性排序后kill一个worker。\n\n我们主要看下增加worker的过程，增加worker是通过调用os.fork来实现的，\b调用os.fork的进程称为主进程，生成的进程称为子进程，对于这两个进程，os.fork的返回值是不一样的，子进程的返回值是0，父进程返回的是子进程的进程id。所以如果是主进程则记录子进程id后返回到run里的无限循环。如果是子进程，则成为一个worker进程，执行worker.init_process()。正常情况不会执行`sys.exit(0)`语句。\n\n我们现在回到刚才os.fork的主进程，他执行完os.fork后就返回到run里的无限循环.\n```python\n        try:\n            self.manage_workers()\n\n            while True:\n                self.maybe_promote_master()\n\n                sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None\n                if sig is None:\n                    self.sleep()\n                    self.murder_workers()\n                    self.manage_workers()\n                    continue\n\n                if sig not in self.SIG_NAMES:\n                    self.log.info(\"Ignoring unknown signal: %s\", sig)\n                    continue\n\n                signame = self.SIG_NAMES.get(sig)\n                handler = getattr(self, \"handle_%s\" % signame, None)\n                if not handler:\n                    self.log.error(\"Unhandled signal: %s\", signame)\n                    continue\n                self.log.info(\"Handling signal: %s\", signame)\n                handler()\n                self.wakeup()\n        except StopIteration:\n            self.halt()\n        except KeyboardInterrupt:\n            self.halt()\n        except HaltServer as inst:\n            self.halt(reason=inst.reason, exit_status=inst.exit_status)\n        except SystemExit:\n            raise\n        except Exception:\n            self.log.info(\"Unhandled exception in main loop\",\n                          exc_info=True)\n            self.stop(False)\n            if self.pidfile is not None:\n                self.pidfile.unlink()\n            sys.exit(-1)\n```\n\n主进程在执行`maybe_promote_master`方法，将自己\b标识为master进程，然后根据信号量来进行一些控制进程的操作。如果信号量为空，则通过sleep方法进入睡眠状态，sleep的代码是这样的：\n\n```python\n    def sleep(self):\n        \"\"\"\\\n        Sleep until PIPE is readable or we timeout.\n        A readable PIPE means a signal occurred.\n        \"\"\"\n        try:\n            ready = select.select([self.PIPE[0]], [], [], 1.0)\n            if not ready[0]:\n                return\n            while os.read(self.PIPE[0], 1):\n                pass\n        except (select.error, OSError) as e:\n            # TODO: select.error is a subclass of OSError since Python 3.3.\n            error_number = getattr(e, 'errno', e.args[0])\n            if error_number not in [errno.EAGAIN, errno.EINTR]:\n                raise\n        except KeyboardInterrupt:\n            sys.exit()\n```\n循环的监听管道，如果有信号量就退出循环，关于select这一块我也不是很清楚。退出循环后回到上一段的循环中,首先保持worker的数量为配置信息里的值，然后读取信号量的名字，根据不同的名字调用不同的hander方法。之后不断的重复，master进程大概就是这样。\n\n\n## Worker进程\n\n通过上面的分析，可以看出来worker进程才是真正用来处理请求的进程，入口是`worker.init_process()`.这个worker的来历大概是这样的，`worker -> self.work_class(*args) -> self.cfg.worker_class() -> util.load_class()`。util.load_class接受一个字符串参数，是配置中的`worker_class`变量，默认为SyncWorker。但是也能变成gevent, threadworker等更高效的worker.我们先看下默认的SyncWorker的逻辑是怎么样的。\n\n所有的worker模块都在gunicorn/workers包中。`SyncWorker`继承自base.Worker.`SyncWorker`的init_process()方法来自于父类。\n\n```python\n    def init_process(self):\n        \"\"\"\\\n        If you override this method in a subclass, the last statement\n        in the function should be to call this method with\n        super(MyWorkerClass, self).init_process() so that the ``run()``\n        loop is initiated.\n        \"\"\"\n\n        # set environment' variables\n        if self.cfg.env:\n            for k, v in self.cfg.env.items():\n                os.environ[k] = v\n\n        util.set_owner_process(self.cfg.uid, self.cfg.gid,\n                               initgroups=self.cfg.initgroups)\n\n        # Reseed the random number generator\n        util.seed()\n\n        # For waking ourselves up\n        self.PIPE = os.pipe()\n        for p in self.PIPE:\n            util.set_non_blocking(p)\n            util.close_on_exec(p)\n\n        # Prevent fd inheritance\n        for s in self.sockets:\n            util.close_on_exec(s)\n        util.close_on_exec(self.tmp.fileno())\n\n        self.wait_fds = self.sockets + [self.PIPE[0]]\n\n        self.log.close_on_exec()\n\n        self.init_signals()\n\n        # start the reloader\n        if self.cfg.reload:\n            def changed(fname):\n                self.log.info(\"Worker reloading: %s modified\", fname)\n                self.alive = False\n                self.cfg.worker_int(self)\n                time.sleep(0.1)\n                sys.exit(0)\n\n            reloader_cls = reloader_engines[self.cfg.reload_engine]\n            self.reloader = reloader_cls(extra_files=self.cfg.reload_extra_files,\n                                         callback=changed)\n            self.reloader.start()\n\n        self.load_wsgi()\n        self.cfg.post_worker_init(self)\n\n        # Enter main run loop\n        self.booted = True\n        self.run()\n```\n\n1. init_signals()注册信号量\n2. load_wsgi()： self.wsgi = self.app.wsgi()，一般就是python框架里起的app，比如Flask里的`app = Flask(__name__)`.\n3. run(). 现在我们到syncworker的run方法看一看。\n\n```python\n    def run(self):\n        timeout = self.timeout or 0.5\n\n        for s in self.sockets:\n            s.setblocking(0)\n\n        if len(self.sockets) > 1:\n            self.run_for_multiple(timeout)\n        else:\n            self.run_for_one(timeout)\n    \n    def run_for_one(self, timeout):\n        listener = self.sockets[0]\n        while self.alive:\n            self.notify()\n            try:\n                self.accept(listener)\n                continue\n            except EnvironmentError as e:\n                if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                        errno.EWOULDBLOCK):\n                    raise\n\n            if not self.is_parent_alive():\n                return\n\n            try:\n                self.wait(timeout)\n            except StopWaiting:\n                return\n\n    def run_for_multiple(self, timeout):\n        while self.alive:\n            self.notify()\n            try:\n                ready = self.wait(timeout)\n            except StopWaiting:\n                return\n\n            if ready is not None:\n                for listener in ready:\n                    if listener == self.PIPE[0]:\n                        continue\n\n                    try:\n                        self.accept(listener)\n                    except EnvironmentError as e:\n                        if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                                errno.EWOULDBLOCK):\n                            raise\n\n            if not self.is_parent_alive():\n                return\n```\n\n我把一些注释删了，run方法之后进入的两个方法同样也都是无限循环，不断的接收socket。`accept`方法很简洁，就是在建立连接的socket上获取client端的地址等信息，并设置socket为阻塞的，也就是同一时间只能处理一个请求。然后调用handle方法处理请求，handle方法如下：\n\n```python\n    def handle(self, listener, client, addr):\n        req = None\n        try:\n            if self.cfg.is_ssl:\n                client = ssl.wrap_socket(client, server_side=True,\n                    **self.cfg.ssl_options)\n\n            parser = http.RequestParser(self.cfg, client)\n            req = six.next(parser)\n            self.handle_request(listener, req, client, addr)\n        except http.errors.NoMoreData as e:\n            self.log.debug(\"Ignored premature client disconnection. %s\", e)\n        except StopIteration as e:\n            self.log.debug(\"Closing connection. %s\", e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                client.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, client, addr, e)\n        except EnvironmentError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                else:\n                    self.log.debug(\"Ignoring EPIPE\")\n        except Exception as e:\n            self.handle_error(req, client, addr, e)\n        finally:\n            util.close(client)\n\n    def handle_request(self, listener, req, client, addr):\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            request_start = datetime.now()\n            resp, environ = wsgi.create(req, client, addr,\n                    listener.getsockname(), self.cfg)\n            # Force the connection closed until someone shows\n            # a buffering proxy that supports Keep-Alive to\n            # the backend.\n            resp.force_close()\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                self.log.info(\"Autorestarting worker after current request.\")\n                self.alive = False\n            respiter = self.wsgi(environ, resp.start_response)\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n                resp.close()\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n            finally:\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n        except EnvironmentError:\n            # pass to next try-except level\n            six.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    client.shutdown(socket.SHUT_RDWR)\n                    client.close()\n                except EnvironmentError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")\n```\n了解过wsgi协议的应该知道，服务器是如何跟框架交互的。简单的说就是服务器会调用一个方法并传入两个参数，第一个参数为environ,这个参数包含了所有请求有关的信息，比如headers, body等等。第二个参数是一个回调函数，后台服务处理完业务后调用这个函数将response传给服务器，服务器再传给客户端。但是这里还有很多细节，水平有限，看不大明白，但是整体的流程应该还是很清楚。所以这里先parser了http请求的相关信息，保存在environ中，然后生成回调函数resp.strt_response，然后调用wsgi(environ, resp.start_response)。这里的wsgi就是框架中的app.\n\n## GeventWorker\n\n我最近接触到的是配合gevent起一个服务，所以我也分析一下geventworker的逻辑。首先geventworker继承自asyncworker，asyncworker继承自base.worker。上面提到了，默认的worker是一个阻塞的模型，同一时间只能处理一个请求，所以效率比较低，生产环境一般不会使用。\n\n### AsyncWorker\n\n`AsyncWorker`的构造函数先是调用了父类的构造函数，然后又添加了一个额外的参数`worker_connections`，这个参数也是在cfg中设置的，且只在`eventlet`和`gevent`两种模式下起作用，作用是限制最大的同时的客户端连接数。\n\n前面的SyncWorker的init_process是继承自worker。但是GeventWorker重写了这个方法。用过gevent的应该知道，gevent底层实现的方法叫做猴子补丁-monkey_patch。修改了大多数的底层库，将一些阻塞的底层实现，重新换成非阻塞的。所以GeventWorker先是打上补丁，然后调用worker的init_process方法，最终进入GeventWorker的run方法开始执行处理请求任务。run方法代码如下：\n```python\n    def run(self):\n        ...\n        for s in self.sockets:\n            s.setblocking(1)\n            pool = Pool(self.worker_connections)\n            if self.server_class is not None:\n                environ = base_environ(self.cfg)\n                environ.update({\n                    \"wsgi.multithread\": True,\n                    \"SERVER_SOFTWARE\": VERSION,\n                })\n                server = self.server_class(\n                    s, application=self.wsgi, spawn=pool, log=self.log,\n                    handler_class=self.wsgi_handler, environ=environ,\n                    **ssl_args)\n            else:\n                hfun = partial(self.handle, s)\n                server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args)\n\n            server.start()\n            servers.append(server)\n\n        while self.alive:\n            self.notify()\n            gevent.sleep(1.0)\n\n        try:\n            # Stop accepting requests\n            for server in servers:\n                if hasattr(server, 'close'):  # gevent 1.0\n                    server.close()\n                if hasattr(server, 'kill'):  # gevent < 1.0\n                    server.kill()\n\n            # Handle current requests until graceful_timeout\n            ts = time.time()\n            while time.time() - ts <= self.cfg.graceful_timeout:\n                accepting = 0\n                for server in servers:\n                    if server.pool.free_count() != server.pool.size:\n                        accepting += 1\n\n                # if no server is accepting a connection, we can exit\n                if not accepting:\n                    return\n\n                self.notify()\n                gevent.sleep(1.0)\n\n            # Force kill all active the handlers\n            self.log.warning(\"Worker graceful timeout (pid:%s)\" % self.pid)\n            for server in servers:\n                server.stop(timeout=1)\n        except:\n            pass\n```\n1. 创建tcpServer。并用pool限制了最大连接数。这个server的实现在gevent中，没看懂。\n2. hfun这个方法，是一个绑定了参数的handle，是asyncWorker的handle。过程跟前面的同步的差不多。但是遇到阻塞是gevent会帮助切换，所以提高了并发量。\n3. 创建完server进入无限循环，notify网上查了一下说是给Arbiter发信号的，这里我不大懂。\n\n\n## 总结\n\ngunicorn代码比较多，且有很多底层的东西。很多地方不懂，都跳过了，分析可能也有很多错误，看到可以指出。\n\n相比于之前看过的flask、request、tornado等等。gunicorn显然难很多，也没有那么清晰，有很多方法，参数来的不明不白；而且跟gevent牵扯很大，gevent的代码更加难懂。\n\n但应该还是有点收获吧，虽然暂时没察觉到～\n","source":"_posts/gunicorn源码阅读.md","raw":"---\ntitle: gunicorn源码阅读\ndate: 2018-08-13 17:03:59\ntags:\n    - Python\n---\n## 入口\n\n首先程序的入口为`gunicorn/app/wsgiapp`这个模块。\n\n```python\ndef run():\n    \"\"\"\\\n    The ``gunicorn`` command line runner for launching Gunicorn with\n    generic WSGI applications.\n    \"\"\"\n    from gunicorn.app.wsgiapp import WSGIApplication\n    WSGIApplication(\"%(prog)s [OPTIONS] [APP_MODULE]\").run()\n\n\nif __name__ == '__main__':\n    run()\n```\n\n`WSGIApplication`这个类继承于`Application`,然后继承于`BaseApplication`.而且这三个类只有`BaseApplication`是有构造函数的。\n\n```python\ndef __init__(self, usage=None, prog=None):\n    self.usage = usage\n    self.cfg = None\n    self.callable = None\n    self.prog = prog\n    self.logger = None\n    self.do_load_config()\n```\n\n这里面`useage, prog`就是两个字符串，忽略，其他的下面分析。赋值完后进入`do_load_config`方法。这个方法做了两件事，第一件是将一个Config对象赋值`给self.cfg`参数。这个对象可以从命令行中解析参数，将一些配置绑定。第二件是调用一个在`Application`中才实现的方法`load_config`。这个方法通过各种途径将参数绑定到cfg对象中,其中包括调用一次`WSGIApplicagion`的init方法，同样也是绑定相关参数。\n\n<!--more-->\n但这里有个比较神奇的技巧，关于cfg的，一开始没看懂，看到后来发现cfg中包含了很多可以使用的方法，却不知道是什么时候偷偷绑定上来的。现在来仔细看一下，之前说过了，cfg就是一个`Config`对象。\n\n```python\nKNOWN_SETTINGS = []\n\ndef make_settings(ignore=None):\n    settings = {}\n    ignore = ignore or ()\n    for s in KNOWN_SETTINGS:\n        setting = s()\n        if setting.name in ignore:\n            continue\n        settings[setting.name] = setting.copy()\n    return settings\n\nclass Config(object):\n\n    def __init__(self, usage=None, prog=None):\n        self.settings = make_settings()\n        ...\n```\n目前来看，`KNOWN_SETTINGS`是一个空列表，所以`self.settings`也应该是一个空字典。但其实不然。\n\n```python\nclass SettingMeta(type):\n    def __new__(cls, name, bases, attrs):\n        super_new = super(SettingMeta, cls).__new__\n        parents = [b for b in bases if isinstance(b, SettingMeta)]\n        if not parents:\n            return super_new(cls, name, bases, attrs)\n\n        attrs[\"order\"] = len(KNOWN_SETTINGS)\n        attrs[\"validator\"] = staticmethod(attrs[\"validator\"])\n\n        new_class = super_new(cls, name, bases, attrs)\n        new_class.fmt_desc(attrs.get(\"desc\", \"\"))\n        KNOWN_SETTINGS.append(new_class)\n        return new_class\n\nclass Setting(object):\n    pass\n\nSetting = SettingMeta('Setting', (Setting,), {})\n\nclass Workers(Setting):\n    name = 'xxx'\n    ...\n    validator = xxx\n    pass\n```\n\nconfig.py这个模块中还有很多个类似`Workers`一样的类，结构都是差不多的，首先都是继承`Setting`类，而`Setting`类是一个由`SettingMeta`创造出来的类，\b大家应该都知道创造类是__new__这个方法来完成的，这里也不例外，在__new__方法中，通过type这个元类来生成一个新的类，并通过`attrs[\"validator\"] = staticmethod(attrs[\"validator\"])`来给类绑定一个方法。同时将新的`Setting`类加入`KNOWN_SETTINGS`中，这样后续定义的类似`Workers`的类都会被加入列表中，从而绑定到cfg这个对象上。\n\n简单的说，在调用run方法之前，初始化了一些参数，主要是给cfg这个对象绑定了很多熟悉和方法。\n\n## run方法\n\n`run`方法最终调用的是`Arbiter`对象的run方法，创建`Arbiter`对象时传入`Application`对象作为参数。根据类注释，可以很清楚的了解这个类的主要作用。\n\n```python\nclass Arbiter(object):\n    \"\"\"\n    Arbiter maintain the workers processes alive. It launches or\n    kills them if needed. It also manages application reloading\n    via SIGHUP/USR2.\n    \"\"\"\n    ...\n        def run(self):\n        \"Main master loop.\"\n        self.start()\n        ...\n        try:\n            self.manage_workers()\n\n            while True:\n                self.maybe_promote_master()\n\n                ...\n        ...\n        except Exception:\n            ...\n            sys.exit(-1)\n```\n在`Arbiter`的run方法中，先调用start()来创建socket监听,然后通过manage_workers()来控制worker的数量，现在来看下`manage_workers`的代码。\n\n```python\n    def manage_workers(self):\n        \"\"\"\\\n        Maintain the number of workers by spawning or killing\n        as required.\n        \"\"\"\n        if len(self.WORKERS.keys()) < self.num_workers:\n            self.spawn_workers()\n        workers = self.WORKERS.items()\n        workers = sorted(workers, key=lambda w: w[1].age)\n        while len(workers) > self.num_workers:\n            (pid, _) = workers.pop(0)\n            self.kill_worker(pid, signal.SIGTERM)\n        ...\n\n    def spawn_workers(self):\n        \"\"\"\\\n        Spawn new workers as needed.\n\n        This is where a worker process leaves the main loop\n        of the master process.\n        \"\"\"\n\n        for _ in range(self.num_workers - len(self.WORKERS.keys())):\n            self.spawn_worker()\n            time.sleep(0.1 * random.random())\n\n    def spawn_worker(self):\n        self.worker_age += 1\n        worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,\n                                   self.app, self.timeout / 2.0,\n                                   self.cfg, self.log)\n        self.cfg.pre_fork(self, worker)\n        pid = os.fork()\n        if pid != 0:\n            worker.pid = pid\n            self.WORKERS[pid] = worker\n            return pid\n\n        # Do not inherit the temporary files of other workers\n        for sibling in self.WORKERS.values():\n            sibling.tmp.close()\n\n        # Process Child\n        worker.pid = os.getpid()\n        try:\n            util._setproctitle(\"worker [%s]\" % self.proc_name)\n            self.log.info(\"Booting worker with pid: %s\", worker.pid)\n            self.cfg.post_fork(self, worker)\n            worker.init_process()\n            sys.exit(0)\n        except SystemExit:\n            raise\n        ...\n```\n\n如果worker少于cfg.num_workers，调用spawn_workers方法增加worker数量，增加的方法就是os.fork()。\n如果数量大于cfg.num_workers，根据worker.age的属性排序后kill一个worker。\n\n我们主要看下增加worker的过程，增加worker是通过调用os.fork来实现的，\b调用os.fork的进程称为主进程，生成的进程称为子进程，对于这两个进程，os.fork的返回值是不一样的，子进程的返回值是0，父进程返回的是子进程的进程id。所以如果是主进程则记录子进程id后返回到run里的无限循环。如果是子进程，则成为一个worker进程，执行worker.init_process()。正常情况不会执行`sys.exit(0)`语句。\n\n我们现在回到刚才os.fork的主进程，他执行完os.fork后就返回到run里的无限循环.\n```python\n        try:\n            self.manage_workers()\n\n            while True:\n                self.maybe_promote_master()\n\n                sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None\n                if sig is None:\n                    self.sleep()\n                    self.murder_workers()\n                    self.manage_workers()\n                    continue\n\n                if sig not in self.SIG_NAMES:\n                    self.log.info(\"Ignoring unknown signal: %s\", sig)\n                    continue\n\n                signame = self.SIG_NAMES.get(sig)\n                handler = getattr(self, \"handle_%s\" % signame, None)\n                if not handler:\n                    self.log.error(\"Unhandled signal: %s\", signame)\n                    continue\n                self.log.info(\"Handling signal: %s\", signame)\n                handler()\n                self.wakeup()\n        except StopIteration:\n            self.halt()\n        except KeyboardInterrupt:\n            self.halt()\n        except HaltServer as inst:\n            self.halt(reason=inst.reason, exit_status=inst.exit_status)\n        except SystemExit:\n            raise\n        except Exception:\n            self.log.info(\"Unhandled exception in main loop\",\n                          exc_info=True)\n            self.stop(False)\n            if self.pidfile is not None:\n                self.pidfile.unlink()\n            sys.exit(-1)\n```\n\n主进程在执行`maybe_promote_master`方法，将自己\b标识为master进程，然后根据信号量来进行一些控制进程的操作。如果信号量为空，则通过sleep方法进入睡眠状态，sleep的代码是这样的：\n\n```python\n    def sleep(self):\n        \"\"\"\\\n        Sleep until PIPE is readable or we timeout.\n        A readable PIPE means a signal occurred.\n        \"\"\"\n        try:\n            ready = select.select([self.PIPE[0]], [], [], 1.0)\n            if not ready[0]:\n                return\n            while os.read(self.PIPE[0], 1):\n                pass\n        except (select.error, OSError) as e:\n            # TODO: select.error is a subclass of OSError since Python 3.3.\n            error_number = getattr(e, 'errno', e.args[0])\n            if error_number not in [errno.EAGAIN, errno.EINTR]:\n                raise\n        except KeyboardInterrupt:\n            sys.exit()\n```\n循环的监听管道，如果有信号量就退出循环，关于select这一块我也不是很清楚。退出循环后回到上一段的循环中,首先保持worker的数量为配置信息里的值，然后读取信号量的名字，根据不同的名字调用不同的hander方法。之后不断的重复，master进程大概就是这样。\n\n\n## Worker进程\n\n通过上面的分析，可以看出来worker进程才是真正用来处理请求的进程，入口是`worker.init_process()`.这个worker的来历大概是这样的，`worker -> self.work_class(*args) -> self.cfg.worker_class() -> util.load_class()`。util.load_class接受一个字符串参数，是配置中的`worker_class`变量，默认为SyncWorker。但是也能变成gevent, threadworker等更高效的worker.我们先看下默认的SyncWorker的逻辑是怎么样的。\n\n所有的worker模块都在gunicorn/workers包中。`SyncWorker`继承自base.Worker.`SyncWorker`的init_process()方法来自于父类。\n\n```python\n    def init_process(self):\n        \"\"\"\\\n        If you override this method in a subclass, the last statement\n        in the function should be to call this method with\n        super(MyWorkerClass, self).init_process() so that the ``run()``\n        loop is initiated.\n        \"\"\"\n\n        # set environment' variables\n        if self.cfg.env:\n            for k, v in self.cfg.env.items():\n                os.environ[k] = v\n\n        util.set_owner_process(self.cfg.uid, self.cfg.gid,\n                               initgroups=self.cfg.initgroups)\n\n        # Reseed the random number generator\n        util.seed()\n\n        # For waking ourselves up\n        self.PIPE = os.pipe()\n        for p in self.PIPE:\n            util.set_non_blocking(p)\n            util.close_on_exec(p)\n\n        # Prevent fd inheritance\n        for s in self.sockets:\n            util.close_on_exec(s)\n        util.close_on_exec(self.tmp.fileno())\n\n        self.wait_fds = self.sockets + [self.PIPE[0]]\n\n        self.log.close_on_exec()\n\n        self.init_signals()\n\n        # start the reloader\n        if self.cfg.reload:\n            def changed(fname):\n                self.log.info(\"Worker reloading: %s modified\", fname)\n                self.alive = False\n                self.cfg.worker_int(self)\n                time.sleep(0.1)\n                sys.exit(0)\n\n            reloader_cls = reloader_engines[self.cfg.reload_engine]\n            self.reloader = reloader_cls(extra_files=self.cfg.reload_extra_files,\n                                         callback=changed)\n            self.reloader.start()\n\n        self.load_wsgi()\n        self.cfg.post_worker_init(self)\n\n        # Enter main run loop\n        self.booted = True\n        self.run()\n```\n\n1. init_signals()注册信号量\n2. load_wsgi()： self.wsgi = self.app.wsgi()，一般就是python框架里起的app，比如Flask里的`app = Flask(__name__)`.\n3. run(). 现在我们到syncworker的run方法看一看。\n\n```python\n    def run(self):\n        timeout = self.timeout or 0.5\n\n        for s in self.sockets:\n            s.setblocking(0)\n\n        if len(self.sockets) > 1:\n            self.run_for_multiple(timeout)\n        else:\n            self.run_for_one(timeout)\n    \n    def run_for_one(self, timeout):\n        listener = self.sockets[0]\n        while self.alive:\n            self.notify()\n            try:\n                self.accept(listener)\n                continue\n            except EnvironmentError as e:\n                if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                        errno.EWOULDBLOCK):\n                    raise\n\n            if not self.is_parent_alive():\n                return\n\n            try:\n                self.wait(timeout)\n            except StopWaiting:\n                return\n\n    def run_for_multiple(self, timeout):\n        while self.alive:\n            self.notify()\n            try:\n                ready = self.wait(timeout)\n            except StopWaiting:\n                return\n\n            if ready is not None:\n                for listener in ready:\n                    if listener == self.PIPE[0]:\n                        continue\n\n                    try:\n                        self.accept(listener)\n                    except EnvironmentError as e:\n                        if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                                errno.EWOULDBLOCK):\n                            raise\n\n            if not self.is_parent_alive():\n                return\n```\n\n我把一些注释删了，run方法之后进入的两个方法同样也都是无限循环，不断的接收socket。`accept`方法很简洁，就是在建立连接的socket上获取client端的地址等信息，并设置socket为阻塞的，也就是同一时间只能处理一个请求。然后调用handle方法处理请求，handle方法如下：\n\n```python\n    def handle(self, listener, client, addr):\n        req = None\n        try:\n            if self.cfg.is_ssl:\n                client = ssl.wrap_socket(client, server_side=True,\n                    **self.cfg.ssl_options)\n\n            parser = http.RequestParser(self.cfg, client)\n            req = six.next(parser)\n            self.handle_request(listener, req, client, addr)\n        except http.errors.NoMoreData as e:\n            self.log.debug(\"Ignored premature client disconnection. %s\", e)\n        except StopIteration as e:\n            self.log.debug(\"Closing connection. %s\", e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                client.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, client, addr, e)\n        except EnvironmentError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                else:\n                    self.log.debug(\"Ignoring EPIPE\")\n        except Exception as e:\n            self.handle_error(req, client, addr, e)\n        finally:\n            util.close(client)\n\n    def handle_request(self, listener, req, client, addr):\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            request_start = datetime.now()\n            resp, environ = wsgi.create(req, client, addr,\n                    listener.getsockname(), self.cfg)\n            # Force the connection closed until someone shows\n            # a buffering proxy that supports Keep-Alive to\n            # the backend.\n            resp.force_close()\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                self.log.info(\"Autorestarting worker after current request.\")\n                self.alive = False\n            respiter = self.wsgi(environ, resp.start_response)\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n                resp.close()\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n            finally:\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n        except EnvironmentError:\n            # pass to next try-except level\n            six.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    client.shutdown(socket.SHUT_RDWR)\n                    client.close()\n                except EnvironmentError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")\n```\n了解过wsgi协议的应该知道，服务器是如何跟框架交互的。简单的说就是服务器会调用一个方法并传入两个参数，第一个参数为environ,这个参数包含了所有请求有关的信息，比如headers, body等等。第二个参数是一个回调函数，后台服务处理完业务后调用这个函数将response传给服务器，服务器再传给客户端。但是这里还有很多细节，水平有限，看不大明白，但是整体的流程应该还是很清楚。所以这里先parser了http请求的相关信息，保存在environ中，然后生成回调函数resp.strt_response，然后调用wsgi(environ, resp.start_response)。这里的wsgi就是框架中的app.\n\n## GeventWorker\n\n我最近接触到的是配合gevent起一个服务，所以我也分析一下geventworker的逻辑。首先geventworker继承自asyncworker，asyncworker继承自base.worker。上面提到了，默认的worker是一个阻塞的模型，同一时间只能处理一个请求，所以效率比较低，生产环境一般不会使用。\n\n### AsyncWorker\n\n`AsyncWorker`的构造函数先是调用了父类的构造函数，然后又添加了一个额外的参数`worker_connections`，这个参数也是在cfg中设置的，且只在`eventlet`和`gevent`两种模式下起作用，作用是限制最大的同时的客户端连接数。\n\n前面的SyncWorker的init_process是继承自worker。但是GeventWorker重写了这个方法。用过gevent的应该知道，gevent底层实现的方法叫做猴子补丁-monkey_patch。修改了大多数的底层库，将一些阻塞的底层实现，重新换成非阻塞的。所以GeventWorker先是打上补丁，然后调用worker的init_process方法，最终进入GeventWorker的run方法开始执行处理请求任务。run方法代码如下：\n```python\n    def run(self):\n        ...\n        for s in self.sockets:\n            s.setblocking(1)\n            pool = Pool(self.worker_connections)\n            if self.server_class is not None:\n                environ = base_environ(self.cfg)\n                environ.update({\n                    \"wsgi.multithread\": True,\n                    \"SERVER_SOFTWARE\": VERSION,\n                })\n                server = self.server_class(\n                    s, application=self.wsgi, spawn=pool, log=self.log,\n                    handler_class=self.wsgi_handler, environ=environ,\n                    **ssl_args)\n            else:\n                hfun = partial(self.handle, s)\n                server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args)\n\n            server.start()\n            servers.append(server)\n\n        while self.alive:\n            self.notify()\n            gevent.sleep(1.0)\n\n        try:\n            # Stop accepting requests\n            for server in servers:\n                if hasattr(server, 'close'):  # gevent 1.0\n                    server.close()\n                if hasattr(server, 'kill'):  # gevent < 1.0\n                    server.kill()\n\n            # Handle current requests until graceful_timeout\n            ts = time.time()\n            while time.time() - ts <= self.cfg.graceful_timeout:\n                accepting = 0\n                for server in servers:\n                    if server.pool.free_count() != server.pool.size:\n                        accepting += 1\n\n                # if no server is accepting a connection, we can exit\n                if not accepting:\n                    return\n\n                self.notify()\n                gevent.sleep(1.0)\n\n            # Force kill all active the handlers\n            self.log.warning(\"Worker graceful timeout (pid:%s)\" % self.pid)\n            for server in servers:\n                server.stop(timeout=1)\n        except:\n            pass\n```\n1. 创建tcpServer。并用pool限制了最大连接数。这个server的实现在gevent中，没看懂。\n2. hfun这个方法，是一个绑定了参数的handle，是asyncWorker的handle。过程跟前面的同步的差不多。但是遇到阻塞是gevent会帮助切换，所以提高了并发量。\n3. 创建完server进入无限循环，notify网上查了一下说是给Arbiter发信号的，这里我不大懂。\n\n\n## 总结\n\ngunicorn代码比较多，且有很多底层的东西。很多地方不懂，都跳过了，分析可能也有很多错误，看到可以指出。\n\n相比于之前看过的flask、request、tornado等等。gunicorn显然难很多，也没有那么清晰，有很多方法，参数来的不明不白；而且跟gevent牵扯很大，gevent的代码更加难懂。\n\n但应该还是有点收获吧，虽然暂时没察觉到～\n","slug":"gunicorn源码阅读","published":1,"updated":"2019-02-03T07:16:46.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrpqkllh000xuetugcr9kwrl","content":"<h2 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h2><p>首先程序的入口为<code>gunicorn/app/wsgiapp</code>这个模块。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    The ``gunicorn`` command line runner for launching Gunicorn with</span></span><br><span class=\"line\"><span class=\"string\">    generic WSGI applications.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> gunicorn.app.wsgiapp <span class=\"keyword\">import</span> WSGIApplication</span><br><span class=\"line\">    WSGIApplication(<span class=\"string\">\"%(prog)s [OPTIONS] [APP_MODULE]\"</span>).run()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    run()</span><br></pre></td></tr></table></figure>\n<p><code>WSGIApplication</code>这个类继承于<code>Application</code>,然后继承于<code>BaseApplication</code>.而且这三个类只有<code>BaseApplication</code>是有构造函数的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, usage=None, prog=None)</span>:</span></span><br><span class=\"line\">    self.usage = usage</span><br><span class=\"line\">    self.cfg = <span class=\"keyword\">None</span></span><br><span class=\"line\">    self.callable = <span class=\"keyword\">None</span></span><br><span class=\"line\">    self.prog = prog</span><br><span class=\"line\">    self.logger = <span class=\"keyword\">None</span></span><br><span class=\"line\">    self.do_load_config()</span><br></pre></td></tr></table></figure>\n<p>这里面<code>useage, prog</code>就是两个字符串，忽略，其他的下面分析。赋值完后进入<code>do_load_config</code>方法。这个方法做了两件事，第一件是将一个Config对象赋值<code>给self.cfg</code>参数。这个对象可以从命令行中解析参数，将一些配置绑定。第二件是调用一个在<code>Application</code>中才实现的方法<code>load_config</code>。这个方法通过各种途径将参数绑定到cfg对象中,其中包括调用一次<code>WSGIApplicagion</code>的init方法，同样也是绑定相关参数。</p>\n<a id=\"more\"></a>\n<p>但这里有个比较神奇的技巧，关于cfg的，一开始没看懂，看到后来发现cfg中包含了很多可以使用的方法，却不知道是什么时候偷偷绑定上来的。现在来仔细看一下，之前说过了，cfg就是一个<code>Config</code>对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KNOWN_SETTINGS = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_settings</span><span class=\"params\">(ignore=None)</span>:</span></span><br><span class=\"line\">    settings = &#123;&#125;</span><br><span class=\"line\">    ignore = ignore <span class=\"keyword\">or</span> ()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> KNOWN_SETTINGS:</span><br><span class=\"line\">        setting = s()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> setting.name <span class=\"keyword\">in</span> ignore:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        settings[setting.name] = setting.copy()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> settings</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, usage=None, prog=None)</span>:</span></span><br><span class=\"line\">        self.settings = make_settings()</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<p>目前来看，<code>KNOWN_SETTINGS</code>是一个空列表，所以<code>self.settings</code>也应该是一个空字典。但其实不然。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SettingMeta</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, name, bases, attrs)</span>:</span></span><br><span class=\"line\">        super_new = super(SettingMeta, cls).__new__</span><br><span class=\"line\">        parents = [b <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> bases <span class=\"keyword\">if</span> isinstance(b, SettingMeta)]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> parents:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> super_new(cls, name, bases, attrs)</span><br><span class=\"line\"></span><br><span class=\"line\">        attrs[<span class=\"string\">\"order\"</span>] = len(KNOWN_SETTINGS)</span><br><span class=\"line\">        attrs[<span class=\"string\">\"validator\"</span>] = staticmethod(attrs[<span class=\"string\">\"validator\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        new_class = super_new(cls, name, bases, attrs)</span><br><span class=\"line\">        new_class.fmt_desc(attrs.get(<span class=\"string\">\"desc\"</span>, <span class=\"string\">\"\"</span>))</span><br><span class=\"line\">        KNOWN_SETTINGS.append(new_class)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_class</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Setting</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">Setting = SettingMeta(<span class=\"string\">'Setting'</span>, (Setting,), &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Workers</span><span class=\"params\">(Setting)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'xxx'</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    validator = xxx</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>config.py这个模块中还有很多个类似<code>Workers</code>一样的类，结构都是差不多的，首先都是继承<code>Setting</code>类，而<code>Setting</code>类是一个由<code>SettingMeta</code>创造出来的类，\b大家应该都知道创造类是<strong>new</strong>这个方法来完成的，这里也不例外，在<strong>new</strong>方法中，通过type这个元类来生成一个新的类，并通过<code>attrs[&quot;validator&quot;] = staticmethod(attrs[&quot;validator&quot;])</code>来给类绑定一个方法。同时将新的<code>Setting</code>类加入<code>KNOWN_SETTINGS</code>中，这样后续定义的类似<code>Workers</code>的类都会被加入列表中，从而绑定到cfg这个对象上。</p>\n<p>简单的说，在调用run方法之前，初始化了一些参数，主要是给cfg这个对象绑定了很多熟悉和方法。</p>\n<h2 id=\"run方法\"><a href=\"#run方法\" class=\"headerlink\" title=\"run方法\"></a>run方法</h2><p><code>run</code>方法最终调用的是<code>Arbiter</code>对象的run方法，创建<code>Arbiter</code>对象时传入<code>Application</code>对象作为参数。根据类注释，可以很清楚的了解这个类的主要作用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arbiter</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Arbiter maintain the workers processes alive. It launches or</span></span><br><span class=\"line\"><span class=\"string\">    kills them if needed. It also manages application reloading</span></span><br><span class=\"line\"><span class=\"string\">    via SIGHUP/USR2.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"Main master loop.\"</span></span><br><span class=\"line\">        self.start()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.manage_workers()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">                self.maybe_promote_master()</span><br><span class=\"line\"></span><br><span class=\"line\">                ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            sys.exit(<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>在<code>Arbiter</code>的run方法中，先调用start()来创建socket监听,然后通过manage_workers()来控制worker的数量，现在来看下<code>manage_workers</code>的代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">manage_workers</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    Maintain the number of workers by spawning or killing</span></span><br><span class=\"line\"><span class=\"string\">    as required.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(self.WORKERS.keys()) &lt; self.num_workers:</span><br><span class=\"line\">        self.spawn_workers()</span><br><span class=\"line\">    workers = self.WORKERS.items()</span><br><span class=\"line\">    workers = sorted(workers, key=<span class=\"keyword\">lambda</span> w: w[<span class=\"number\">1</span>].age)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(workers) &gt; self.num_workers:</span><br><span class=\"line\">        (pid, _) = workers.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">        self.kill_worker(pid, signal.SIGTERM)</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spawn_workers</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    Spawn new workers as needed.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    This is where a worker process leaves the main loop</span></span><br><span class=\"line\"><span class=\"string\">    of the master process.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_workers - len(self.WORKERS.keys())):</span><br><span class=\"line\">        self.spawn_worker()</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.1</span> * random.random())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spawn_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    self.worker_age += <span class=\"number\">1</span></span><br><span class=\"line\">    worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,</span><br><span class=\"line\">                               self.app, self.timeout / <span class=\"number\">2.0</span>,</span><br><span class=\"line\">                               self.cfg, self.log)</span><br><span class=\"line\">    self.cfg.pre_fork(self, worker)</span><br><span class=\"line\">    pid = os.fork()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pid != <span class=\"number\">0</span>:</span><br><span class=\"line\">        worker.pid = pid</span><br><span class=\"line\">        self.WORKERS[pid] = worker</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pid</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Do not inherit the temporary files of other workers</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> sibling <span class=\"keyword\">in</span> self.WORKERS.values():</span><br><span class=\"line\">        sibling.tmp.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Process Child</span></span><br><span class=\"line\">    worker.pid = os.getpid()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        util._setproctitle(<span class=\"string\">\"worker [%s]\"</span> % self.proc_name)</span><br><span class=\"line\">        self.log.info(<span class=\"string\">\"Booting worker with pid: %s\"</span>, worker.pid)</span><br><span class=\"line\">        self.cfg.post_fork(self, worker)</span><br><span class=\"line\">        worker.init_process()</span><br><span class=\"line\">        sys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> SystemExit:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>如果worker少于cfg.num_workers，调用spawn_workers方法增加worker数量，增加的方法就是os.fork()。<br>如果数量大于cfg.num_workers，根据worker.age的属性排序后kill一个worker。</p>\n<p>我们主要看下增加worker的过程，增加worker是通过调用os.fork来实现的，\b调用os.fork的进程称为主进程，生成的进程称为子进程，对于这两个进程，os.fork的返回值是不一样的，子进程的返回值是0，父进程返回的是子进程的进程id。所以如果是主进程则记录子进程id后返回到run里的无限循环。如果是子进程，则成为一个worker进程，执行worker.init_process()。正常情况不会执行<code>sys.exit(0)</code>语句。</p>\n<p>我们现在回到刚才os.fork的主进程，他执行完os.fork后就返回到run里的无限循环.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    self.manage_workers()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        self.maybe_promote_master()</span><br><span class=\"line\"></span><br><span class=\"line\">        sig = self.SIG_QUEUE.pop(<span class=\"number\">0</span>) <span class=\"keyword\">if</span> self.SIG_QUEUE <span class=\"keyword\">else</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sig <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            self.sleep()</span><br><span class=\"line\">            self.murder_workers()</span><br><span class=\"line\">            self.manage_workers()</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sig <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.SIG_NAMES:</span><br><span class=\"line\">            self.log.info(<span class=\"string\">\"Ignoring unknown signal: %s\"</span>, sig)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        signame = self.SIG_NAMES.get(sig)</span><br><span class=\"line\">        handler = getattr(self, <span class=\"string\">\"handle_%s\"</span> % signame, <span class=\"keyword\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> handler:</span><br><span class=\"line\">            self.log.error(<span class=\"string\">\"Unhandled signal: %s\"</span>, signame)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        self.log.info(<span class=\"string\">\"Handling signal: %s\"</span>, signame)</span><br><span class=\"line\">        handler()</span><br><span class=\"line\">        self.wakeup()</span><br><span class=\"line\"><span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">    self.halt()</span><br><span class=\"line\"><span class=\"keyword\">except</span> KeyboardInterrupt:</span><br><span class=\"line\">    self.halt()</span><br><span class=\"line\"><span class=\"keyword\">except</span> HaltServer <span class=\"keyword\">as</span> inst:</span><br><span class=\"line\">    self.halt(reason=inst.reason, exit_status=inst.exit_status)</span><br><span class=\"line\"><span class=\"keyword\">except</span> SystemExit:</span><br><span class=\"line\">    <span class=\"keyword\">raise</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">    self.log.info(<span class=\"string\">\"Unhandled exception in main loop\"</span>,</span><br><span class=\"line\">                  exc_info=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    self.stop(<span class=\"keyword\">False</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.pidfile <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        self.pidfile.unlink()</span><br><span class=\"line\">    sys.exit(<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>主进程在执行<code>maybe_promote_master</code>方法，将自己\b标识为master进程，然后根据信号量来进行一些控制进程的操作。如果信号量为空，则通过sleep方法进入睡眠状态，sleep的代码是这样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sleep</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    Sleep until PIPE is readable or we timeout.</span></span><br><span class=\"line\"><span class=\"string\">    A readable PIPE means a signal occurred.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        ready = select.select([self.PIPE[<span class=\"number\">0</span>]], [], [], <span class=\"number\">1.0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ready[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> os.read(self.PIPE[<span class=\"number\">0</span>], <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> (select.error, OSError) <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"comment\"># <span class=\"doctag\">TODO:</span> select.error is a subclass of OSError since Python 3.3.</span></span><br><span class=\"line\">        error_number = getattr(e, <span class=\"string\">'errno'</span>, e.args[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> error_number <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> [errno.EAGAIN, errno.EINTR]:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> KeyboardInterrupt:</span><br><span class=\"line\">        sys.exit()</span><br></pre></td></tr></table></figure>\n<p>循环的监听管道，如果有信号量就退出循环，关于select这一块我也不是很清楚。退出循环后回到上一段的循环中,首先保持worker的数量为配置信息里的值，然后读取信号量的名字，根据不同的名字调用不同的hander方法。之后不断的重复，master进程大概就是这样。</p>\n<h2 id=\"Worker进程\"><a href=\"#Worker进程\" class=\"headerlink\" title=\"Worker进程\"></a>Worker进程</h2><p>通过上面的分析，可以看出来worker进程才是真正用来处理请求的进程，入口是<code>worker.init_process()</code>.这个worker的来历大概是这样的，<code>worker -&gt; self.work_class(*args) -&gt; self.cfg.worker_class() -&gt; util.load_class()</code>。util.load_class接受一个字符串参数，是配置中的<code>worker_class</code>变量，默认为SyncWorker。但是也能变成gevent, threadworker等更高效的worker.我们先看下默认的SyncWorker的逻辑是怎么样的。</p>\n<p>所有的worker模块都在gunicorn/workers包中。<code>SyncWorker</code>继承自base.Worker.<code>SyncWorker</code>的init_process()方法来自于父类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_process</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    If you override this method in a subclass, the last statement</span></span><br><span class=\"line\"><span class=\"string\">    in the function should be to call this method with</span></span><br><span class=\"line\"><span class=\"string\">    super(MyWorkerClass, self).init_process() so that the ``run()``</span></span><br><span class=\"line\"><span class=\"string\">    loop is initiated.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># set environment' variables</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.cfg.env:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.cfg.env.items():</span><br><span class=\"line\">            os.environ[k] = v</span><br><span class=\"line\"></span><br><span class=\"line\">    util.set_owner_process(self.cfg.uid, self.cfg.gid,</span><br><span class=\"line\">                           initgroups=self.cfg.initgroups)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Reseed the random number generator</span></span><br><span class=\"line\">    util.seed()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># For waking ourselves up</span></span><br><span class=\"line\">    self.PIPE = os.pipe()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> self.PIPE:</span><br><span class=\"line\">        util.set_non_blocking(p)</span><br><span class=\"line\">        util.close_on_exec(p)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Prevent fd inheritance</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> self.sockets:</span><br><span class=\"line\">        util.close_on_exec(s)</span><br><span class=\"line\">    util.close_on_exec(self.tmp.fileno())</span><br><span class=\"line\"></span><br><span class=\"line\">    self.wait_fds = self.sockets + [self.PIPE[<span class=\"number\">0</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">    self.log.close_on_exec()</span><br><span class=\"line\"></span><br><span class=\"line\">    self.init_signals()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># start the reloader</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.cfg.reload:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">changed</span><span class=\"params\">(fname)</span>:</span></span><br><span class=\"line\">            self.log.info(<span class=\"string\">\"Worker reloading: %s modified\"</span>, fname)</span><br><span class=\"line\">            self.alive = <span class=\"keyword\">False</span></span><br><span class=\"line\">            self.cfg.worker_int(self)</span><br><span class=\"line\">            time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">            sys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        reloader_cls = reloader_engines[self.cfg.reload_engine]</span><br><span class=\"line\">        self.reloader = reloader_cls(extra_files=self.cfg.reload_extra_files,</span><br><span class=\"line\">                                     callback=changed)</span><br><span class=\"line\">        self.reloader.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    self.load_wsgi()</span><br><span class=\"line\">    self.cfg.post_worker_init(self)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Enter main run loop</span></span><br><span class=\"line\">    self.booted = <span class=\"keyword\">True</span></span><br><span class=\"line\">    self.run()</span><br></pre></td></tr></table></figure>\n<ol>\n<li>init_signals()注册信号量</li>\n<li>load_wsgi()： self.wsgi = self.app.wsgi()，一般就是python框架里起的app，比如Flask里的<code>app = Flask(__name__)</code>.</li>\n<li>run(). 现在我们到syncworker的run方法看一看。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    timeout = self.timeout <span class=\"keyword\">or</span> <span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> self.sockets:</span><br><span class=\"line\">        s.setblocking(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(self.sockets) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        self.run_for_multiple(timeout)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.run_for_one(timeout)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_for_one</span><span class=\"params\">(self, timeout)</span>:</span></span><br><span class=\"line\">    listener = self.sockets[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.alive:</span><br><span class=\"line\">        self.notify()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.accept(listener)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> EnvironmentError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> e.errno <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (errno.EAGAIN, errno.ECONNABORTED,</span><br><span class=\"line\">                    errno.EWOULDBLOCK):</span><br><span class=\"line\">                <span class=\"keyword\">raise</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_parent_alive():</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.wait(timeout)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopWaiting:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_for_multiple</span><span class=\"params\">(self, timeout)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.alive:</span><br><span class=\"line\">        self.notify()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            ready = self.wait(timeout)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopWaiting:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ready <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> listener <span class=\"keyword\">in</span> ready:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> listener == self.PIPE[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                    self.accept(listener)</span><br><span class=\"line\">                <span class=\"keyword\">except</span> EnvironmentError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> e.errno <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (errno.EAGAIN, errno.ECONNABORTED,</span><br><span class=\"line\">                            errno.EWOULDBLOCK):</span><br><span class=\"line\">                        <span class=\"keyword\">raise</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_parent_alive():</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>我把一些注释删了，run方法之后进入的两个方法同样也都是无限循环，不断的接收socket。<code>accept</code>方法很简洁，就是在建立连接的socket上获取client端的地址等信息，并设置socket为阻塞的，也就是同一时间只能处理一个请求。然后调用handle方法处理请求，handle方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle</span><span class=\"params\">(self, listener, client, addr)</span>:</span></span><br><span class=\"line\">    req = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.cfg.is_ssl:</span><br><span class=\"line\">            client = ssl.wrap_socket(client, server_side=<span class=\"keyword\">True</span>,</span><br><span class=\"line\">                **self.cfg.ssl_options)</span><br><span class=\"line\"></span><br><span class=\"line\">        parser = http.RequestParser(self.cfg, client)</span><br><span class=\"line\">        req = six.next(parser)</span><br><span class=\"line\">        self.handle_request(listener, req, client, addr)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> http.errors.NoMoreData <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        self.log.debug(<span class=\"string\">\"Ignored premature client disconnection. %s\"</span>, e)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        self.log.debug(<span class=\"string\">\"Closing connection. %s\"</span>, e)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> ssl.SSLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e.args[<span class=\"number\">0</span>] == ssl.SSL_ERROR_EOF:</span><br><span class=\"line\">            self.log.debug(<span class=\"string\">\"ssl connection closed\"</span>)</span><br><span class=\"line\">            client.close()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.log.debug(<span class=\"string\">\"Error processing SSL request.\"</span>)</span><br><span class=\"line\">            self.handle_error(req, client, addr, e)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> EnvironmentError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e.errno <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (errno.EPIPE, errno.ECONNRESET):</span><br><span class=\"line\">            self.log.exception(<span class=\"string\">\"Socket error processing request.\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> e.errno == errno.ECONNRESET:</span><br><span class=\"line\">                self.log.debug(<span class=\"string\">\"Ignoring connection reset\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.log.debug(<span class=\"string\">\"Ignoring EPIPE\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        self.handle_error(req, client, addr, e)</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        util.close(client)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_request</span><span class=\"params\">(self, listener, req, client, addr)</span>:</span></span><br><span class=\"line\">    environ = &#123;&#125;</span><br><span class=\"line\">    resp = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        self.cfg.pre_request(self, req)</span><br><span class=\"line\">        request_start = datetime.now()</span><br><span class=\"line\">        resp, environ = wsgi.create(req, client, addr,</span><br><span class=\"line\">                listener.getsockname(), self.cfg)</span><br><span class=\"line\">        <span class=\"comment\"># Force the connection closed until someone shows</span></span><br><span class=\"line\">        <span class=\"comment\"># a buffering proxy that supports Keep-Alive to</span></span><br><span class=\"line\">        <span class=\"comment\"># the backend.</span></span><br><span class=\"line\">        resp.force_close()</span><br><span class=\"line\">        self.nr += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.nr &gt;= self.max_requests:</span><br><span class=\"line\">            self.log.info(<span class=\"string\">\"Autorestarting worker after current request.\"</span>)</span><br><span class=\"line\">            self.alive = <span class=\"keyword\">False</span></span><br><span class=\"line\">        respiter = self.wsgi(environ, resp.start_response)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> isinstance(respiter, environ[<span class=\"string\">'wsgi.file_wrapper'</span>]):</span><br><span class=\"line\">                resp.write_file(respiter)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> respiter:</span><br><span class=\"line\">                    resp.write(item)</span><br><span class=\"line\">            resp.close()</span><br><span class=\"line\">            request_time = datetime.now() - request_start</span><br><span class=\"line\">            self.log.access(resp, req, environ, request_time)</span><br><span class=\"line\">        <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> hasattr(respiter, <span class=\"string\">\"close\"</span>):</span><br><span class=\"line\">                respiter.close()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> EnvironmentError:</span><br><span class=\"line\">        <span class=\"comment\"># pass to next try-except level</span></span><br><span class=\"line\">        six.reraise(*sys.exc_info())</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> resp <span class=\"keyword\">and</span> resp.headers_sent:</span><br><span class=\"line\">            <span class=\"comment\"># If the requests have already been sent, we should close the</span></span><br><span class=\"line\">            <span class=\"comment\"># connection to indicate the error.</span></span><br><span class=\"line\">            self.log.exception(<span class=\"string\">\"Error handling request\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                client.shutdown(socket.SHUT_RDWR)</span><br><span class=\"line\">                client.close()</span><br><span class=\"line\">            <span class=\"keyword\">except</span> EnvironmentError:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration()</span><br><span class=\"line\">        <span class=\"keyword\">raise</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.cfg.post_request(self, req, environ, resp)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            self.log.exception(<span class=\"string\">\"Exception in post_request hook\"</span>)</span><br></pre></td></tr></table></figure>\n<p>了解过wsgi协议的应该知道，服务器是如何跟框架交互的。简单的说就是服务器会调用一个方法并传入两个参数，第一个参数为environ,这个参数包含了所有请求有关的信息，比如headers, body等等。第二个参数是一个回调函数，后台服务处理完业务后调用这个函数将response传给服务器，服务器再传给客户端。但是这里还有很多细节，水平有限，看不大明白，但是整体的流程应该还是很清楚。所以这里先parser了http请求的相关信息，保存在environ中，然后生成回调函数resp.strt_response，然后调用wsgi(environ, resp.start_response)。这里的wsgi就是框架中的app.</p>\n<h2 id=\"GeventWorker\"><a href=\"#GeventWorker\" class=\"headerlink\" title=\"GeventWorker\"></a>GeventWorker</h2><p>我最近接触到的是配合gevent起一个服务，所以我也分析一下geventworker的逻辑。首先geventworker继承自asyncworker，asyncworker继承自base.worker。上面提到了，默认的worker是一个阻塞的模型，同一时间只能处理一个请求，所以效率比较低，生产环境一般不会使用。</p>\n<h3 id=\"AsyncWorker\"><a href=\"#AsyncWorker\" class=\"headerlink\" title=\"AsyncWorker\"></a>AsyncWorker</h3><p><code>AsyncWorker</code>的构造函数先是调用了父类的构造函数，然后又添加了一个额外的参数<code>worker_connections</code>，这个参数也是在cfg中设置的，且只在<code>eventlet</code>和<code>gevent</code>两种模式下起作用，作用是限制最大的同时的客户端连接数。</p>\n<p>前面的SyncWorker的init_process是继承自worker。但是GeventWorker重写了这个方法。用过gevent的应该知道，gevent底层实现的方法叫做猴子补丁-monkey_patch。修改了大多数的底层库，将一些阻塞的底层实现，重新换成非阻塞的。所以GeventWorker先是打上补丁，然后调用worker的init_process方法，最终进入GeventWorker的run方法开始执行处理请求任务。run方法代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> self.sockets:</span><br><span class=\"line\">        s.setblocking(<span class=\"number\">1</span>)</span><br><span class=\"line\">        pool = Pool(self.worker_connections)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.server_class <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            environ = base_environ(self.cfg)</span><br><span class=\"line\">            environ.update(&#123;</span><br><span class=\"line\">                <span class=\"string\">\"wsgi.multithread\"</span>: <span class=\"keyword\">True</span>,</span><br><span class=\"line\">                <span class=\"string\">\"SERVER_SOFTWARE\"</span>: VERSION,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            server = self.server_class(</span><br><span class=\"line\">                s, application=self.wsgi, spawn=pool, log=self.log,</span><br><span class=\"line\">                handler_class=self.wsgi_handler, environ=environ,</span><br><span class=\"line\">                **ssl_args)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hfun = partial(self.handle, s)</span><br><span class=\"line\">            server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args)</span><br><span class=\"line\"></span><br><span class=\"line\">        server.start()</span><br><span class=\"line\">        servers.append(server)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.alive:</span><br><span class=\"line\">        self.notify()</span><br><span class=\"line\">        gevent.sleep(<span class=\"number\">1.0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># Stop accepting requests</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> server <span class=\"keyword\">in</span> servers:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> hasattr(server, <span class=\"string\">'close'</span>):  <span class=\"comment\"># gevent 1.0</span></span><br><span class=\"line\">                server.close()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> hasattr(server, <span class=\"string\">'kill'</span>):  <span class=\"comment\"># gevent &lt; 1.0</span></span><br><span class=\"line\">                server.kill()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Handle current requests until graceful_timeout</span></span><br><span class=\"line\">        ts = time.time()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> time.time() - ts &lt;= self.cfg.graceful_timeout:</span><br><span class=\"line\">            accepting = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> server <span class=\"keyword\">in</span> servers:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> server.pool.free_count() != server.pool.size:</span><br><span class=\"line\">                    accepting += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># if no server is accepting a connection, we can exit</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> accepting:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">            self.notify()</span><br><span class=\"line\">            gevent.sleep(<span class=\"number\">1.0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Force kill all active the handlers</span></span><br><span class=\"line\">        self.log.warning(<span class=\"string\">\"Worker graceful timeout (pid:%s)\"</span> % self.pid)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> server <span class=\"keyword\">in</span> servers:</span><br><span class=\"line\">            server.stop(timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>创建tcpServer。并用pool限制了最大连接数。这个server的实现在gevent中，没看懂。</li>\n<li>hfun这个方法，是一个绑定了参数的handle，是asyncWorker的handle。过程跟前面的同步的差不多。但是遇到阻塞是gevent会帮助切换，所以提高了并发量。</li>\n<li>创建完server进入无限循环，notify网上查了一下说是给Arbiter发信号的，这里我不大懂。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>gunicorn代码比较多，且有很多底层的东西。很多地方不懂，都跳过了，分析可能也有很多错误，看到可以指出。</p>\n<p>相比于之前看过的flask、request、tornado等等。gunicorn显然难很多，也没有那么清晰，有很多方法，参数来的不明不白；而且跟gevent牵扯很大，gevent的代码更加难懂。</p>\n<p>但应该还是有点收获吧，虽然暂时没察觉到～</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h2><p>首先程序的入口为<code>gunicorn/app/wsgiapp</code>这个模块。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    The ``gunicorn`` command line runner for launching Gunicorn with</span></span><br><span class=\"line\"><span class=\"string\">    generic WSGI applications.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> gunicorn.app.wsgiapp <span class=\"keyword\">import</span> WSGIApplication</span><br><span class=\"line\">    WSGIApplication(<span class=\"string\">\"%(prog)s [OPTIONS] [APP_MODULE]\"</span>).run()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    run()</span><br></pre></td></tr></table></figure>\n<p><code>WSGIApplication</code>这个类继承于<code>Application</code>,然后继承于<code>BaseApplication</code>.而且这三个类只有<code>BaseApplication</code>是有构造函数的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, usage=None, prog=None)</span>:</span></span><br><span class=\"line\">    self.usage = usage</span><br><span class=\"line\">    self.cfg = <span class=\"keyword\">None</span></span><br><span class=\"line\">    self.callable = <span class=\"keyword\">None</span></span><br><span class=\"line\">    self.prog = prog</span><br><span class=\"line\">    self.logger = <span class=\"keyword\">None</span></span><br><span class=\"line\">    self.do_load_config()</span><br></pre></td></tr></table></figure>\n<p>这里面<code>useage, prog</code>就是两个字符串，忽略，其他的下面分析。赋值完后进入<code>do_load_config</code>方法。这个方法做了两件事，第一件是将一个Config对象赋值<code>给self.cfg</code>参数。这个对象可以从命令行中解析参数，将一些配置绑定。第二件是调用一个在<code>Application</code>中才实现的方法<code>load_config</code>。这个方法通过各种途径将参数绑定到cfg对象中,其中包括调用一次<code>WSGIApplicagion</code>的init方法，同样也是绑定相关参数。</p>","more":"<p>但这里有个比较神奇的技巧，关于cfg的，一开始没看懂，看到后来发现cfg中包含了很多可以使用的方法，却不知道是什么时候偷偷绑定上来的。现在来仔细看一下，之前说过了，cfg就是一个<code>Config</code>对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KNOWN_SETTINGS = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_settings</span><span class=\"params\">(ignore=None)</span>:</span></span><br><span class=\"line\">    settings = &#123;&#125;</span><br><span class=\"line\">    ignore = ignore <span class=\"keyword\">or</span> ()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> KNOWN_SETTINGS:</span><br><span class=\"line\">        setting = s()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> setting.name <span class=\"keyword\">in</span> ignore:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        settings[setting.name] = setting.copy()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> settings</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, usage=None, prog=None)</span>:</span></span><br><span class=\"line\">        self.settings = make_settings()</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<p>目前来看，<code>KNOWN_SETTINGS</code>是一个空列表，所以<code>self.settings</code>也应该是一个空字典。但其实不然。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SettingMeta</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, name, bases, attrs)</span>:</span></span><br><span class=\"line\">        super_new = super(SettingMeta, cls).__new__</span><br><span class=\"line\">        parents = [b <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> bases <span class=\"keyword\">if</span> isinstance(b, SettingMeta)]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> parents:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> super_new(cls, name, bases, attrs)</span><br><span class=\"line\"></span><br><span class=\"line\">        attrs[<span class=\"string\">\"order\"</span>] = len(KNOWN_SETTINGS)</span><br><span class=\"line\">        attrs[<span class=\"string\">\"validator\"</span>] = staticmethod(attrs[<span class=\"string\">\"validator\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        new_class = super_new(cls, name, bases, attrs)</span><br><span class=\"line\">        new_class.fmt_desc(attrs.get(<span class=\"string\">\"desc\"</span>, <span class=\"string\">\"\"</span>))</span><br><span class=\"line\">        KNOWN_SETTINGS.append(new_class)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_class</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Setting</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">Setting = SettingMeta(<span class=\"string\">'Setting'</span>, (Setting,), &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Workers</span><span class=\"params\">(Setting)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'xxx'</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    validator = xxx</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>config.py这个模块中还有很多个类似<code>Workers</code>一样的类，结构都是差不多的，首先都是继承<code>Setting</code>类，而<code>Setting</code>类是一个由<code>SettingMeta</code>创造出来的类，\b大家应该都知道创造类是<strong>new</strong>这个方法来完成的，这里也不例外，在<strong>new</strong>方法中，通过type这个元类来生成一个新的类，并通过<code>attrs[&quot;validator&quot;] = staticmethod(attrs[&quot;validator&quot;])</code>来给类绑定一个方法。同时将新的<code>Setting</code>类加入<code>KNOWN_SETTINGS</code>中，这样后续定义的类似<code>Workers</code>的类都会被加入列表中，从而绑定到cfg这个对象上。</p>\n<p>简单的说，在调用run方法之前，初始化了一些参数，主要是给cfg这个对象绑定了很多熟悉和方法。</p>\n<h2 id=\"run方法\"><a href=\"#run方法\" class=\"headerlink\" title=\"run方法\"></a>run方法</h2><p><code>run</code>方法最终调用的是<code>Arbiter</code>对象的run方法，创建<code>Arbiter</code>对象时传入<code>Application</code>对象作为参数。根据类注释，可以很清楚的了解这个类的主要作用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arbiter</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Arbiter maintain the workers processes alive. It launches or</span></span><br><span class=\"line\"><span class=\"string\">    kills them if needed. It also manages application reloading</span></span><br><span class=\"line\"><span class=\"string\">    via SIGHUP/USR2.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"Main master loop.\"</span></span><br><span class=\"line\">        self.start()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.manage_workers()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">                self.maybe_promote_master()</span><br><span class=\"line\"></span><br><span class=\"line\">                ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            sys.exit(<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>在<code>Arbiter</code>的run方法中，先调用start()来创建socket监听,然后通过manage_workers()来控制worker的数量，现在来看下<code>manage_workers</code>的代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">manage_workers</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    Maintain the number of workers by spawning or killing</span></span><br><span class=\"line\"><span class=\"string\">    as required.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(self.WORKERS.keys()) &lt; self.num_workers:</span><br><span class=\"line\">        self.spawn_workers()</span><br><span class=\"line\">    workers = self.WORKERS.items()</span><br><span class=\"line\">    workers = sorted(workers, key=<span class=\"keyword\">lambda</span> w: w[<span class=\"number\">1</span>].age)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(workers) &gt; self.num_workers:</span><br><span class=\"line\">        (pid, _) = workers.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">        self.kill_worker(pid, signal.SIGTERM)</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spawn_workers</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    Spawn new workers as needed.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    This is where a worker process leaves the main loop</span></span><br><span class=\"line\"><span class=\"string\">    of the master process.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_workers - len(self.WORKERS.keys())):</span><br><span class=\"line\">        self.spawn_worker()</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.1</span> * random.random())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spawn_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    self.worker_age += <span class=\"number\">1</span></span><br><span class=\"line\">    worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,</span><br><span class=\"line\">                               self.app, self.timeout / <span class=\"number\">2.0</span>,</span><br><span class=\"line\">                               self.cfg, self.log)</span><br><span class=\"line\">    self.cfg.pre_fork(self, worker)</span><br><span class=\"line\">    pid = os.fork()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pid != <span class=\"number\">0</span>:</span><br><span class=\"line\">        worker.pid = pid</span><br><span class=\"line\">        self.WORKERS[pid] = worker</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pid</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Do not inherit the temporary files of other workers</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> sibling <span class=\"keyword\">in</span> self.WORKERS.values():</span><br><span class=\"line\">        sibling.tmp.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Process Child</span></span><br><span class=\"line\">    worker.pid = os.getpid()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        util._setproctitle(<span class=\"string\">\"worker [%s]\"</span> % self.proc_name)</span><br><span class=\"line\">        self.log.info(<span class=\"string\">\"Booting worker with pid: %s\"</span>, worker.pid)</span><br><span class=\"line\">        self.cfg.post_fork(self, worker)</span><br><span class=\"line\">        worker.init_process()</span><br><span class=\"line\">        sys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> SystemExit:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>如果worker少于cfg.num_workers，调用spawn_workers方法增加worker数量，增加的方法就是os.fork()。<br>如果数量大于cfg.num_workers，根据worker.age的属性排序后kill一个worker。</p>\n<p>我们主要看下增加worker的过程，增加worker是通过调用os.fork来实现的，\b调用os.fork的进程称为主进程，生成的进程称为子进程，对于这两个进程，os.fork的返回值是不一样的，子进程的返回值是0，父进程返回的是子进程的进程id。所以如果是主进程则记录子进程id后返回到run里的无限循环。如果是子进程，则成为一个worker进程，执行worker.init_process()。正常情况不会执行<code>sys.exit(0)</code>语句。</p>\n<p>我们现在回到刚才os.fork的主进程，他执行完os.fork后就返回到run里的无限循环.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    self.manage_workers()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        self.maybe_promote_master()</span><br><span class=\"line\"></span><br><span class=\"line\">        sig = self.SIG_QUEUE.pop(<span class=\"number\">0</span>) <span class=\"keyword\">if</span> self.SIG_QUEUE <span class=\"keyword\">else</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sig <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            self.sleep()</span><br><span class=\"line\">            self.murder_workers()</span><br><span class=\"line\">            self.manage_workers()</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sig <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.SIG_NAMES:</span><br><span class=\"line\">            self.log.info(<span class=\"string\">\"Ignoring unknown signal: %s\"</span>, sig)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        signame = self.SIG_NAMES.get(sig)</span><br><span class=\"line\">        handler = getattr(self, <span class=\"string\">\"handle_%s\"</span> % signame, <span class=\"keyword\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> handler:</span><br><span class=\"line\">            self.log.error(<span class=\"string\">\"Unhandled signal: %s\"</span>, signame)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        self.log.info(<span class=\"string\">\"Handling signal: %s\"</span>, signame)</span><br><span class=\"line\">        handler()</span><br><span class=\"line\">        self.wakeup()</span><br><span class=\"line\"><span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">    self.halt()</span><br><span class=\"line\"><span class=\"keyword\">except</span> KeyboardInterrupt:</span><br><span class=\"line\">    self.halt()</span><br><span class=\"line\"><span class=\"keyword\">except</span> HaltServer <span class=\"keyword\">as</span> inst:</span><br><span class=\"line\">    self.halt(reason=inst.reason, exit_status=inst.exit_status)</span><br><span class=\"line\"><span class=\"keyword\">except</span> SystemExit:</span><br><span class=\"line\">    <span class=\"keyword\">raise</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">    self.log.info(<span class=\"string\">\"Unhandled exception in main loop\"</span>,</span><br><span class=\"line\">                  exc_info=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    self.stop(<span class=\"keyword\">False</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.pidfile <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        self.pidfile.unlink()</span><br><span class=\"line\">    sys.exit(<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>主进程在执行<code>maybe_promote_master</code>方法，将自己\b标识为master进程，然后根据信号量来进行一些控制进程的操作。如果信号量为空，则通过sleep方法进入睡眠状态，sleep的代码是这样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sleep</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    Sleep until PIPE is readable or we timeout.</span></span><br><span class=\"line\"><span class=\"string\">    A readable PIPE means a signal occurred.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        ready = select.select([self.PIPE[<span class=\"number\">0</span>]], [], [], <span class=\"number\">1.0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ready[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> os.read(self.PIPE[<span class=\"number\">0</span>], <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> (select.error, OSError) <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"comment\"># <span class=\"doctag\">TODO:</span> select.error is a subclass of OSError since Python 3.3.</span></span><br><span class=\"line\">        error_number = getattr(e, <span class=\"string\">'errno'</span>, e.args[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> error_number <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> [errno.EAGAIN, errno.EINTR]:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> KeyboardInterrupt:</span><br><span class=\"line\">        sys.exit()</span><br></pre></td></tr></table></figure>\n<p>循环的监听管道，如果有信号量就退出循环，关于select这一块我也不是很清楚。退出循环后回到上一段的循环中,首先保持worker的数量为配置信息里的值，然后读取信号量的名字，根据不同的名字调用不同的hander方法。之后不断的重复，master进程大概就是这样。</p>\n<h2 id=\"Worker进程\"><a href=\"#Worker进程\" class=\"headerlink\" title=\"Worker进程\"></a>Worker进程</h2><p>通过上面的分析，可以看出来worker进程才是真正用来处理请求的进程，入口是<code>worker.init_process()</code>.这个worker的来历大概是这样的，<code>worker -&gt; self.work_class(*args) -&gt; self.cfg.worker_class() -&gt; util.load_class()</code>。util.load_class接受一个字符串参数，是配置中的<code>worker_class</code>变量，默认为SyncWorker。但是也能变成gevent, threadworker等更高效的worker.我们先看下默认的SyncWorker的逻辑是怎么样的。</p>\n<p>所有的worker模块都在gunicorn/workers包中。<code>SyncWorker</code>继承自base.Worker.<code>SyncWorker</code>的init_process()方法来自于父类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_process</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"\\</span></span><br><span class=\"line\"><span class=\"string\">    If you override this method in a subclass, the last statement</span></span><br><span class=\"line\"><span class=\"string\">    in the function should be to call this method with</span></span><br><span class=\"line\"><span class=\"string\">    super(MyWorkerClass, self).init_process() so that the ``run()``</span></span><br><span class=\"line\"><span class=\"string\">    loop is initiated.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># set environment' variables</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.cfg.env:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.cfg.env.items():</span><br><span class=\"line\">            os.environ[k] = v</span><br><span class=\"line\"></span><br><span class=\"line\">    util.set_owner_process(self.cfg.uid, self.cfg.gid,</span><br><span class=\"line\">                           initgroups=self.cfg.initgroups)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Reseed the random number generator</span></span><br><span class=\"line\">    util.seed()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># For waking ourselves up</span></span><br><span class=\"line\">    self.PIPE = os.pipe()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> self.PIPE:</span><br><span class=\"line\">        util.set_non_blocking(p)</span><br><span class=\"line\">        util.close_on_exec(p)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Prevent fd inheritance</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> self.sockets:</span><br><span class=\"line\">        util.close_on_exec(s)</span><br><span class=\"line\">    util.close_on_exec(self.tmp.fileno())</span><br><span class=\"line\"></span><br><span class=\"line\">    self.wait_fds = self.sockets + [self.PIPE[<span class=\"number\">0</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">    self.log.close_on_exec()</span><br><span class=\"line\"></span><br><span class=\"line\">    self.init_signals()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># start the reloader</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.cfg.reload:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">changed</span><span class=\"params\">(fname)</span>:</span></span><br><span class=\"line\">            self.log.info(<span class=\"string\">\"Worker reloading: %s modified\"</span>, fname)</span><br><span class=\"line\">            self.alive = <span class=\"keyword\">False</span></span><br><span class=\"line\">            self.cfg.worker_int(self)</span><br><span class=\"line\">            time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">            sys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        reloader_cls = reloader_engines[self.cfg.reload_engine]</span><br><span class=\"line\">        self.reloader = reloader_cls(extra_files=self.cfg.reload_extra_files,</span><br><span class=\"line\">                                     callback=changed)</span><br><span class=\"line\">        self.reloader.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    self.load_wsgi()</span><br><span class=\"line\">    self.cfg.post_worker_init(self)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Enter main run loop</span></span><br><span class=\"line\">    self.booted = <span class=\"keyword\">True</span></span><br><span class=\"line\">    self.run()</span><br></pre></td></tr></table></figure>\n<ol>\n<li>init_signals()注册信号量</li>\n<li>load_wsgi()： self.wsgi = self.app.wsgi()，一般就是python框架里起的app，比如Flask里的<code>app = Flask(__name__)</code>.</li>\n<li>run(). 现在我们到syncworker的run方法看一看。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    timeout = self.timeout <span class=\"keyword\">or</span> <span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> self.sockets:</span><br><span class=\"line\">        s.setblocking(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(self.sockets) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        self.run_for_multiple(timeout)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.run_for_one(timeout)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_for_one</span><span class=\"params\">(self, timeout)</span>:</span></span><br><span class=\"line\">    listener = self.sockets[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.alive:</span><br><span class=\"line\">        self.notify()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.accept(listener)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> EnvironmentError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> e.errno <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (errno.EAGAIN, errno.ECONNABORTED,</span><br><span class=\"line\">                    errno.EWOULDBLOCK):</span><br><span class=\"line\">                <span class=\"keyword\">raise</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_parent_alive():</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.wait(timeout)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopWaiting:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_for_multiple</span><span class=\"params\">(self, timeout)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.alive:</span><br><span class=\"line\">        self.notify()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            ready = self.wait(timeout)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopWaiting:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ready <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> listener <span class=\"keyword\">in</span> ready:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> listener == self.PIPE[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                    self.accept(listener)</span><br><span class=\"line\">                <span class=\"keyword\">except</span> EnvironmentError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> e.errno <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (errno.EAGAIN, errno.ECONNABORTED,</span><br><span class=\"line\">                            errno.EWOULDBLOCK):</span><br><span class=\"line\">                        <span class=\"keyword\">raise</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_parent_alive():</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>我把一些注释删了，run方法之后进入的两个方法同样也都是无限循环，不断的接收socket。<code>accept</code>方法很简洁，就是在建立连接的socket上获取client端的地址等信息，并设置socket为阻塞的，也就是同一时间只能处理一个请求。然后调用handle方法处理请求，handle方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle</span><span class=\"params\">(self, listener, client, addr)</span>:</span></span><br><span class=\"line\">    req = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.cfg.is_ssl:</span><br><span class=\"line\">            client = ssl.wrap_socket(client, server_side=<span class=\"keyword\">True</span>,</span><br><span class=\"line\">                **self.cfg.ssl_options)</span><br><span class=\"line\"></span><br><span class=\"line\">        parser = http.RequestParser(self.cfg, client)</span><br><span class=\"line\">        req = six.next(parser)</span><br><span class=\"line\">        self.handle_request(listener, req, client, addr)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> http.errors.NoMoreData <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        self.log.debug(<span class=\"string\">\"Ignored premature client disconnection. %s\"</span>, e)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        self.log.debug(<span class=\"string\">\"Closing connection. %s\"</span>, e)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> ssl.SSLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e.args[<span class=\"number\">0</span>] == ssl.SSL_ERROR_EOF:</span><br><span class=\"line\">            self.log.debug(<span class=\"string\">\"ssl connection closed\"</span>)</span><br><span class=\"line\">            client.close()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.log.debug(<span class=\"string\">\"Error processing SSL request.\"</span>)</span><br><span class=\"line\">            self.handle_error(req, client, addr, e)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> EnvironmentError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e.errno <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (errno.EPIPE, errno.ECONNRESET):</span><br><span class=\"line\">            self.log.exception(<span class=\"string\">\"Socket error processing request.\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> e.errno == errno.ECONNRESET:</span><br><span class=\"line\">                self.log.debug(<span class=\"string\">\"Ignoring connection reset\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.log.debug(<span class=\"string\">\"Ignoring EPIPE\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        self.handle_error(req, client, addr, e)</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        util.close(client)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_request</span><span class=\"params\">(self, listener, req, client, addr)</span>:</span></span><br><span class=\"line\">    environ = &#123;&#125;</span><br><span class=\"line\">    resp = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        self.cfg.pre_request(self, req)</span><br><span class=\"line\">        request_start = datetime.now()</span><br><span class=\"line\">        resp, environ = wsgi.create(req, client, addr,</span><br><span class=\"line\">                listener.getsockname(), self.cfg)</span><br><span class=\"line\">        <span class=\"comment\"># Force the connection closed until someone shows</span></span><br><span class=\"line\">        <span class=\"comment\"># a buffering proxy that supports Keep-Alive to</span></span><br><span class=\"line\">        <span class=\"comment\"># the backend.</span></span><br><span class=\"line\">        resp.force_close()</span><br><span class=\"line\">        self.nr += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.nr &gt;= self.max_requests:</span><br><span class=\"line\">            self.log.info(<span class=\"string\">\"Autorestarting worker after current request.\"</span>)</span><br><span class=\"line\">            self.alive = <span class=\"keyword\">False</span></span><br><span class=\"line\">        respiter = self.wsgi(environ, resp.start_response)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> isinstance(respiter, environ[<span class=\"string\">'wsgi.file_wrapper'</span>]):</span><br><span class=\"line\">                resp.write_file(respiter)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> respiter:</span><br><span class=\"line\">                    resp.write(item)</span><br><span class=\"line\">            resp.close()</span><br><span class=\"line\">            request_time = datetime.now() - request_start</span><br><span class=\"line\">            self.log.access(resp, req, environ, request_time)</span><br><span class=\"line\">        <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> hasattr(respiter, <span class=\"string\">\"close\"</span>):</span><br><span class=\"line\">                respiter.close()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> EnvironmentError:</span><br><span class=\"line\">        <span class=\"comment\"># pass to next try-except level</span></span><br><span class=\"line\">        six.reraise(*sys.exc_info())</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> resp <span class=\"keyword\">and</span> resp.headers_sent:</span><br><span class=\"line\">            <span class=\"comment\"># If the requests have already been sent, we should close the</span></span><br><span class=\"line\">            <span class=\"comment\"># connection to indicate the error.</span></span><br><span class=\"line\">            self.log.exception(<span class=\"string\">\"Error handling request\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                client.shutdown(socket.SHUT_RDWR)</span><br><span class=\"line\">                client.close()</span><br><span class=\"line\">            <span class=\"keyword\">except</span> EnvironmentError:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration()</span><br><span class=\"line\">        <span class=\"keyword\">raise</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.cfg.post_request(self, req, environ, resp)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            self.log.exception(<span class=\"string\">\"Exception in post_request hook\"</span>)</span><br></pre></td></tr></table></figure>\n<p>了解过wsgi协议的应该知道，服务器是如何跟框架交互的。简单的说就是服务器会调用一个方法并传入两个参数，第一个参数为environ,这个参数包含了所有请求有关的信息，比如headers, body等等。第二个参数是一个回调函数，后台服务处理完业务后调用这个函数将response传给服务器，服务器再传给客户端。但是这里还有很多细节，水平有限，看不大明白，但是整体的流程应该还是很清楚。所以这里先parser了http请求的相关信息，保存在environ中，然后生成回调函数resp.strt_response，然后调用wsgi(environ, resp.start_response)。这里的wsgi就是框架中的app.</p>\n<h2 id=\"GeventWorker\"><a href=\"#GeventWorker\" class=\"headerlink\" title=\"GeventWorker\"></a>GeventWorker</h2><p>我最近接触到的是配合gevent起一个服务，所以我也分析一下geventworker的逻辑。首先geventworker继承自asyncworker，asyncworker继承自base.worker。上面提到了，默认的worker是一个阻塞的模型，同一时间只能处理一个请求，所以效率比较低，生产环境一般不会使用。</p>\n<h3 id=\"AsyncWorker\"><a href=\"#AsyncWorker\" class=\"headerlink\" title=\"AsyncWorker\"></a>AsyncWorker</h3><p><code>AsyncWorker</code>的构造函数先是调用了父类的构造函数，然后又添加了一个额外的参数<code>worker_connections</code>，这个参数也是在cfg中设置的，且只在<code>eventlet</code>和<code>gevent</code>两种模式下起作用，作用是限制最大的同时的客户端连接数。</p>\n<p>前面的SyncWorker的init_process是继承自worker。但是GeventWorker重写了这个方法。用过gevent的应该知道，gevent底层实现的方法叫做猴子补丁-monkey_patch。修改了大多数的底层库，将一些阻塞的底层实现，重新换成非阻塞的。所以GeventWorker先是打上补丁，然后调用worker的init_process方法，最终进入GeventWorker的run方法开始执行处理请求任务。run方法代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> self.sockets:</span><br><span class=\"line\">        s.setblocking(<span class=\"number\">1</span>)</span><br><span class=\"line\">        pool = Pool(self.worker_connections)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.server_class <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            environ = base_environ(self.cfg)</span><br><span class=\"line\">            environ.update(&#123;</span><br><span class=\"line\">                <span class=\"string\">\"wsgi.multithread\"</span>: <span class=\"keyword\">True</span>,</span><br><span class=\"line\">                <span class=\"string\">\"SERVER_SOFTWARE\"</span>: VERSION,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            server = self.server_class(</span><br><span class=\"line\">                s, application=self.wsgi, spawn=pool, log=self.log,</span><br><span class=\"line\">                handler_class=self.wsgi_handler, environ=environ,</span><br><span class=\"line\">                **ssl_args)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hfun = partial(self.handle, s)</span><br><span class=\"line\">            server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args)</span><br><span class=\"line\"></span><br><span class=\"line\">        server.start()</span><br><span class=\"line\">        servers.append(server)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.alive:</span><br><span class=\"line\">        self.notify()</span><br><span class=\"line\">        gevent.sleep(<span class=\"number\">1.0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># Stop accepting requests</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> server <span class=\"keyword\">in</span> servers:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> hasattr(server, <span class=\"string\">'close'</span>):  <span class=\"comment\"># gevent 1.0</span></span><br><span class=\"line\">                server.close()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> hasattr(server, <span class=\"string\">'kill'</span>):  <span class=\"comment\"># gevent &lt; 1.0</span></span><br><span class=\"line\">                server.kill()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Handle current requests until graceful_timeout</span></span><br><span class=\"line\">        ts = time.time()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> time.time() - ts &lt;= self.cfg.graceful_timeout:</span><br><span class=\"line\">            accepting = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> server <span class=\"keyword\">in</span> servers:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> server.pool.free_count() != server.pool.size:</span><br><span class=\"line\">                    accepting += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># if no server is accepting a connection, we can exit</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> accepting:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">            self.notify()</span><br><span class=\"line\">            gevent.sleep(<span class=\"number\">1.0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Force kill all active the handlers</span></span><br><span class=\"line\">        self.log.warning(<span class=\"string\">\"Worker graceful timeout (pid:%s)\"</span> % self.pid)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> server <span class=\"keyword\">in</span> servers:</span><br><span class=\"line\">            server.stop(timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>创建tcpServer。并用pool限制了最大连接数。这个server的实现在gevent中，没看懂。</li>\n<li>hfun这个方法，是一个绑定了参数的handle，是asyncWorker的handle。过程跟前面的同步的差不多。但是遇到阻塞是gevent会帮助切换，所以提高了并发量。</li>\n<li>创建完server进入无限循环，notify网上查了一下说是给Arbiter发信号的，这里我不大懂。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>gunicorn代码比较多，且有很多底层的东西。很多地方不懂，都跳过了，分析可能也有很多错误，看到可以指出。</p>\n<p>相比于之前看过的flask、request、tornado等等。gunicorn显然难很多，也没有那么清晰，有很多方法，参数来的不明不白；而且跟gevent牵扯很大，gevent的代码更加难懂。</p>\n<p>但应该还是有点收获吧，虽然暂时没察觉到～</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjrpqklkq0000uetuhg9epzvu","tag_id":"cjrpqklkw0002uetu9hkzuqwo","_id":"cjrpqklkz0005uetur9s0ndbt"},{"post_id":"cjrpqklku0001uetuhojcxbhy","tag_id":"cjrpqklkz0004uetupy1nm44y","_id":"cjrpqkll10008uetukg532gwb"},{"post_id":"cjrpqklku0001uetuhojcxbhy","tag_id":"cjrpqkll00006uetun61nrm7b","_id":"cjrpqkll10009ueturckk06pt"},{"post_id":"cjrpqklkx0003uetux7nbehh2","tag_id":"cjrpqkll10007uetu8kdyfzve","_id":"cjrpqkll1000auetugd4z3fcl"},{"post_id":"cjrpqkll6000euetuy08mel3i","tag_id":"cjrpqklkw0002uetu9hkzuqwo","_id":"cjrpqkll8000guetuoehf1qzi"},{"post_id":"cjrpqkll7000fuetunmcfl37y","tag_id":"cjrpqklkw0002uetu9hkzuqwo","_id":"cjrpqkll9000juetuftkqc8ib"},{"post_id":"cjrpqkll8000huetuznqs00ln","tag_id":"cjrpqkll10007uetu8kdyfzve","_id":"cjrpqklla000luetufbmbgb1x"},{"post_id":"cjrpqkll4000buetunrb4o7c4","tag_id":"cjrpqkll6000duetuzgq6fby1","_id":"cjrpqkllc000nuetujbtg0t0v"},{"post_id":"cjrpqkll4000buetunrb4o7c4","tag_id":"cjrpqkll9000iuetua7n0ami5","_id":"cjrpqkllc000ouetub7wodcso"},{"post_id":"cjrpqkll5000cuetuo1cmtrub","tag_id":"cjrpqkll6000duetuzgq6fby1","_id":"cjrpqklld000ruetuiq8h9ovk"},{"post_id":"cjrpqkll5000cuetuo1cmtrub","tag_id":"cjrpqkll9000iuetua7n0ami5","_id":"cjrpqklld000suetug0qlbvh8"},{"post_id":"cjrpqkll9000kuetuagj0tsna","tag_id":"cjrpqkllc000quetuahokr97d","_id":"cjrpqklld000uuetur6dovbx3"},{"post_id":"cjrpqkll9000kuetuagj0tsna","tag_id":"cjrpqklld000tuetu36674n2x","_id":"cjrpqklld000vuetu8vkcervz"},{"post_id":"cjrpqklle000wuetugua0s3vc","tag_id":"cjrpqkll6000duetuzgq6fby1","_id":"cjrpqklli000yuetu47ahpn66"},{"post_id":"cjrpqklle000wuetugua0s3vc","tag_id":"cjrpqkll9000iuetua7n0ami5","_id":"cjrpqklli000zuetue2q3ipd2"},{"post_id":"cjrpqkllh000xuetugcr9kwrl","tag_id":"cjrpqklkw0002uetu9hkzuqwo","_id":"cjrpqklli0010uetudhjz1oaf"}],"Tag":[{"name":"Python","_id":"cjrpqklkw0002uetu9hkzuqwo"},{"name":"redis","_id":"cjrpqklkz0004uetupy1nm44y"},{"name":"数据库","_id":"cjrpqkll00006uetun61nrm7b"},{"name":"随笔","_id":"cjrpqkll10007uetu8kdyfzve"},{"name":"Java","_id":"cjrpqkll6000duetuzgq6fby1"},{"name":"Java源码","_id":"cjrpqkll9000iuetua7n0ami5"},{"name":"数据结构","_id":"cjrpqkllc000quetuahokr97d"},{"name":"算法","_id":"cjrpqklld000tuetu36674n2x"}]}}