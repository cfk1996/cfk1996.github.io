---
title: 高性能mysql
date: 2019-02-23 21:40:49
tags:
    - 数据库
    - mysql
---

最近在看《高性能Mysql》,深入的学习一下mysql的相关知识及原理，并记录下相关知识点。记录的内容可能跳跃性较大，基于我自己主观意愿，需要一定的mysql基础。

### 1 mysql服务器逻辑架构

![mysql架构图](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/2019/mysql.png)

最上层的服务并不是mysql独有的，大多数基于网络的BS服务都有类似的架构。

第二层架构是Mysql中比较有意思的部分，大多数mysql的核心服务功能都在这一层，包括查询解析、分析、优化、缓存等。

第三层包含了存储引擎，存储引擎负责mysql中数据的存储和提取，不同的存储引擎有各自的优点和缺点，服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得这些差异对上层的查询过程透明。

<!--more-->

### 2 mvvc－多版本控制

mysql的InnoDB存储引擎为了提供事务功能，使用了很多类型的锁及多版本控制，典型的有悲观锁和乐观锁，mvvc没有一个统一的实现标准，这一节介绍一下Mysql中的InnoDB的实现机制，是一种乐观锁的思想。

InnoDB的MVVC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的删除时间。时间值为系统版本号，每开始一个新的事务，系统版本号会自动递增，事务开始时刻的系统版本号会作为事务的版本号。

下面是可重复读隔离级别下MVVC的具体操作(不了解几种事务隔离级别的另外查找资料)：

* select
    1. 只查找版本小于等于当前事务版本的数据行，确保事务读取的行要么在事务开始前存在，要么是事务自身插入或修改的
    2. 行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事务开始之前未被删除
* insert
    1. 新插入的每一行保存当前系统版本号为行版本号
* delete
    1. 删除的每一行保存当前系统版本号为行删除时间
* update
    1. 插入一行新纪录，保存当前系统版本号为行版本号，同时将当前系统版本号作为原来行的行删除时间

保存这两个额外系统版本号，是大多数读操作都可以不用加锁，提高性能，不足之处是需要额外的存储空间及一些额外的行检查操作。


### 3 复制

Mysql内建的复制功能是构建基于Mysql的大规模、高性能应用的基础，可以通过为服务器配置一个或多个备库的方式来进行数据同步。

#### 3.1 复制概述

复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。

mysql支持两种复制方式：基于行的复制和基于语句的复制。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。这意味着，在同一个时间点备库上的数据可能与主库存在不一致，并且无法保证主备之间的延迟。

复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但是出于备份或从崩溃中恢复的目的，这点开销是必要的。除此之外，每个备库也会对主库增加负载（例如网络IO开销）。

通过复制可以将读操作指向备库来获得更好的读性能，但对于写操作，除非设计得当，否则并不适合通过复制来扩展写操作。

#### 3.2　复制如何工作

总的来说，复制有三个步骤：

1. 在主库上把数据更改记录到二进制日志(Binary Log)中
2. 备库将主库中的日志复制到自己的中继日志(Relay Log)中
3. 备库读取中继日志中的时间，将其重放到备库数据之上

![Mysql复制](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/2019/mysql-log.png)

第一步是在主库上记录二进制日志，在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。Mysql会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。

下一步，备库将主库的二进制日志复制到其本地的中继日志中。首先备库会启动一个工作线程，称为IO线程，IO线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储(binlog dump)线程，这个二进制转储会读取主库上二进制日志中的时间，它不会对事件进行轮询，如果该线程追赶上了主库，将进入睡眠状态，直到主库发送信号量通知其有新的事件产生。备库IO线程会将接受到的事件记录到中继日志中。

备库的SQL线程执行最后异步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据更新。当SQL线程追赶上IO线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL线程执行的事件也可以通过配置决定是否写入自己的二进制日志中。

这套架构实现了获取事件和重放事件的解藕，允许两个过程异步执行。但是备库只有一个SQL线程来重放中继日志，也成为了某些工作服贼的性能瓶颈。

#### 3.3 如何配置复制

上面介绍了复制的过程，但是没有介绍如何配置开启复制，这节将详细介绍如何配置.

大的层面来说有这几个步骤：

1. 在每台服务器上创建复制帐号
2. 配置主库和备库
3. 通知备库连接到主库并复制

假设有两台MYSQL服务器，server1为192.168.0.1，　server2为192.168.0.2

##### 创建复制帐号

mysql会赋予一些特殊的权限给复制线程，在备库运行的IO线程会建立一个到主库的TCP/IP连接，这意味着必须在主库创建一个用户，并赋予其合适的权限。备库IO线程以该用户名连接到主库，并读取其二进制日志。

```sql
GRANT REPLICATION SLAVE, REPILCATION CLIENT ON *.* TO repl@'192.168.0.%' IDENTIFIED BY 'password';
```

在主库和备库上都创建该帐号。因为是特权帐号，所以把账户限制在本地网络。

##### 配置主库和备库

下一步需要在主库上开启一些设置，将设server1是主库，需要打开二进制日志并指定一个独一无二的服务器ID,在主库的`my.cnf`文件中增加或修改如下内容：

```
log_bin   = mysql-bin
server_id = 10
```

实际取值由你觉得。必须明确的指定一个唯一的服务器ID，默认服务器ID通常为1，使用默认值可能导致与其他服务器ID冲突;取值需要保证他是不变的且唯一的，修改完重启服务器。

备库上也需要在`my.cnf`中增加类似的配置，并重启服务器。配置如下：

```
log_bin           = mysql-bin
server_id         = 2
relay_log         = /var/lib/mysql/mysql-relay-bin  ##　中继日志路径
log_slave_updates = 1  ##允许备库将其重放的事件记录到自身的二进制日志中
read_only         = 1
```

从技术角度来说，只有serber_id是必须的。

##### 启动复制

下一步是告诉备库如何连接到主库并重放其日志。这一步不需要修改`my.cnf`来配置，而是使用｀CHANGE MASTER TO`语句，替代了My.cnf中相应的设置，并且允许以后指向别的主库而无须重启。

```SQL
CHANGE MASTER TO MASTER_HOST='server1',
MASTER_USER='repl',
MASTER_PASSWORD='password',
MASTER_LOG_FILE='mysql-bin.000001',
MASTER_LOG_POS=0;
```

### 4　EXPLAIN命令

EXPLAIN命令是查看查询优化器如何决定执行查询的主要方法，它功能有局限性，并不总会说出真相，但大多数情况它的输出是可以获取的最好信息，值得花时间了解。

要使用EXPLAIN，只需在查询中的SELET关键字之前增加EXPLAIN这个词。mysql会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于在执行计划中每一步的信息，而不是执行它。但是如果在FROM子句中包括子查询，那么mysql实际上会执行子查询。

```
mysql> explain select * from identity\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: identity
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
```

在查询中每个表在输出中只有一行，如果查询是两个表的连接，那么输出中将有两行。下面解释一下输出中所有列的含义。

+ **id**:　这一列总是一个编号，标识SELECT所属的行，如果在语句当中没有子查询或联合，那么只会有唯一的SELECT，于是每一行在这个列中都将显示1。否则内层的SELECT语句一般会顺序编号，对应其在原始语句中的位置。

+ **select_type**：　显示了对应行是简单还是复杂SELECT，simple意味着查询不包括子查询和UNION。如果查询有任何复杂的子部分，则最外层部分标记为PRIMARY。
    + SUBQUERY：包含在select列表中的子查询中的select
    + DERIVED：标识包含在FROM子句的子查询中的SELECT
    + UNION:在UNION中的第二个和随后的SELECT被标记为UNION
    + UNION RESULT: 用来从UNION的匿名临时表检索结果的SELECT被标记为UNION RESULT

+ **table**: 正在访问的表的表名或者该表的别名(如果SQL中定义了别名)，如果是派生表或联合时生成的匿名表，形式为<derivedN>或<unionN>

+ **type**: 关联类型，访问类型---mysql决定如何查找表中的行
    + ALL:全表扫描，意味着mysql必须扫描整张表，从头到尾
    + index：这个跟全表扫描一样，只是mysql扫描表时按索引次序进行而不是按行的次序。主要优点是避免了排序，缺点是要承担按索引次序读取整个表的开销，这通常意味着若是按随机次序访问行，开销非常大。如果在Extra列中看到"Using index"说明mysql正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行。比按索引次序全表扫描的开销少很多
    + range：范围扫描是一个有限制的索引扫描，通常是带有between或在where中带有>的查询
    + ref:　一种索引访问，返回所有匹配某个单个值的行，然而它可能会找到多个符合条件的行，如使用非唯一性索引
    + eq_ref：索引查找时mysql知道最多只返回一条符合条件的记录，如使用主键或者唯一性索引
    + const,system：mysql能对查询的某部分进行优化并将其转换成一个常量
    + null:意味着mysql能在优化阶段分解查询语句，在执行阶段甚至不用访问表或者索引

+ **possible_keys**：显示了查询可以使用哪些索引

+ **key**: 显示了mysql决定采用哪个索引来优化对该表的访问。取决于mysql的优化方案

+ **key_len**：　显示了mysql在索引里使用的字节数，通过查找表的定义计算出，而不是通过表中的数据得出

+ **ref**: 显示了之前的表在key列记录的索引中查找值所用的列或常量

+ **rows**:　显示了mysql估计为了找到所需的行而需要读取的行数，只是估算

+ **extra**:包含不适合在其他列显示的额外信息，常见的值包括
    + using inde: 表示mysql将使用覆盖索引，以避免访问表
    + using where:　意味着mysql服务器将在存储引擎检索行后再进行过滤
    + using temporary:意味着mysql在对查询结果排序时会使用一个临时表
    + ...


### 总结

这本书大致看完了，但是很多地方暂时没有接触到，理解不是很深刻，以后在工作中遇到一些场景后，再回头看看一些部分会有更大的收获。

书很厚，有800多页，但是这篇博客只记录了几个点。有几个原因吧。

* 有些内容对目前的我意义不大，了解就好，比如讲述mysql扩展性的那几个章节，我只记录了复制的相关内容，但其实也只是冰山一角。书中还介绍了几种常见的服务器拓扑，比如主主结构，一主多倍等等;其他的内容还包括如何处理错误，切换主备等常见操作，但是目前这些对我意义不大。
* 有的内容太宏观，看一下就能理解大概，但是却不太好记录，没有太强的总结概括能力。比如我记录了复制可以提升读性能，那么如何提升写性能在书中也有介绍到，是通过数据分片。那么在架构层面，提到数据分片也就了解了个大概。那么如何切，什么时候切，怎么创建表结构等都需要具体业务具体分析，书上也列举了几个例子和工具，篇幅过大，不宜记录
* 书中还有很多关于优化查询的部分，包括从设计表结构，系统硬件，应用层优化等等，随笔一个点拿出来都可以写很多，但是水平有限，找不到合适的场景来验证优化的例子，怕误导大家，就不记录了。
* 本来还想记录InnoDB索引的实现，但是发现书上的介绍还不如之前网上查看的博客，于是放弃。

### 欢迎关注我的公众号

欢迎关注我的公众号，会经常分享一些技术文章和生活随笔～

![技术旅途](https://raw.githubusercontent.com/cfk1996/cfk1996.github.io/source/photos/wechat.jpg)